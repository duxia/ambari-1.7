(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var require = function(name, loaderPath) {
    var path = expand(name, '.');
    if (loaderPath == null) loaderPath = '/';

    if (has(cache, path)) return cache[path].exports;
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex].exports;
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '" from '+ '"' + loaderPath + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  var list = function() {
    var result = [];
    for (var item in modules) {
      if (has(modules, item)) {
        result.push(item);
      }
    }
    return result;
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.list = list;
  globals.require.brunch = true;
})();
require.register("test/app_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');
require('models/host_component');
require('models/stack_service_component');
var modelSetup = require('test/init_model_test');

describe('App', function () {

  describe('#stackVersionURL', function () {

    App.QuickViewLinks.reopen({
      loadTags: function () {
      }
    });
    App.set('defaultStackVersion', "HDP-1.2.2");
    App.set('currentStackVersion', "HDP-1.2.2");

    var testCases = [
      {
        title: 'if currentStackVersion and defaultStackVersion are empty then stackVersionURL should contain prefix',
        currentStackVersion: '',
        defaultStackVersion: '',
        result: '/stacks/HDP/versions/'
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: 'HDP-1.3.1',
        defaultStackVersion: '',
        result: '/stacks/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion and currentStackVersion are different then stackVersionURL should have currentStackVersion value',
        currentStackVersion: 'HDP-1.3.2',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/versions/1.3.2'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('defaultStackVersion', test.defaultStackVersion);
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('stackVersionURL')).to.equal(test.result);
        App.set('defaultStackVersion', "HDP-1.2.2");
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#falconServerURL', function () {

    var testCases = [
      {
        title: 'No services installed, url should be empty',
        service: Em.A([]),
        result: ''
      },
      {
        title: 'FALCON is not installed, url should be empty',
        service: Em.A([
          {
            serviceName: 'HDFS'
          }
        ]),
        result: ''
      },
      {
        title: 'FALCON is installed, url should be "host1"',
        service: Em.A([
          Em.Object.create({
            serviceName: 'FALCON',
            hostComponents: [
              Em.Object.create({
                componentName: 'FALCON_SERVER',
                hostName: 'host1'
              })
            ]
          })
        ]),
        result: 'host1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        sinon.stub(App.Service, 'find', function () {
          return test.service;
        });
        expect(App.get('falconServerURL')).to.equal(test.result);
        App.Service.find.restore();
      });
    });
  });

  describe('#currentStackVersionNumber', function () {

    var testCases = [
      {
        title: 'if currentStackVersion is empty then currentStackVersionNumber should be empty',
        currentStackVersion: '',
        result: ''
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDP-1.3.1',
        result: '1.3.1'
      },
      {
        title: 'if currentStackVersion is "HDPLocal-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDPLocal-1.3.1',
        result: '1.3.1'
      }
    ];
    before(function () {
      App.set('defaultStackVersion', '');
    });
    after(function () {
      App.set('defaultStackVersion', 'HDP-2.0.5');
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('currentStackVersionNumber')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#isHadoop2Stack', function () {
    before(function () {
      App.set('defaultStackVersion', '');
    });
    after(function () {
      App.set('defaultStackVersion', 'HDP-2.0.5');
    });
    var testCasesWithoutHDFSDefined = [
      {
        title: 'if currentStackVersion is empty then isHadoop2Stack should be false',
        currentStackVersion: '',
        result: false
      },
      {
        title: 'if currentStackVersion is "HDP-1.9.9" then isHadoop2Stack should be false',
        currentStackVersion: 'HDP-1.9.9',
        result: false
      },
      {
        title: 'if currentStackVersion is "HDP-2.0.0" then isHadoop2Stack should be true',
        currentStackVersion: 'HDP-2.0.0',
        result: true
      },
      {
        title: 'if currentStackVersion is "HDP-2.0.1" then isHadoop2Stack should be true',
        currentStackVersion: 'HDP-2.0.1',
        result: true
      }
    ];

    testCasesWithoutHDFSDefined.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('isHadoop2Stack')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });


    it('HDFS service version should get priority when defined', function () {
      var stackServices = [
        Em.Object.create({
          serviceName: 'HDFS',
          serviceVersion: '2.1'
        })
      ];
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });
      App.set('currentStackVersion', '0.8');
      App.set('isStackServicesLoaded', true);
      expect(App.get('isHadoop2Stack')).to.equal(true);
      App.set('isStackServicesLoaded', false);
      App.set('currentStackVersion', "HDP-1.2.2");
      App.StackService.find.restore();
    });
  });

  describe('#isHaEnabled when HDFS is installed:', function () {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {
            id: 'HDFS',
            serviceName: 'HDFS'
          }
        ];
      });
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    it('if hadoop stack version less than 2 then isHaEnabled should be false', function () {
      App.set('currentStackVersion', 'HDP-1.3.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });
    it('if hadoop stack version higher than 2 then isHaEnabled should be true', function () {
      App.set('currentStackVersion', 'HDP-2.0.1');
      expect(App.get('isHaEnabled')).to.equal(true);
      App.set('currentStackVersion', "HDP-1.2.2");
    });
    it('if cluster has SECONDARY_NAMENODE then isHaEnabled should be false', function () {
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });
  });

  describe('#isHaEnabled when HDFS is not installed:', function () {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {
            id: 'ZOOKEEPER',
            serviceName: 'ZOOKEEPER'
          }
        ];
      });
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    it('if hadoop stack version higher than 2 but HDFS not installed then isHaEnabled should be false', function () {
      App.set('currentStackVersion', 'HDP-2.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });

  });


  describe('#services', function () {
    var stackServices = [
      Em.Object.create({
        serviceName: 'S1',
        isClientOnlyService: true
      }),
      Em.Object.create({
        serviceName: 'S2',
        hasClient: true
      }),
      Em.Object.create({
        serviceName: 'S3',
        hasMaster: true
      }),
      Em.Object.create({
        serviceName: 'S4',
        hasSlave: true
      }),
      Em.Object.create({
        serviceName: 'S5',
        isNoConfigTypes: true
      }),
      Em.Object.create({
        serviceName: 'S6',
        isMonitoringService: true
      }),
      Em.Object.create({
        serviceName: 'S7'
      })
    ];

    it('distribute services by categories', function () {
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });

      expect(App.get('services.all')).to.eql(['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7']);
      expect(App.get('services.clientOnly')).to.eql(['S1']);
      expect(App.get('services.hasClient')).to.eql(['S2']);
      expect(App.get('services.hasMaster')).to.eql(['S3']);
      expect(App.get('services.hasSlave')).to.eql(['S4']);
      expect(App.get('services.noConfigTypes')).to.eql(['S5']);
      expect(App.get('services.monitoring')).to.eql(['S6']);
      App.StackService.find.restore();
    });
  });


  describe('#components', function () {
    var i = 0,
      testCases = [
        {
          key: 'allComponents',
          data: [
            Em.Object.create({
              componentName: 'C1'
            })
          ],
          result: ['C1']
        },
        {
          key: 'reassignable',
          data: [
            Em.Object.create({
              componentName: 'C2',
              isReassignable: true
            })
          ],
          result: ['C2']
        },
        {
          key: 'restartable',
          data: [
            Em.Object.create({
              componentName: 'C3',
              isRestartable: true
            })
          ],
          result: ['C3']
        },
        {
          key: 'deletable',
          data: [
            Em.Object.create({
              componentName: 'C4',
              isDeletable: true
            })
          ],
          result: ['C4']
        },
        {
          key: 'rollinRestartAllowed',
          data: [
            Em.Object.create({
              componentName: 'C5',
              isRollinRestartAllowed: true
            })
          ],
          result: ['C5']
        },
        {
          key: 'decommissionAllowed',
          data: [
            Em.Object.create({
              componentName: 'C6',
              isDecommissionAllowed: true
            })
          ],
          result: ['C6']
        },
        {
          key: 'refreshConfigsAllowed',
          data: [
            Em.Object.create({
              componentName: 'C7',
              isRefreshConfigsAllowed: true
            })
          ],
          result: ['C7']
        },
        {
          key: 'addableToHost',
          data: [
            Em.Object.create({
              componentName: 'C8',
              isAddableToHost: true
            })
          ],
          result: ['C8']
        },
        {
          key: 'addableMasterInstallerWizard',
          data: [
            Em.Object.create({
              componentName: 'C9',
              isMasterAddableInstallerWizard: true
            })
          ],
          result: ['C9']
        },
        {
          key: 'multipleMasters',
          data: [
            Em.Object.create({
              componentName: 'C10',
              isMasterWithMultipleInstances: true
            })
          ],
          result: ['C10']
        },
        {
          key: 'slaves',
          data: [
            Em.Object.create({
              componentName: 'C11',
              isSlave: true
            })
          ],
          result: ['C11']
        },
        {
          key: 'clients',
          data: [
            Em.Object.create({
              componentName: 'C12',
              isClient: true
            })
          ],
          result: ['C12']
        }
      ];

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return testCases[i].data;
      });
    });

    afterEach(function () {
      i++;
      App.StackServiceComponent.find.restore();
    });

    testCases.forEach(function (test) {
      it(test.key + ' should contain ' + test.result, function () {
        expect(App.get('components.' + test.key)).to.eql(test.result);
      })
    })
  });
});

});

;require.register("test/controllers/global/background_operations_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('config');
require('utils/updater');
require('utils/ajax/ajax');

require('models/host_component');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/host_progress_popup');

describe('App.BackgroundOperationsController', function () {

  var controller = App.BackgroundOperationsController.create({
    isInitLoading: Em.K
  });

  describe('#getQueryParams', function () {
    /**
     * Predefined data
     *
     */
    App.set('clusterName', 'testName');
    App.bgOperationsUpdateInterval = 100;

    var tests = Em.A([
      {
        levelInfo: Em.Object.create({
          name: 'REQUESTS_LIST',
          requestId: null,
          taskId: null,
          sync: false
        }),
        e: {
          name: 'background_operations.get_most_recent',
          successCallback: 'callBackForMostRecent',
          data: {
            'operationsCount': 10
          }
        },
        response: {items: []},
        m: '"Get Most Recent"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASK_DETAILS',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_task',
          successCallback: 'callBackFilteredByTask',
          data: {
            taskId: 1,
            requestId: 1
          }
        },
        response: {items: {Tasks: {request_id: 0}}},
        m: '"Filtered By task"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASKS_LIST',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (TASKS_LIST)"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'HOSTS_LIST',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (HOSTS_LIST)"'
      }
    ]);

    beforeEach(function () {
      App.testMode = false;
    });
    afterEach(function () {
      App.testMode = true;
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('levelInfo', test.levelInfo);
        var r = controller.getQueryParams();
        expect(r.name).to.equal(test.e.name);
        expect(r.successCallback).to.equal(test.e.successCallback);
        expect(r.data).to.eql(test.e.data);
      });
    });
  });

  describe('#startPolling()', function () {

    beforeEach(function () {
      sinon.spy(App.updater, 'run');
      sinon.spy(controller, 'requestMostRecent');
    });
    afterEach(function () {
      App.updater.run.restore();
      controller.requestMostRecent.restore();
    });

    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.calledOnce).to.equal(false);
      expect(controller.requestMostRecent.calledOnce).to.equal(false);
    });
    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.calledOnce).to.equal(true);
      expect(controller.requestMostRecent.calledOnce).to.equal(true);
    });
  });

  describe('#callBackForMostRecent()', function () {
    it('No requests exists', function () {
      var data = {
        items: []
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services.length")).to.equal(0);
    });
    it('One non-running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 0,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });


    it('One running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(1);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });
    it('Two requests in order', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: ''
            }
          },
          {
            Requests: {
              id: 2,
              request_context: ''
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([2, 1]);
    });
  });

  describe('#removeOldRequests()', function () {
    var testCases = [
      {
        title: 'No requests exist',
        content: {
          currentRequestIds: [],
          services: []
        },
        result: []
      },
      {
        title: 'One current request',
        content: {
          currentRequestIds: [1],
          services: [
            {id: 1}
          ]
        },
        result: [
          {id: 1}
        ]
      },
      {
        title: 'One old request',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1}
          ]
        },
        result: []
      },
      {
        title: 'One old request and one is current',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1},
            {id: 2}
          ]
        },
        result: [
          {id: 2}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('services', test.content.services);
        controller.removeOldRequests(test.content.currentRequestIds);
        expect(controller.get('services')).to.eql(test.result);
      });
    });
  });

  describe('#isRequestRunning()', function () {
    var testCases = [
      {
        title: 'Counters are missing',
        request: {
          Requests: {}
        },
        result: false
      },
      {
        title: 'Request has zero tasks',
        request: {
          Requests: {
            task_count: 0,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in running status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in queued status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in aborted status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 1,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in completed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 1,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in failed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 1,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status and the second one in running',
        request: {
          Requests: {
            task_count: 2,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in each status',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in each status except queued',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'No tasks in running status',
        request: {
          Requests: {
            task_count: 4,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isRequestRunning(test.request)).to.eql(test.result);
      });
    });
  });

  describe('#isOneHost()', function () {
    var testCases = [
      {
        title: 'inputs is null',
        inputs: null,
        result: false
      },
      {
        title: 'inputs is "null"',
        inputs: 'null',
        result: false
      },
      {
        title: 'inputs is empty object',
        inputs: '{}',
        result: false
      },
      {
        title: 'included_hosts is empty',
        inputs: '{"included_hosts": ""}',
        result: false
      },
      {
        title: 'included_hosts contain one host',
        inputs: '{"included_hosts": "host1"}',
        result: true
      },
      {
        title: 'included_hosts contain two hosts',
        inputs: '{"included_hosts": "host1,host2"}',
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isOneHost(test.inputs)).to.eql(test.result);
      });
    });
  });

  describe('#assignScheduleId()', function () {
    var testCases = [
      {
        title: 'isOneHost is false',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: null
            }
          },
          requestParams: ''
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext is empty',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: ''
          }
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext contains "Recommission"',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: 'Recommission'
          }
        },
        result: null
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.assignScheduleId(test.content.request, test.content.requestParams);
        expect(test.content.request.Requests.request_schedule.schedule_id).to.equal(test.result);
      });
    });
  });

  describe('#callBackFilteredByRequest()', function () {

    it('request haven\'t tasks and isRunning false', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: false,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request haven\'t tasks and isRunning true', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(true);
    });

    it('request has one completed task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED"});
      expect(request.get('hostsMap')['host1'].logTasks.length).to.equal(1);
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request has one completed task and one running task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          },
          {
            Tasks: {
              id: 2,
              host_name: 'host1',
              status: 'IN_PROGRESS'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED", "2": "IN_PROGRESS"});
      expect(request.get('hostsMap')['host1'].logTasks.length).to.equal(2);
      expect(request.get('isRunning')).to.equal(true);
    });
  });
});

});

;require.register("test/controllers/global/cluster_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/cluster_controller');
require('models/host_component');
require('utils/http_client');
require('models/service');
require('models/host');
require('utils/ajax/ajax');

var modelSetup = require('test/init_model_test');

describe('App.clusterController', function () {
  var controller = App.ClusterController.create();
  App.Service.FIXTURES = [
    {service_name: 'NAGIOS'}
  ];

  describe('#updateLoadStatus()', function () {

    controller.set('dataLoadList', Em.Object.create({
      'item1': false,
      'item2': false
    }));

    it('when none item is loaded then width should be "width:0"', function () {
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:0');
    });
    it('when first item is loaded then isLoaded should be false', function () {
      controller.updateLoadStatus.call(controller, 'item1');
      expect(controller.get('isLoaded')).to.equal(false);
    });
    it('when first item is loaded then width should be "width:50%"', function () {
      controller.updateLoadStatus.call(controller, 'item1');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:50%');
    });

    it('when all items are loaded then isLoaded should be true', function () {
      controller.updateLoadStatus.call(controller, 'item2');
      expect(controller.get('isLoaded')).to.equal(true);
    });
    it('when all items are loaded then width should be "width:100%"', function () {
      controller.updateLoadStatus.call(controller, 'item2');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:100%');
    });
  });

  describe('#loadClusterName()', function () {

    beforeEach(function () {
      modelSetup.setupStackVersion(this, 'HDP-2.0.5');
      sinon.stub(App.ajax, 'send', function () {
        return {
          complete: function (callback) {
            App.set('clusterName', 'clusterNameFromServer');
            App.set('currentStackVersion', 'HDP-2.0.5');
            callback();
          }
        }
      });
    });
    afterEach(function () {
      modelSetup.restoreStackVersion(this);
      App.ajax.send.restore();
    });

    it('if clusterName is "mycluster" and reload is false then clusterName stays the same', function () {
      App.set('clusterName', 'mycluster');
      controller.loadClusterName(false);
      expect(App.ajax.send.called).to.be.false;
      expect(App.get('clusterName')).to.equal('mycluster');
    });

    it('reload is true and clusterName is not empty', function () {
      controller.loadClusterName(true);
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(App.get('clusterName')).to.equal('clusterNameFromServer');
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });

    it('reload is false and clusterName is empty', function () {
      App.set('clusterName', '');
      controller.loadClusterName(false);
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(App.get('clusterName')).to.equal('clusterNameFromServer');
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });


  });

  describe('#loadClusterNameSuccessCallback', function () {
    var test_data = {
      "items": [
        {
          "Clusters": {
            "cluster_name": "tdk",
            "version": "HDP-1.3.0"
          }
        }
      ]
    };
    it('Check cluster', function () {
      controller.loadClusterNameSuccessCallback(test_data);
      expect(App.get('clusterName')).to.equal('tdk');
      expect(App.get('currentStackVersion')).to.equal('HDP-1.3.0');
    });
  });

  describe('#loadClusterNameErrorCallback', function () {
    controller.loadClusterNameErrorCallback();
    it('', function () {
      expect(controller.get('isLoaded')).to.equal(true);
    });
  });

  describe('#getServerClockSuccessCallback()', function () {
    var testCases = [
      {
        title: 'if server clock is 1 then currentServerTime should be 1000',
        data: {
          RootServiceComponents: {
            server_clock: 1
          }
        },
        result: 1000
      },
      {
        title: 'if server clock is 0 then currentServerTime should be 0',
        data: {
          RootServiceComponents: {
            server_clock: 0
          }
        },
        result: 0
      },
      {
        title: 'if server clock is 111111111111 then currentServerTime should be 111111111111000',
        data: {
          RootServiceComponents: {
            server_clock: 111111111111
          }
        },
        result: 111111111111000
      },
      {
        title: 'if server clock is 1111111111113 then currentServerTime should be 1111111111113',
        data: {
          RootServiceComponents: {
            server_clock: 1111111111113
          }
        },
        result: 1111111111113
      }
    ];
    var currentServerTime = App.get('currentServerTime');
    var clockDistance = App.get('clockDistance');

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.getServerClockSuccessCallback(test.data);
        expect(App.get('currentServerTime')).to.equal(test.result);
        App.set('clockDistance', clockDistance);
        App.set('currentServerTime', currentServerTime);
      });
    });
  });

  describe('#getUrl', function () {
    controller.set('clusterName', 'tdk');
    var tests = ['test1', 'test2', 'test3'];
    it('testMode = true', function () {
      App.testMode = true;
      tests.forEach(function (test) {
        expect(controller.getUrl(test, test)).to.equal(test);
      });
    });
    it('testMode = false', function () {
      App.testMode = false;
      tests.forEach(function (test) {
        expect(controller.getUrl(test, test)).to.equal(App.apiPrefix + '/clusters/' + controller.get('clusterName') + test);
      });
    });
  });

  describe('#setGangliaUrl()', function () {
    beforeEach(function () {
      controller.set('gangliaUrl', null);
    });

    it('testMode = true', function () {
      App.testMode = true;
      controller.setGangliaUrl();
      expect(controller.get('gangliaUrl')).to.equal('http://gangliaserver/ganglia/?t=yes');
      expect(controller.get('isGangliaUrlLoaded')).to.be.true;
    });
    it('Cluster is not loaded', function () {
      App.testMode = false;
      controller.set('isLoaded', false);
      controller.setGangliaUrl();
      expect(controller.get('gangliaUrl')).to.equal(null);
    });
    it('GANGLIA_SERVER component is absent', function () {
      controller.set('isLoaded', true);
      App.testMode = false;
      sinon.stub(App.HostComponent, 'find', function(){
        return [];
      });
      controller.setGangliaUrl();
      expect(controller.get('gangliaUrl')).to.equal(null);
      App.HostComponent.find.restore();
    });
    it('Ganglia Server host is "GANGLIA_host"', function () {
      controller.set('isLoaded', true);
      App.testMode = false;
      sinon.stub(App.HostComponent, 'find', function(){
        return [Em.Object.create({
          componentName: 'GANGLIA_SERVER',
          hostName: 'GANGLIA_host'
        })];
      });
      sinon.spy(App.ajax, 'send');

      controller.setGangliaUrl();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.get('isGangliaUrlLoaded')).to.be.false;

      App.HostComponent.find.restore();
      App.ajax.send.restore();
    });
  });

  describe('#setNagiosUrl()', function () {
    beforeEach(function () {
      controller.set('nagiosUrl', null);
    });

    it('testMode = true', function () {
      App.testMode = true;
      controller.setNagiosUrl();
      expect(controller.get('nagiosUrl')).to.equal('http://nagiosserver/nagios');
      expect(controller.get('isNagiosUrlLoaded')).to.be.true;

    });
    it('Cluster is not loaded', function () {
      App.testMode = false;
      controller.set('isLoaded', false);
      controller.setNagiosUrl();
      expect(controller.get('nagiosUrl')).to.equal(null);
    });
    it('GANGLIA_SERVER component is absent', function () {
      controller.set('isLoaded', true);
      App.testMode = false;
      sinon.stub(App.HostComponent, 'find', function(){
        return [];
      });
      controller.setNagiosUrl();
      expect(controller.get('nagiosUrl')).to.equal(null);
      App.HostComponent.find.restore();
    });
    it('Ganglia Server host is "NAGIOS_host"', function () {
      controller.set('isLoaded', true);
      App.testMode = false;
      sinon.stub(App.HostComponent, 'find', function(){
        return [Em.Object.create({
          componentName: 'NAGIOS_SERVER',
          hostName: 'NAGIOS_host'
        })];
      });
      sinon.spy(App.ajax, 'send');
      controller.setNagiosUrl();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.get('isNagiosUrlLoaded')).to.be.false;
      App.ajax.send.restore();
      App.HostComponent.find.restore();
    });
  });

  describe('#nagiosWebProtocol', function () {
    var testCases = [
      {
        title: 'if ambariProperties is null then nagiosWebProtocol should be "http"',
        data: null,
        result: 'http'
      },
      {
        title: 'if ambariProperties is empty object then nagiosWebProtocol should be "http"',
        data: {},
        result: 'http'
      },
      {
        title: 'if nagios.https is false then nagiosWebProtocol should be "http"',
        data: {'nagios.https': false},
        result: 'http'
      },
      {
        title: 'if nagios.https is true then nagiosWebProtocol should be "http"',
        data: {'nagios.https': true},
        result: 'https'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('ambariProperties', test.data);
        expect(controller.get('nagiosWebProtocol')).to.equal(test.result);
      });
    });
  });

  describe('#gangliaWebProtocol', function () {
    var testCases = [
      {
        title: 'if ambariProperties is null then nagiosWebProtocol should be "http"',
        data: null,
        result: 'http'
      },
      {
        title: 'if ambariProperties is empty object then nagiosWebProtocol should be "http"',
        data: {},
        result: 'http'
      },
      {
        title: 'if nagios.https is false then nagiosWebProtocol should be "http"',
        data: {'ganglia.https': false},
        result: 'http'
      },
      {
        title: 'if nagios.https is true then nagiosWebProtocol should be "http"',
        data: {'ganglia.https': true},
        result: 'https'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('ambariProperties', test.data);
        expect(controller.get('gangliaWebProtocol')).to.equal(test.result);
      });
    });
  });


  describe('#setGangliaUrlSuccessCallback()', function () {

    it('Query return no hosts', function () {
      controller.setGangliaUrlSuccessCallback({items: []});
      expect(controller.get('gangliaUrl')).to.equal(null);
      expect(controller.get('isGangliaUrlLoaded')).to.be.true;
    });
    it('App.singleNodeInstall is true', function () {
      controller.reopen({
        gangliaWebProtocol: 'http'
      });
      App.set('singleNodeInstall', true);
      App.set('singleNodeAlias', 'localhost');
      controller.setGangliaUrlSuccessCallback({items: [{
        Hosts: {
          public_host_name: 'host1'
        }
      }]});
      expect(controller.get('gangliaUrl')).to.equal('http://localhost:42080/ganglia');
      expect(controller.get('isGangliaUrlLoaded')).to.be.true;
    });
    it('App.singleNodeInstall is false', function () {
      controller.reopen({
        gangliaWebProtocol: 'http'
      });
      App.set('singleNodeInstall', false);
      App.set('singleNodeAlias', 'localhost');
      controller.setGangliaUrlSuccessCallback({items: [{
        Hosts: {
          public_host_name: 'host1'
        }
      }]});
      expect(controller.get('gangliaUrl')).to.equal('http://host1/ganglia');
      expect(controller.get('isGangliaUrlLoaded')).to.be.true;
    });
  });

  describe('#setNagiosUrlSuccessCallback()', function () {

    it('Query return no hosts', function () {
      controller.setNagiosUrlSuccessCallback({items: []});
      expect(controller.get('nagiosUrl')).to.equal(null);
      expect(controller.get('isNagiosUrlLoaded')).to.be.true;
    });
    it('App.singleNodeInstall is true', function () {
      controller.reopen({
        nagiosWebProtocol: 'http'
      });
      App.set('singleNodeInstall', true);
      App.set('singleNodeAlias', 'localhost');
      controller.setNagiosUrlSuccessCallback({items: [{
        Hosts: {
          public_host_name: 'host1'
        }
      }]});
      expect(controller.get('nagiosUrl')).to.equal('http://localhost:42080/nagios');
      expect(controller.get('isNagiosUrlLoaded')).to.be.true;
    });
    it('App.singleNodeInstall is false', function () {
      controller.reopen({
        nagiosWebProtocol: 'http'
      });
      App.set('singleNodeInstall', false);
      App.set('singleNodeAlias', 'localhost');
      controller.setNagiosUrlSuccessCallback({items: [{
        Hosts: {
          public_host_name: 'host1'
        }
      }]});
      expect(controller.get('nagiosUrl')).to.equal('http://host1/nagios');
      expect(controller.get('isNagiosUrlLoaded')).to.be.true;
    });
  });
});

});

;require.register("test/controllers/global/configuration_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/configuration_controller');


describe('App.ConfigurationController', function () {
  var controller = App.ConfigurationController.create();

  describe('#checkTagsChanges()', function () {
    var testCases = [
      {
        title: 'Tags haven\'t been uploaded',
        content: {
          tags: [],
          storedTags: []
        },
        result: false
      },
      {
        title: 'New tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: []
        },
        result: true
      },
      {
        title: 'Existing tag with with new tagName',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site1',
              tagName: 2
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags with different tagNames',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'One new tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            },
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags haven\'t been changed',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.checkTagsChanges(test.content.tags, test.content.storedTags)).to.equal(test.result);
      });
    });
  });
});
});

;require.register("test/controllers/global/update_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/updater');
require('controllers/global/update_controller');

describe('App.UpdateController', function () {
  var controller = App.UpdateController.create({
    clusterName: '',
    location: '',
    updateServiceMetric: function(){}
  });

  describe('#getUrl()', function () {

    it('testMode = true', function () {
      App.set('testMode', true);
      expect(controller.getUrl('test', '/real')).to.equal('test');
    });

    it('testMode = false', function () {
      App.set('testMode', false);
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters//real');
    });

    it('testMode = false', function () {
      App.set('testMode', false);
      controller.set('clusterName', 'mycluster');
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters/mycluster/real');
    });
  });

  describe('#updateAll()', function () {

    beforeEach(function () {
      sinon.stub(App.updater, 'run', Em.K);
    });
    afterEach(function () {
      App.updater.run.restore();
    });
    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.called).to.equal(false);
    });

    it('isWorking = true, App.supports.hostOverrides = false', function () {
      App.supports.hostOverrides = false;
      controller.set('isWorking', true);
      expect(App.updater.run.callCount).to.equal(5);
      controller.set('isWorking', false);
    });

    it('isWorking = true, App.supports.hostOverrides = true', function () {
      App.supports.hostOverrides = true;
      controller.set('isWorking', true);
      expect(App.updater.run.callCount).to.equal(6);
    });
  });

  describe('#updateServiceMetricConditionally()', function () {
    var context = {
      callback: function(){}
    };

    beforeEach(function () {
      sinon.spy(controller, 'updateServiceMetric');
      sinon.spy(context, 'callback');
    });
    afterEach(function () {
      controller.updateServiceMetric.restore();
      context.callback.restore();
    });

    it('location is empty', function () {
      controller.set('location', '');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(false);
      expect(context.callback.called).to.equal(true);
    });
    it('location is "/main/hosts"', function () {
      controller.set('location', '/main/hosts');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(false);
      expect(context.callback.called).to.equal(true);
    });
    it('location is "/main/dashboard"', function () {
      controller.set('location', '/main/dashboard');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
    it('location is "/main/services/HDFS"', function () {
      controller.set('location', '/main/services/HDFS');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
  });


  describe('#getConditionalFields()', function () {

    var testCases = [
      {
        title: 'No services exist',
        services: [],
        result: []
      },
      {
        title: 'HDFS service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HDFS'
            }
          }
        ],
        result: []
      },
      {
        title: 'FLUME service',
        services: [
          {
            ServiceInfo: {
              service_name: 'FLUME'
            }
          }
        ],
        result: ["host_components/metrics/flume/flume,"+
          "host_components/processes/HostComponentProcess"]
      },
      {
        title: 'YARN service',
        services: [
          {
            ServiceInfo: {
              service_name: 'YARN'
            }
          }
        ],
        result: ["host_components/metrics/yarn/Queue," +
          "ServiceComponentInfo/rm_metrics/cluster/activeNMcount," +
          "ServiceComponentInfo/rm_metrics/cluster/unhealthyNMcount," +
          "ServiceComponentInfo/rm_metrics/cluster/rebootedNMcount," +
          "ServiceComponentInfo/rm_metrics/cluster/decommissionedNMcount"]
      },
      {
        title: 'HBASE service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HBASE'
            }
          }
        ],
        result: ["host_components/metrics/hbase/master/IsActiveMaster," +
          "ServiceComponentInfo/MasterStartTime," +
          "ServiceComponentInfo/MasterActiveTime," +
          "ServiceComponentInfo/AverageLoad," +
          "ServiceComponentInfo/Revision," +
          "ServiceComponentInfo/RegionsInTransition"]
      },
      {
        title: 'MAPREDUCE service',
        services: [
          {
            ServiceInfo: {
              service_name: 'MAPREDUCE'
            }
          }
        ],
        result: ["ServiceComponentInfo/AliveNodes," +
          "ServiceComponentInfo/GrayListedNodes," +
          "ServiceComponentInfo/BlackListedNodes," +
          "ServiceComponentInfo/jobtracker/*,"]
      },
      {
        title: 'STORM service',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        result: ["metrics/api/v1/cluster/summary," +
          "metrics/api/v1/topology/summary"]
      }
    ];

    var testCasesByStackVersion = [
      {
        title: 'STORM service stack 2.1',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.1',
        result: ["metrics/api/cluster/summary"]
      },
      {
        title: 'STORM service stack 2.2',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.2',
        result: ["metrics/api/v1/cluster/summary,metrics/api/v1/topology/summary"]
      }
    ];
    testCases.forEach(function(test){
      it(test.title, function () {
        App.cache['services'] = test.services;
        expect(controller.getConditionalFields()).to.eql(test.result);
      });
    });

    testCasesByStackVersion.forEach(function(test) {
      it(test.title, function() {
        App.cache['services'] = test.services;
        sinon.stub(App, 'get', function(key) {
          if (key == 'currentStackVersionNumber') {
            return test.stackVersionNumber;
          }
        });
        expect(controller.getConditionalFields()).to.eql(test.result);
        App.get.restore();
      });
    });
  });
});

});

;require.register("test/controllers/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/installer');

describe('App.InstallerController', function () {

  var installerController = App.InstallerController.create();

  describe('#loadStacksVersionsSuccessCallback', function() {
    beforeEach(function () {
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function () {
      App.store.commit.restore();
    });
    it ('Correct data', function() {
      installerController.loadStacksVersionsSuccessCallback(require('test/stack'));
      expect(installerController.get('content.stacks.length')).to.equal(2);
      expect(installerController.get('content.stacks').everyProperty('isSelected')).to.equal(false);
      expect(installerController.get('content.stacks').mapProperty('id')).to.eql(['HDP-2.1','HDP-1.3']);
    });
  });

  describe('#getServerVersionSuccessCallback', function () {

    var cases = [
        {
          osType: 'redhat5',
          expected: false
        },
        {
          osType: 'redhat6',
          expected: true
        },
        {
          osType: 'sles11',
          expected: false
        }
      ],
      title = 'App.isManagedMySQLForHiveEnabled should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osType), function () {
        installerController.getServerVersionSuccessCallback({
          'RootServiceComponents': {
            'component_version': '',
            'properties': {
              'server.os_type': item.osType
            }
          }
        });
        expect(App.get('isManagedMySQLForHiveEnabled')).to.equal(item.expected);
      });
    });

  });

});

});

;require.register("test/controllers/main/admin/highAvailability/progress_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.HighAvailabilityProgressPageController', function () {

  var controller = App.HighAvailabilityProgressPageController.create();

  describe('#reconfigureSites()', function () {
    var tests = [
      {
        content: {
          controllerName: "rMHighAvailabilityWizardController"
        },
        siteNames: ["site1", "site2"],
        data: {
          items: [
            {
              type: "site1",
              properties: {
                site1_property1: "site1_property1_value",
                site1_property2: "site1_property2_value"
              },
              properties_attributes: {
                final: {
                  site1_property1: "true"
                }
              }
            },
            {
              type: "site2",
              properties: {
                site2_property1: "site2_property1_value",
                site2_property2: "site2_property2_value"
              }
            },
            {
              type: "site3",
              properties: {
                site3_property: "site3_property_value"
              }
            }
          ]
        },
        result: [
          {
            type: "site1",
            tag: "version1",
            properties: {
              site1_property1: "site1_property1_value",
              site1_property2: "site1_property2_value"
            },
            service_config_version_note: Em.I18n.t('admin.highAvailability.step4.save.configuration.note').format("ResourceManager"),
            properties_attributes: {
              final: {
                site1_property1: "true"
              }
            }
          },
          {
            type: "site2",
            tag: "version1",
            properties: {
              site2_property1: "site2_property1_value",
              site2_property2: "site2_property2_value"
            },
            service_config_version_note: Em.I18n.t('admin.highAvailability.step4.save.configuration.note').format("ResourceManager")
          }
        ]
      },
      {
        content: {
          controllerName: "anyOther"
        },
        siteNames: ["site1"],
        data: {
          items: [
            {
              type: "site1",
              properties: {
                site1_property1: "site1_property1_value",
                site1_property2: "site1_property2_value"
              },
              properties_attributes: {
                final: {
                  site1_property1: "true"
                }
              }
            }
          ]
        },
        result: [
          {
            type: "site1",
            tag: "version1",
            properties: {
              site1_property1: "site1_property1_value",
              site1_property2: "site1_property2_value"
            },
            service_config_version_note: Em.I18n.t('admin.highAvailability.step4.save.configuration.note').format("NameNode"),
            properties_attributes: {
              final: {
                site1_property1: "true"
              }
            }
          }
        ]
      }];
    beforeEach(function() {
      App.set('testMode', true);
    });
    afterEach(function() {
      App.set('testMode', false);
    });
    it("reconfigures configs after HA", function() {
      tests.forEach(function(t) {
        controller.set('content', t.content);
        expect(controller.reconfigureSites(t.siteNames, t.data)).to.eql(t.result);
      });
    });
  });

});

});

;require.register("test/controllers/main/admin/highAvailability_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.MainAdminHighAvailabilityController', function () {

  var controller = App.MainAdminHighAvailabilityController.create();

  describe('#enableHighAvailability()', function () {

    var hostComponents = [];

    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(App.HostComponent, 'find', function(){
        return hostComponents;
      });
      sinon.spy(controller, "showErrorPopup");
    });
    afterEach(function () {
      App.router.transitionTo.restore();
      controller.showErrorPopup.restore();
      App.HostComponent.find.restore();
    });

    it('Security enabled', function () {
      sinon.stub(controller, 'get', function (k) {
        if (k === 'securityEnabled') return true;
        return Em.get(controller, k);
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      controller.get.restore();
    });
    it('NAMENODE in INSTALLED state', function () {
      sinon.stub(controller, 'get', function (k) {
        if (k === 'securityEnabled') return false;
        return Em.get(controller, k);
      });
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];

      sinon.stub(App.router, 'get', function(){
        return 3;
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      App.router.get.restore();
      controller.get.restore();
    });
    it('Cluster has less than 3 ZOOKEPER_SERVER components', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        })
      ];

      sinon.stub(App.router, 'get', function(){
        return 3;
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.called).to.be.true;
      App.router.get.restore();
    });
    it('total hosts number less than 3', function () {
      sinon.stub(controller, 'get', function (k) {
        if (k === 'securityEnabled') return false;
        return Em.get(controller, k);
      });
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];
      sinon.stub(App.router, 'get', function () {
        return 1;
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      App.router.get.restore();
      controller.get.restore();
    });
    it('All checks passed', function () {
      sinon.stub(controller, 'get', function (k) {
        if (k === 'securityEnabled') return false;
        return Em.get(controller, k);
      });
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];
      sinon.stub(App.router, 'get', function(){
        return 3;
      });
      expect(controller.enableHighAvailability()).to.be.true;
      expect(App.router.transitionTo.calledWith('main.services.enableHighAvailability')).to.be.true;
      expect(controller.showErrorPopup.calledOnce).to.be.false;
      App.router.get.restore();
      controller.get.restore();
    });
  });

  describe('#joinMessage()', function () {
    it('message is empty', function () {
      var message = [];
      expect(controller.joinMessage(message)).to.be.empty;
    });
    it('message is array from two strings', function () {
      var message = ['yes', 'no'];
      expect(controller.joinMessage(message)).to.equal('yes<br/>no');
    });
    it('message is string', function () {
      var message = 'hello';
      expect(controller.joinMessage(message)).to.equal('<p>hello</p>');
    });
  });

});

});

;require.register("test/controllers/main/admin/repositories_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/repositories');

describe('App.MainAdminRepositoriesController', function() {
  var controller;
  var data = {
    "items": [
      {
        "Versions": {
          "stack_version": "1.3.1",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "1.3.0",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "1.2.2",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "1.2.0",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "2.0.5",
          "min_upgrade_version": "2.0.0"
        }
      },
      {
        "Versions": {
          "stack_version": "2.0.5",
          "min_upgrade_version": "2.0.5"
        }
      }
    ]
  };

  beforeEach(function() {
    controller = App.MainAdminRepositoriesController.create({
      parseServicesInfo: Em.K
    });
  });

  //todo should be verified
  describe('#updateUpgradeVersionSuccessCallback()', function () {
    it('upgrade version of stack should be "HDP-1.2.2"', function () {
      App.set('currentStackVersion', 'HDP-1.2.2');
      controller.updateUpgradeVersionSuccessCallback.call(controller, data);
      expect(controller.get('upgradeVersion')).to.equal('HDP-1.2.2');
    });
    it('if min upgrade version less then current then upgrade version equal current', function () {
      App.set('currentStackVersion', 'HDP-1.2.2');
      data.items[0].Versions.min_upgrade_version = "1.2.3";
      controller.updateUpgradeVersionSuccessCallback.call(controller, data);
      expect(controller.get('upgradeVersion')).to.equal('HDP-1.2.2');
    })
  });
});

});

;require.register("test/controllers/main/admin/security/add/addSecurity_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('mixins/common/localStorage');
require('controllers/wizard');
require('controllers/main/admin/security/add/addSecurity_controller');
require('models/cluster');
require('models/service');

describe('App.AddSecurityController', function () {

  var controller = App.AddSecurityController.create({
    currentStep: null,
    content: Em.Object.create({
      isATSInstalled: true,
      services: [],
      isNnHa: 'false',
      serviceConfigProperties: null
    })
  });

  describe('#installedServices', function () {

    afterEach(function () {
      App.Service.find.restore();
    });

    it('No installed services', function () {
      sinon.stub(App.Service, 'find', function () {
        return [];
      });
      expect(controller.get('installedServices')).to.eql([]);
    });
    it('One service installed', function () {
      sinon.stub(App.Service, 'find', function () {
        return [Em.Object.create({serviceName: 'HDFS'})];
      });
      Em.propertyDidChange(controller, 'installedServices');
      expect(controller.get('installedServices')).to.eql(['HDFS']);
    });
  });

  describe('#secureServices', function () {

    afterEach(function () {
      App.get.restore();
    });

    it('App.isHadoop2Stack = false', function () {
      var result = [
        "GENERAL",
        "HDFS",
        "MAPREDUCE",
        "HIVE",
        "HBASE",
        "ZOOKEEPER",
        "OOZIE",
        "NAGIOS"
      ];
      sinon.stub(App, 'get', function () {
        return false;
      });
      Em.propertyDidChange(App, 'isHadoop2Stack');
      expect(controller.get('secureServices').mapProperty('serviceName')).to.eql(result);
    });
    it('App.isHadoop2Stack = true', function () {
      var result = [
        "GENERAL",
        "HDFS",
        "MAPREDUCE2",
        "YARN",
        "HIVE",
        "HBASE",
        "ZOOKEEPER",
        "OOZIE",
        "NAGIOS",
        "STORM",
        "FALCON",
        "KNOX"
      ];
      sinon.stub(App, 'get', function () {
        return true;
      });
      Em.propertyDidChange(App, 'isHadoop2Stack');
      expect(controller.get('secureServices').mapProperty('serviceName')).to.eql(result);
    });
  });

  describe('#loadAllPriorSteps()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'loadServiceConfigs', Em.K);
      sinon.stub(controller, 'loadServices', Em.K);
      sinon.stub(controller, 'loadNnHaStatus', Em.K);
    });
    afterEach(function () {
      controller.loadServiceConfigs.restore();
      controller.loadServices.restore();
      controller.loadNnHaStatus.restore();
    });

    var commonSteps = ['4', '3', '2'];
    commonSteps.forEach(function (step) {
      it('Current step - ' + step, function () {
        controller.set('currentStep', step);
        controller.loadAllPriorSteps();
        expect(controller.loadServiceConfigs.calledOnce).to.be.true;
        expect(controller.loadServices.calledOnce).to.be.true;
        expect(controller.loadNnHaStatus.calledOnce).to.be.true;
      });
    });
    it('Current step - 1', function () {
      controller.set('currentStep', '1');
      controller.loadAllPriorSteps();
      expect(controller.loadServiceConfigs.called).to.be.false;
      expect(controller.loadServices.calledOnce).to.be.true;
      expect(controller.loadNnHaStatus.calledOnce).to.be.true;
    });
  });

  describe('#loadServices()', function () {
    it('No installed services', function () {
      controller.reopen({
        installedServices: [],
        secureServices: [
          {serviceName: 'GENERAL'}
        ]
      });
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL']);
    });
    it('Installed service does not match the secure one', function () {
      controller.set('installedServices', ["HDFS"]);
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL']);
    });
    it('Installed service matches the secure one', function () {
      controller.set('secureServices', [
        {serviceName: 'GENERAL'},
        {serviceName: 'HDFS'}
      ]);
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL', 'HDFS']);
    });
  });

  describe('#loadNnHaStatus()', function () {
    afterEach(function () {
      App.db.getIsNameNodeHa.restore();
    });
    it('NameNode HA is off', function () {
      sinon.stub(App.db, 'getIsNameNodeHa', function () {
        return false;
      });
      controller.loadNnHaStatus();
      expect(controller.get('content.isNnHa')).to.be.false;
    });
    it('NameNode HA is on', function () {
      sinon.stub(App.db, 'getIsNameNodeHa', function () {
        return true;
      });
      controller.loadNnHaStatus();
      expect(controller.get('content.isNnHa')).to.be.true;
    });
  });

  describe('#loadServiceConfigs()', function () {
    afterEach(function () {
      App.db.getSecureConfigProperties.restore();
    });
    it('SecureConfigProperties is empty', function () {
      sinon.stub(App.db, 'getSecureConfigProperties', function () {
        return [];
      });
      controller.loadServiceConfigs();
      expect(controller.get('content.serviceConfigProperties')).to.eql([]);
    });
    it('SecureConfigProperties has one config', function () {
      sinon.stub(App.db, 'getSecureConfigProperties', function () {
        return [{}];
      });
      controller.loadServiceConfigs();
      expect(controller.get('content.serviceConfigProperties')).to.eql([{}]);
    });
  });

  describe('#getConfigOverrides()', function () {
    var testCases = [
      {
        title: 'overrides is null',
        configProperty: Em.Object.create({overrides: null}),
        result: null
      },
      {
        title: 'overrides is empty',
        configProperty: Em.Object.create({overrides: []}),
        result: null
      },
      {
        title: 'overrides has one override',
        configProperty: Em.Object.create({
          overrides: [
            Em.Object.create({
              value: 'value1',
              selectedHostOptions: []
            })
          ]
        }),
        result: [{
          value: 'value1',
          hosts: []
        }]
      },
      {
        title: 'overrides has one override with hosts',
        configProperty: Em.Object.create({
          overrides: [
            Em.Object.create({
              value: 'value1',
              selectedHostOptions: ['host1']
            })
          ]
        }),
        result: [{
          value: 'value1',
          hosts: ['host1']
        }]
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function () {
        expect(controller.getConfigOverrides(test.configProperty)).to.eql(test.result);
      });
    });
  });

  describe('#saveServiceConfigProperties()', function () {
    var testCases = [
      {
        title: 'stepConfigs is empty',
        stepController: Em.Object.create({
          stepConfigs: []
        }),
        result: []
      },
      {
        title: 'No configs in service',
        stepController: Em.Object.create({
          stepConfigs: [
            Em.Object.create({configs: []})
          ]
        }),
        result: []
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        sinon.stub(App.db, 'setSecureConfigProperties', Em.K);
        controller.saveServiceConfigProperties(test.stepController);
        expect(App.db.setSecureConfigProperties.calledWith(test.result)).to.be.true;
        expect(controller.get('content.serviceConfigProperties')).to.eql(test.result);
        App.db.setSecureConfigProperties.restore();
      });
    });
    it('Service has config', function () {
      var  stepController = Em.Object.create({
        stepConfigs: [
          Em.Object.create({configs: [
            Em.Object.create({
              name: 'config1',
              value: 'value1'
            })
          ]})
        ]
      });
      sinon.stub(App.db, 'setSecureConfigProperties', Em.K);
      controller.saveServiceConfigProperties(stepController);
      expect(App.db.setSecureConfigProperties.calledOnce).to.be.true;
      expect(controller.get('content.serviceConfigProperties').mapProperty('name')).to.eql(['config1']);
      App.db.setSecureConfigProperties.restore();
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step1_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step1');
require('models/service');
var controller;
describe('App.MainAdminSecurityAddStep1Controller', function () {

  beforeEach(function () {
    controller = App.MainAdminSecurityAddStep1Controller.create({
      content: {}
    });
  });

  describe('#shouldRemoveATS()', function () {

    var tests = Em.A([
      {
        doesATSSupportKerberos: true,
        isATSInstalled: true,
        e: false
      },
      {
        doesATSSupportKerberos: true,
        isATSInstalled: false,
        e: false
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: true,
        e: true
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: false,
        e: false
      }
    ]);

    tests.forEach(function (test) {
      it('', function () {
        controller.set('content.isATSInstalled', test.isATSInstalled);
        sinon.stub(App, 'get', function (k) {
          if ('doesATSSupportKerberos' === k) return test.doesATSSupportKerberos;
          return Em.get(App, k);
        });
        var result = controller.shouldRemoveATS();
        App.get.restore();
        expect(result).to.equal(test.e);
      });
    });

  });
});

});

;require.register("test/controllers/main/admin/security/add/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step2');
require('models/service');

describe('App.MainAdminSecurityAddStep2Controller', function () {

  var controller = App.MainAdminSecurityAddStep2Controller.create({
    content: {}
  });

  describe('#clearStep()', function () {
    it('Info is empty', function () {
      controller.set('stepConfigs', []);
      controller.set('securityUsers', []);
      controller.clearStep();
      expect(controller.get('stepConfigs')).to.be.empty;
      expect(controller.get('securityUsers')).to.be.empty;
    });
    it('Info filled', function () {
      controller.set('stepConfigs', [1]);
      controller.set('securityUsers', [1]);
      controller.clearStep();
      expect(controller.get('stepConfigs')).to.be.empty;
      expect(controller.get('securityUsers')).to.be.empty;
    });
  });

  describe('#isSubmitDisabled', function () {
    var tests = [
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          }
        ],
        m: 'All show configs, nothing with errors',
        e: false
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          },
          {
            showConfig: true,
            errorCount: 1
          }
        ],
        m: 'All show configs, 1 with errors',
        e: true
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          },
          {
            showConfig: false,
            errorCount: 1
          }
        ],
        m: '1 has errors but not visible',
        e: false
      },
      {
        config: [
          {
            showConfig: false,
            errorCount: 0
          },
          {
            showConfig: false,
            errorCount: 1
          }
        ],
        m: '1 has errors, all not visible',
        e: false
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 1
          },
          {
            showConfig: true,
            errorCount: 1
          }
        ],
        m: 'All has errors, all not visible',
        e: true
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('stepConfigs', test.config);
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });
  });

  describe('#loadStep()', function () {
    it('load step', function () {
      controller.set('stepConfigs', [
        {}
      ]);
      controller.set('securityUsers', ['user1']);
      controller.set('content.services', ['service1']);
      controller.set('content.serviceConfigProperties', ['config1']);
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'loadUsers', Em.K);
      sinon.stub(controller, 'addUserPrincipals', Em.K);
      sinon.stub(controller, 'renderServiceConfigs', Em.K);
      sinon.stub(controller, 'changeCategoryOnHa', Em.K);
      sinon.stub(controller, 'setStoredConfigsValue', Em.K);
      sinon.stub(controller, 'addHostPrincipals', Em.K);
      sinon.stub(App.Service, 'find', function () {
        return [
          {serviceName: 'HDFS'}
        ];
      });

      controller.loadStep();
      expect(controller.get('installedServices')).to.eql(['HDFS']);
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.loadUsers.calledOnce).to.be.true;
      expect(controller.addUserPrincipals.calledWith(['service1'], ['user1'])).to.be.true;
      expect(controller.addHostPrincipals.calledOnce).to.be.true;
      expect(controller.renderServiceConfigs.calledWith(['service1'])).to.be.true;
      expect(controller.changeCategoryOnHa.calledWith(['service1'], [{}])).to.be.true;
      expect(controller.setStoredConfigsValue.calledWith(['config1'])).to.be.true;

      controller.clearStep.restore();
      controller.loadUsers.restore();
      controller.addUserPrincipals.restore();
      controller.renderServiceConfigs.restore();
      controller.changeCategoryOnHa.restore();
      controller.setStoredConfigsValue.restore();
      controller.addHostPrincipals.restore();
      App.Service.find.restore();
    });
  });

  describe('#setStoredConfigsValue()', function () {
    it('storedConfigProperties is null', function () {
      expect(controller.setStoredConfigsValue(null)).to.be.false;
    });
    it('stepConfigs is empty', function () {
      controller.set('stepConfigs', []);
      expect(controller.setStoredConfigsValue([])).to.be.true;
      expect(controller.get('stepConfigs')).to.be.empty;
    });
    it('stepConfig has no configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: []
      })]);
      expect(controller.setStoredConfigsValue([])).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs')).to.be.empty;
    });
    it('stepConfig has no stored configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [Em.Object.create({
          name: 'config1',
          value: 'value1'
        })]
      })]);
      var storedConfigProperties = [
        {
          name: 'config2',
          value: "value2"
        }
      ];
      expect(controller.setStoredConfigsValue(storedConfigProperties)).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs').findProperty('name', 'config1').get('value')).to.equal('value1');
    });
    it('stepConfig has stored configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [Em.Object.create({
          name: 'config2',
          value: 'value1'
        })]
      })]);
      var storedConfigProperties = [
        {
          name: 'config2',
          value: "value2"
        }
      ];
      expect(controller.setStoredConfigsValue(storedConfigProperties)).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs').findProperty('name', 'config2').get('value')).to.equal('value2');
    });
  });

  describe('#renderServiceConfigs()', function () {
    it('serviceConfigs and stepConfigs are empty', function () {
      controller.set('stepConfigs', []);
      controller.renderServiceConfigs([]);
      expect(controller.get('selectedService')).to.be.undefined;
    });
    it('serviceConfigs is empty', function () {
      controller.set('stepConfigs', [
        {showConfig: true}
      ]);
      controller.renderServiceConfigs([]);
      expect(controller.get('selectedService')).to.eql({showConfig: true});
    });
    it('serviceConfigs has service', function () {
      var serviceConfigs = [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ];
      sinon.stub(controller, 'wrapConfigProperties', function () {
        return [];
      });
      controller.set('stepConfigs', []);
      controller.renderServiceConfigs(serviceConfigs);
      expect(controller.get('selectedService').get('serviceName')).to.equal('HDFS');
      expect(controller.get('selectedService').get('showConfig')).to.be.true;
      expect(controller.get('selectedService').get('configs')).to.be.empty;
      expect(controller.wrapConfigProperties.calledWith({
        serviceName: 'HDFS',
        configs: []
      })).to.be.true;
      controller.wrapConfigProperties.restore();
    });
  });

  describe('#wrapConfigProperties()', function () {
    it('_componentConfig is empty', function () {
      expect(controller.wrapConfigProperties({configs: []})).to.be.empty;
    });
    it('serviceConfigs has service', function () {
      var mock = Em.Object.create({
        validate: Em.K,
        isReconfigurable: true,
        isEditable: false
      });
      var _componentConfig = {configs: [
        {name: 'config1'}
      ]};
      sinon.stub(App.ServiceConfigProperty, 'create', function () {
        return mock;
      });
      sinon.spy(mock, 'validate');
      expect(controller.wrapConfigProperties(_componentConfig)[0].get('isEditable')).to.be.true;
      expect(App.ServiceConfigProperty.create.calledWith({name: 'config1'})).to.be.true;
      expect(mock.validate.calledOnce).to.be.true;
      mock.validate.restore();
      App.ServiceConfigProperty.create.restore();
    });
  });

  describe('#setHostsToConfig()', function () {
    it('service is null', function () {
      expect(controller.setHostsToConfig(null)).to.be.false;
    });
    it('service.configs is empty', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ]);
      expect(controller.setHostsToConfig('HDFS')).to.be.false;
    });
    it('No such config name in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1'
            }
          ]
        }
      ]);
      expect(controller.setHostsToConfig('HDFS', 'config2')).to.be.false;
    });
    it('Correct config in service.configs', function () {
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({
          hostComponents: [
            Em.Object.create({
              componentName: 'comp1',
              hostName: 'host1'
            })
          ]
        });
      });
      expect(controller.setHostsToConfig('HDFS', 'config1', ['comp1'])).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.eql(['host1']);
      App.Service.find.restore();
    });
  });

  describe('#setHostToPrincipal()', function () {
    it('service is null', function () {
      expect(controller.setHostToPrincipal(null)).to.be.false;
    });
    it('service.configs is empty', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS')).to.be.false;
    });
    it('No such hostConfigName name in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config2', 'config1')).to.be.false;
    });
    it('No such principalConfigName name in service.configs', function () {
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'config2')).to.be.false;
    });
    it('Correct config in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1',
              defaultValue: 'value1'
            },
            {
              name: 'principal1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'principal1', 'name1')).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.equal('value1');
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('name1value1');
    });
    it('Correct config in service.configs, defaultValue is array', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1',
              defaultValue: ['Value1']
            },
            {
              name: 'principal1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'principal1', 'name1')).to.be.true;
     // expect(controller.get('content.services')[0].configs[0].defaultValue).to.equal('Value1');
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('name1Value1');
    });
  });

  describe('#loadUsers()', function () {

    afterEach(function () {
      App.router.get.restore();
    });

    it('serviceUsers is correct', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: [
          {}
        ]})
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
    });
    it('serviceUsers is null, testMode = true', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: null})
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers').mapProperty('name')).to.eql(["hdfs_user",
        "mapred_user",
        "hbase_user",
        "hive_user",
        "smokeuser"
      ]);
      App.get.restore();
    });
    it('serviceUsers is empty, testMode = true', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: []})
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers').mapProperty('name')).to.eql(["hdfs_user",
        "mapred_user",
        "hbase_user",
        "hive_user",
        "smokeuser"
      ]);
      App.get.restore();
    });
    it('serviceUsers is null, testMode = false', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: null})
      });
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [
          {}
        ];
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
      App.get.restore();
    });
    it('serviceUsers is empty, testMode = false', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: []})
      });
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [
          {}
        ];
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
      App.get.restore();
    });
  });

  describe('#addUserPrincipals()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'setUserPrincipalValue', function () {
        return true;
      });
    });
    afterEach(function () {
      controller.setUserPrincipalValue.restore();
    });

    var generalConfigs = [
      {
        serviceName: 'GENERAL',
        configs: [
          {
            name: 'hbase_principal_name',
            isVisible: false
          },
          {
            name: 'hbase_user_keytab',
            isVisible: false
          },
          {
            name: 'hdfs_principal_name',
            isVisible: false
          },
          {
            name: 'hdfs_user_keytab',
            isVisible: false
          }
        ]
      }
    ];
    var securityUsers = [];

    it('HBASE or HDFS services are not installed neither', function () {
      var serviceConfigs = generalConfigs.slice(0);
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.false;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.false;
    });
    it('HBASE service is installed', function () {
      var serviceConfigs = generalConfigs.slice(0);
      serviceConfigs.push({serviceName: 'HBASE'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.true;
    });
    it('HDFS service is installed', function () {
      var serviceConfigs = generalConfigs.slice(0);
      serviceConfigs.push({serviceName: 'HDFS'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_user_keytab').isVisible).to.be.true;
    });
    it('HDFS and HBASE services are installed', function () {
      var serviceConfigs = generalConfigs.slice(0);
      serviceConfigs.push({serviceName: 'HDFS'});
      serviceConfigs.push({serviceName: 'HBASE'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_user_keytab').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.true;
    });
  });

  describe('#setUserPrincipalValue()', function () {
    it('user and userPrincipal are null', function () {
      expect(controller.setUserPrincipalValue(null, null)).to.be.false;
    });
    it('user is null', function () {
      expect(controller.setUserPrincipalValue(null, {})).to.be.false;
    });
    it('userPrincipal is null', function () {
      expect(controller.setUserPrincipalValue({}, null)).to.be.false;
    });
    it('user and userPrincipal are correct', function () {
      var user = {value: 'value1'};
      var userPrincipal = {};
      expect(controller.setUserPrincipalValue(user, userPrincipal)).to.be.true;
      expect(userPrincipal.defaultValue).to.equal('value1');
    });
  });

  describe('#addHostPrincipals()', function () {
    it('hostToPrincipalMap is empty', function () {
      sinon.stub(controller, 'setHostToPrincipal', Em.K);
      controller.set('hostToPrincipalMap', []);
      controller.addHostPrincipals();
      expect(controller.setHostToPrincipal.called).to.be.false;
      controller.setHostToPrincipal.restore();
    });
    it('Correct data', function () {
      sinon.stub(controller, 'setHostToPrincipal', Em.K);
      controller.set('hostToPrincipalMap', [
        {
          serviceName: 'HDFS',
          configName: 'datanode_hosts',
          principalName: 'principal1',
          primaryName: 'name1'
        }
      ]);
      controller.addHostPrincipals();
      expect(controller.setHostToPrincipal.calledWith('HDFS', 'datanode_hosts', 'principal1', 'name1')).to.be.true;
      controller.setHostToPrincipal.restore();
    });
  });

  describe('#changeCategoryOnHa()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'removeConfigCategory', Em.K);
    });
    afterEach(function () {
      controller.removeConfigCategory.restore();
    });

    var serviceConfigs = [{
      serviceName: 'HDFS',
      configCategories: []
    }];
    var stepConfigs = [Em.Object.create({
      serviceName: 'HDFS',
      configs: []
    })];

    it('HDFS service is absent', function () {
      expect(controller.changeCategoryOnHa([], [])).to.be.false;
    });
    it('HDFS service installed, App.testMode and App.testNameNodeHA - true', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        if ('testNameNodeHA' === k) return true;
        return Em.get(App, k);
      });
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'SNameNode')).to.be.true;
      App.get.restore();
    });
    it('HDFS service installed, content.isNnHa = true', function () {
      controller.set('content.isNnHa', 'true');
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'SNameNode')).to.be.true;
    });
    it('HDFS service installed, HA disabled', function () {
      controller.set('content.isNnHa', 'false');
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'JournalNode')).to.be.true;
    });
  });

  describe('#removeConfigCategory()', function () {
    it('properties should be hidden', function () {
      var properties = [
        Em.Object.create({
          category: 'comp1',
          isVisible: true
        })
      ];
      controller.removeConfigCategory(properties, [], 'comp1');
      expect(properties[0].isVisible).to.be.false;
    });
    it('category should be removed', function () {
      var configCategories = [
        Em.Object.create({
          name: 'comp1'
        })
      ];
      controller.removeConfigCategory([], configCategories, 'comp1');
      expect(configCategories).to.be.empty;
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step3');
var stringUtils = require('utils/string_utils');
var modelSetup = require('test/init_model_test');

describe('App.MainAdminSecurityAddStep3Controller', function () {

  var controller = App.MainAdminSecurityAddStep3Controller.create({
    content: {}
  });

  describe('#openInfoInNewTab()', function() {
    it('Correct data', function() {
      var mock = {
        document: {
          write: function(){}
        },
        focus: function(){}
      };
      sinon.stub(window, 'open', function () {
        return mock;
      });
      sinon.stub(stringUtils, 'arrayToCSV', function () {
        return 'CSV_CONTENT';
      });
      sinon.spy(mock.document, 'write');
      sinon.spy(mock, 'focus');
      controller.set('hostComponents', ['comp1']);

      controller.openInfoInNewTab();
      expect(window.open.calledWith('')).to.be.true;
      expect(stringUtils.arrayToCSV.calledWith(['comp1'])).to.be.true;
      expect(mock.document.write.calledWith('CSV_CONTENT')).to.be.true;
      expect(mock.focus.calledOnce).to.be.true;
      window.open.restore();
      stringUtils.arrayToCSV.restore();
    });
  });

  describe('#loadStep()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [{
          name: 'user_group',
          value: 'value1'
        }];
      });
    });
    afterEach(function(){
      controller.getSecurityUsers.restore();
    });

    it('No hosts installed', function() {
      controller.set('hosts', []);
      controller.loadStep();
      expect(controller.get('hostComponents')).to.be.empty;
    });
    it('One host installed', function () {
      controller.set('hosts', [Em.Object.create({hostName: 'host1'})]);
      sinon.stub(controller, 'setMandatoryConfigs', function (result) {
        return result.push('setMandatoryConfigs');
      });
      sinon.stub(controller, 'setComponentsConfig', function (result) {
        return result.push('setComponentsConfig');
      });
      sinon.stub(controller, 'setHostComponentsSecureValue', function (result) {
        return result.push('setHostComponentsSecureValue');
      });

      controller.loadStep();
      expect(controller.setMandatoryConfigs.calledOnce).to.be.true;
      expect(controller.setComponentsConfig.calledOnce).to.be.true;
      expect(controller.setHostComponentsSecureValue.calledOnce).to.be.true;
      expect(controller.get('hostComponents')).to.eql(["setMandatoryConfigs", "setComponentsConfig", "setHostComponentsSecureValue"]);

      controller.setMandatoryConfigs.restore();
      controller.setComponentsConfig.restore();
      controller.setHostComponentsSecureValue.restore();
    });
  });

  describe('#buildComponentToOwnerMap()', function() {
    beforeEach(function(){
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [{
          name: 'storm_user',
          value: 'storm'
        }];
      });
    });
    afterEach(function(){
      controller.getSecurityUsers.restore();
    });

    it('componentToUserMap is empty', function() {
      sinon.stub(controller, 'get').withArgs('componentToUserMap').returns({});
      expect(controller.buildComponentToOwnerMap([])).to.eql({});
      controller.get.restore();
    });
    it('componentToUserMap has properties', function() {
      var securityUsers = [{
        name: 'config1',
        value: 'value1'
      }];
      sinon.stub(controller, 'get').withArgs('componentToUserMap').returns({'COMP1': 'config1'});
      expect(controller.buildComponentToOwnerMap(securityUsers)).to.eql({'COMP1': 'value1'});
      controller.get.restore();
    });
  });

  describe('#setComponentsConfig()', function() {

    beforeEach(function(){
      modelSetup.setupStackServiceComponent();
      controller.set('content.serviceConfigProperties', [
        {
          serviceName: 'HDFS',
          name: 'principal1',
          value: '_HOST'
        },
        {
          serviceName: 'HDFS',
          name: 'keytab1',
          value: 'value1'
        }
      ]);
    });

    afterEach(function() {
      modelSetup.cleanStackServiceComponent();
    });

    it('componentToConfigMap is empty', function() {
      controller.reopen({
        componentToConfigMap: []
      });
      var result = [];
      controller.setComponentsConfig(result, Em.Object.create({hostName: 'c6401',hostComponents: []}), 'hadoopGroupId');
      expect(result).to.be.empty;
    });
    it('isHadoop2Stack = false, when component from stack2', function() {
      sinon.stub(App, 'get', function () {
        return false;
      });
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1',
          isHadoop2Stack: true
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result).to.be.empty;
      App.get.restore();
    });
    it('isHadoop2Stack = true, when component from stack2', function() {
      sinon.stub(App, 'get', function () {
        return true;
      });
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1',
          isHadoop2Stack: true
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result.length).to.equal(1);
      App.get.restore();
    });
    it('Component does not match host-component', function() {
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1'
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE1'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result).to.be.empty;
    });
    it('Component matches host-component', function() {
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1'
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result.length).to.equal(1);
    });
  });

  describe('#setMandatoryConfigs()', function() {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {serviceName: 'SERVICE1'}
        ];
      });
      controller.set('content.serviceConfigProperties', [
        {
          serviceName: 'GENERAL',
          name: 'kerberos_domain',
          value: 'realm1'
        }
      ]);
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    it('mandatoryConfigs is empty', function() {
      var result = [];
      controller.set('mandatoryConfigs', []);

      controller.setMandatoryConfigs(result, [], '', '');
      expect(result).to.be.empty;
    });
    it('config has unknown service to check', function() {
      var result = [];
      controller.set('mandatoryConfigs', [{
        userConfig: 'kerberos_domain',
        keytab: 'kerberos_domain',
        displayName: '',
        checkService: 'HBASE'
      }]);

      controller.setMandatoryConfigs(result, [], '', '');
      expect(result).to.be.empty;
    });
    it('config should be added', function() {
      var result = [];
      controller.set('mandatoryConfigs', [{
        userConfig: 'userConfig1',
        keytab: 'kerberos_domain',
        displayName: ''
      }]);
      var securityUsers = [{
        name: 'userConfig1',
        value: 'value1'
      }];

      controller.setMandatoryConfigs(result, securityUsers, '', '');
      expect(result.length).to.equal(1);
    });
  });

  describe('#setHostComponentsSecureValue()', function() {

    beforeEach(function () {
      sinon.stub(controller, 'buildComponentToOwnerMap', Em.K);
      sinon.stub(controller, 'changeDisplayName', Em.K);
      sinon.stub(controller, 'getSecureProperties', function(){
        return {principal: '', keytab: ''};
      });
    });
    afterEach(function () {
      controller.buildComponentToOwnerMap.restore();
      controller.changeDisplayName.restore();
      controller.getSecureProperties.restore();
    });

    it('host.hostComponents is empty', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: []
      });

      controller.setHostComponentsSecureValue(result, host);
      expect(result).to.be.empty;
    });
    it('host-component does not match component to display', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'UNKNOWN'
        })]
      });

      controller.setHostComponentsSecureValue(result, host);
      expect(result).to.be.empty;
    });
    it('host-component matches component to display', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'DATANODE'
        })]
      });

      controller.setHostComponentsSecureValue(result, host, {}, [], '');
      expect(result.length).to.equal(1);
    });
    it('addedPrincipalsHost already contain such config', function() {
      var result = [];
      var host = Em.Object.create({
        hostName: 'host1',
        hostComponents: [Em.Object.create({
          componentName: 'DATANODE'
        })]
      });

      controller.setHostComponentsSecureValue(result, host, {'host1--': true}, [], '');
      expect(result.length).to.be.empty;
    });
  });

  describe('#setHostComponentsSecureValue()', function () {

    it('DRPC Server principal should point to Nimbus host for HDP-2.2 stack', function () {
      sinon.stub(App, 'get').withArgs('isHadoop22Stack').returns(true);
      sinon.stub(controller, 'get').withArgs('content.serviceConfigProperties').returns([]);
      sinon.stub(controller, 'getNimbusHostName').returns('nimbus_host');
      sinon.stub(controller, 'buildComponentToOwnerMap').returns({'DRPC_SERVER': 'storm'});
      sinon.stub(controller, 'getSecureProperties').returns({
        "keytab": "/etc/security/keytabs/nimbus.service.keytab",
        "principal": "nimbus/nimbus_host"
      });
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [
          {
            name: 'storm_user',
            value: 'storm'
          }
        ];
      });
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'DRPC_SERVER',
          displayName: 'DRPC Server'
        })]
      });

      var result = [];
      controller.setHostComponentsSecureValue(result, host, {}, [], 'hadoopId');
      expect(result).to.be.not.empty;
      expect(controller.getSecureProperties.args[0][2]).to.equal('nimbus_host');

      var hostComponent = result[0];
      expect(hostComponent.principal).to.equal('nimbus/nimbus_host');
      expect(hostComponent.owner).to.equal('storm');

      App.get.restore();
      controller.get.restore();
      controller.getNimbusHostName.restore();
      controller.buildComponentToOwnerMap.restore();
      controller.getSecureProperties.restore();
      controller.getSecurityUsers.restore();
    });
  });

  describe('#getSecureProperties()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'getPrincipal', function () {
        return 'principal';
      });
    });
    afterEach(function () {
      controller.getPrincipal.restore();
    });

    var testCases = [
      {
        title: 'serviceConfigs is empty',
        content: {
          serviceConfigs: [],
          componentName: ''
        },
        result: {}
      },
      {
        title: 'Config has component that does not match component name',
        content: {
          serviceConfigs: [{
            component: 'comp1'
          }],
          componentName: 'comp2'
        },
        result: {}
      },
      {
        title: 'Config has components that does not match component name',
        content: {
          serviceConfigs: [{
            components: ['comp1']
          }],
          componentName: 'comp2'
        },
        result: {}
      },
      {
        title: 'Config has component that matches component name',
        content: {
          serviceConfigs: [{
            name: 'C_principal_name',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          principal: 'principal'
        }
      },
      {
        title: 'Config has components that matches component name',
        content: {
          serviceConfigs: [{
            name: 'C_principal_name',
            components: ['comp1'],
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          principal: 'principal'
        }
      },
      {
        title: 'Config name without correct postfix',
        content: {
          serviceConfigs: [{
            name: 'config1',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {}
      },
      {
        title: 'Config name with "_keytab" postfix',
        content: {
          serviceConfigs: [{
            name: 'c_keytab',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          keytab: 'value1'
        }
      },
      {
        title: 'Config name with "_keytab_path" postfix',
        content: {
          serviceConfigs: [{
            name: 'c_keytab_path',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          keytab: 'value1'
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getSecureProperties(test.content.serviceConfigs, test.content.componentName, '')).to.eql(test.result);
      });
    });
  });

  describe('#getPrincipal()', function () {

    var testCases = [
      {
        title: 'Config value missing "_HOST" string, unit is empty',
        content: {
          config: {
            value: 'value1',
            unit: ''
          },
          hostName: ''
        },
        result: 'value1'
      },
      {
        title: 'Config value missing "_HOST" string, unit is correct',
        content: {
          config: {
            value: 'value1',
            unit: 'unit1'
          },
          hostName: ''
        },
        result: 'value1unit1'
      },
      {
        title: 'Config value contains "_HOST" string, host name in lowercase',
        content: {
          config: {
            value: '_HOST',
            unit: 'unit1'
          },
          hostName: 'host1'
        },
        result: 'host1unit1'
      },
      {
        title: 'Config value contains "_HOST" string, host name in uppercase',
        content: {
          config: {
            value: '_HOST',
            unit: 'unit1'
          },
          hostName: 'HOST1'
        },
        result: 'host1unit1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getPrincipal(test.content.config, test.content.hostName)).to.equal(test.result);
      });
    });
  });

  describe('#changeDisplayName()', function() {
    it('name is HiveServer2', function() {
      expect(controller.changeDisplayName('HiveServer2')).to.equal('Hive Metastore and HiveServer2');
    });
    it('name is not HiveServer2', function() {
      expect(controller.changeDisplayName('something')).to.equal('something');
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/security_progress_controller');
require('controllers/main/admin/security/add/step4');
require('mixins/wizard/addSecurityConfigs');
require('utils/polling');
require('models/cluster_states');
require('models/service');

var controller;

describe('App.MainAdminSecurityAddStep4Controller', function () {

  beforeEach(function () {
    controller = App.MainAdminSecurityAddStep4Controller.create({
      content: {},
      commands: [],
      enableSubmit: function () {
        this._super()
      },
      secureMapping: [],
      secureProperties: [],
      secureServices: []
    });
  });

  describe('#isBackBtnDisabled', function () {
    it('commands have error', function () {
      controller.set('commands', [Em.Object.create({
        isError: true
      })]);
      expect(controller.get('isBackBtnDisabled')).to.be.false;
    });
    it('commands do not have error', function () {
      controller.set('commands', [Em.Object.create({
        isError: false
      })]);
      expect(controller.get('isBackBtnDisabled')).to.be.true;
    });
  });

  describe('#isSecurityApplied', function () {
    var testCases = [
      {
        title: 'No START_SERVICES command',
        commands: [],
        result: false
      },
      {
        title: 'START_SERVICES is not success',
        commands: [Em.Object.create({
          name: 'START_SERVICES',
          isSuccess: false
        })],
        result: false
      },
      {
        title: 'START_SERVICES is success',
        commands: [Em.Object.create({
          name: 'START_SERVICES',
          isSuccess: true
        })],
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', test.commands);
        expect(controller.get('isSecurityApplied')).to.equal(test.result);
      });
    });
  });

  describe('#enableSubmit()', function () {
    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'setStepsEnable');
      sinon.spy(mock, 'setLowerStepsDisable');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.setStepsEnable.restore();
      mock.setLowerStepsDisable.restore();
    });

    it('Command has error', function () {
      controller.set('commands', [Em.Object.create({
        isError: true
      })]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.false;
      expect(mock.setStepsEnable.calledOnce).to.be.true;
    });
    it('Command is successful', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: true
      })]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it('Command is in progress', function () {
      controller.set('commands', [Em.Object.create()]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.true;
      expect(mock.setLowerStepsDisable.calledWith(4)).to.be.true;
    });
  });

  describe('#clearStep()', function () {
    it('Clear step info', function () {
      controller.set('commands', [Em.Object.create()]);
      controller.set('isSubmitDisabled', false);
      controller.set('serviceConfigTags', [
        {}
      ]);
      controller.clearStep();
      expect(controller.get('isSubmitDisabled')).to.be.true;
      expect(controller.get('commands')).to.be.empty;
      expect(controller.get('serviceConfigTags')).to.be.empty;
    });
  });

  describe('#loadCommands()', function () {

    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
    });

    after(function () {
      App.clusterStatus.setClusterStatus.restore();
    });

    var tests = Em.A([
      {
        doesATSSupportKerberos: true,
        isATSInstalled: true,
        e: {
          l: 3,
          d: false
        }
      },
      {
        doesATSSupportKerberos: true,
        isATSInstalled: false,
        e: {
          l: 3,
          d: false
        }
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: true,
        e: {
          l: 4,
          d: true
        }
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: false,
        e: {
          l: 3,
          d: false
        }
      }
    ]);

    tests.forEach(function (test) {
      it('doesATSSupportKerberos ' + test.doesATSSupportKerberos.toString() + ', isATSInstalled ' + test.isATSInstalled.toString(), function () {
        sinon.stub(App, 'get', function (k) {
          if ('doesATSSupportKerberos' === k) return test.doesATSSupportKerberos;
          return Em.get(App, k);
        });
        controller.set('content.isATSInstalled', test.isATSInstalled);
        controller.loadCommands();
        App.get.restore();
        expect(controller.get('commands.length')).to.equal(test.e.l);
        expect(controller.get('commands').someProperty('name', 'DELETE_ATS')).to.equal(test.e.d);
      });
    });

  });

  describe('#loadStep()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'prepareSecureConfigs', Em.K);
    });
    afterEach(function () {
      controller.clearStep.restore();
      controller.prepareSecureConfigs.restore();
      controller.resumeSavedCommands.restore();
    });

    it('Resume saved commands', function () {
      sinon.stub(controller, 'resumeSavedCommands', function () {
        return true;
      });

      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.prepareSecureConfigs.calledOnce).to.be.true;
      expect(controller.resumeSavedCommands.calledOnce).to.be.true;
    });
    it('No saved commands', function () {
      sinon.stub(controller, 'resumeSavedCommands', function () {
        return false;
      });
      sinon.stub(controller, 'loadCommands', Em.K);
      sinon.stub(controller, 'addInfoToCommands', Em.K);
      sinon.stub(controller, 'syncStopServicesOperation', Em.K);
      sinon.stub(controller, 'addObserverToCommands', Em.K);
      sinon.stub(controller, 'moveToNextCommand', Em.K);

      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.prepareSecureConfigs.calledOnce).to.be.true;
      expect(controller.resumeSavedCommands.calledOnce).to.be.true;

      controller.loadCommands.restore();
      controller.addInfoToCommands.restore();
      controller.syncStopServicesOperation.restore();
      controller.addObserverToCommands.restore();
      controller.moveToNextCommand.restore();
    });
  });

  describe('#syncStopServicesOperation()', function () {

    afterEach(function () {
      App.router.get.restore();
    });

    it('No running operations', function () {
      sinon.stub(App.router, 'get', function () {
        return [];
      });

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('Running operation is not Stop All Services', function () {
      sinon.stub(App.router, 'get', function () {
        return [Em.Object.create({isRunning: true})];
      });

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('No STOP_SERVICES in commands', function () {
      sinon.stub(App.router, 'get', function () {
        return [Em.Object.create({
          isRunning: true,
          name: 'Stop All Services'
        })];
      });
      controller.set('commands', []);

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('Sync stop services commands', function () {
      sinon.stub(App.router, 'get', function () {
        return [Em.Object.create({
          isRunning: true,
          name: 'Stop All Services',
          id: 1
        })];
      });
      controller.set('commands', [Em.Object.create({
        name: 'STOP_SERVICES'
      })]);

      expect(controller.syncStopServicesOperation()).to.be.true;
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
  });

  describe('#resumeSavedCommands()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'addObserverToCommands', Em.K);
      sinon.stub(controller, 'moveToNextCommand', Em.K);
      controller.set('commands', []);
    });
    afterEach(function () {
      controller.moveToNextCommand.restore();
      controller.addObserverToCommands.restore();
      App.db.getSecurityDeployCommands.restore();
    });


    it('Commands is null', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return null;
      });
      expect(controller.resumeSavedCommands()).to.be.false;
    });
    it('Commands is empty', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [];
      });
      expect(controller.resumeSavedCommands()).to.be.false;
    });
    it('Command has error', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [
          {
            isError: true,
            name: 'command1'
          }
        ];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
    });
    it('Command in progress', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [
          {
            isStarted: true,
            isCompleted: false,
            name: 'command1'
          }
        ];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.false;
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
      expect(controller.moveToNextCommand.calledOnce).to.be.true;
    });
    it('Command completed', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [
          {
            isCompleted: true,
            name: 'command1'
          }
        ];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
      expect(controller.moveToNextCommand.calledOnce).to.be.true;
    });
  });

  describe('#manageSecureConfigs()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'setPrincipalValue', Em.K);
    });
    afterEach(function () {
      controller.setPrincipalValue.restore();
    });

    it('serviceConfigTags is null', function () {
      sinon.stub(controller, 'onJsError', Em.K);
      controller.set('serviceConfigTags', null);
      controller.set('configs', [
        {id: 'site property'}
      ]);
      controller.set('commands', [Em.Object.create({
        name: 'APPLY_CONFIGURATIONS'
      })]);

      expect(controller.manageSecureConfigs()).to.be.false;
      expect(controller.onJsError.calledOnce).to.be.true;
      expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isSuccess')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isError')).to.be.true;

      controller.onJsError.restore();
    });
    it('Add configs from site-*.xml', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'site1',
          configs: {}
        }
      ]);
      controller.set('configs', [
        {
          id: 'site property',
          name: 'config1',
          value: "value1",
          filename: 'site1.xml'
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({'config1': 'value1'});
    });
    it('Add configs from global.xml, config matches "_hosts"', function () {
      controller.reopen({
        secureConfigs: [
          {
            serviceName: 'service1',
            name: 'config1'
          }
        ]
      });

      controller.set('serviceConfigTags', [
        {
          siteName: 'global',
          configs: {}
        }
      ]);
      controller.set('globalProperties', [
        {
          id: 'site property',
          name: 'config1_hosts',
          value: "value1",
          filename: 'site1.xml'
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({});
      expect(controller.setPrincipalValue.calledWith('service1', 'config1')).to.be.true;
    });
  });

  describe('#deleteComponents()', function () {
    it('Send ajax', function () {
      sinon.stub(App.ajax, 'send', Em.K);

      controller.deleteComponents('comp1', 'host1');
      expect(App.ajax.send.calledOnce).to.be.true;

      App.ajax.send.restore();
    });
  });

  describe('#onDeleteComplete()', function () {
    it('', function () {
      controller.set('commands', [Em.Object.create({
        name: 'DELETE_ATS'
      })]);

      controller.onDeleteComplete();
      expect(controller.get('commands').findProperty('name', 'DELETE_ATS').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'DELETE_ATS').get('isSuccess')).to.be.true;
    });
  });

  describe('#onJsError()', function () {
    it('Show popup', function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);

      controller.onJsError();
      expect(App.ModalPopup.show.calledOnce).to.be.true;

      App.ModalPopup.show.restore();
    });
  });

});

});

;require.register("test/controllers/main/admin/security/disable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/disable');


describe('App.MainAdminSecurityDisableController', function () {

  var controller = App.MainAdminSecurityDisableController.create({
    serviceConfigTags: null,
    secureProperties: null,
    secureMapping: null
  });


  describe('#resumeCommands()', function () {
    var context = {
      getSecurityDeployCommands: function () {
        return this.testData;
      }
    };

    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.db, "getSecurityDeployCommands", context.getSecurityDeployCommands);
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
    });
    afterEach(function () {
      App.db.getSecurityDeployCommands.restore();
      App.router.get.restore();
    });

    it('commands are absent in local storage', function () {
      App.db.testData = null;
      expect(controller.resumeCommands()).to.be.false;
    });
    it('zero commands in local storage', function () {
      App.db.testData = [];
      expect(controller.resumeCommands()).to.be.false;
    });
    it('one command is present', function () {
      App.db.testData = [
        {
          name: 'command1'
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
    });
    it('command is started and completed', function () {
      App.db.testData = [
        {
          name: 'command1',
          isStarted: true,
          isCompleted: true
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.true;
    });
    it('command is started but not completed', function () {
      App.db.testData = [
        {
          name: 'command1',
          isStarted: true,
          isCompleted: false
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.false;
    });
  });

  describe('#isSubmitDisabled', function () {
    var testCases = [
      {
        title: 'commands is empty',
        commands: [],
        result: false
      },
      {
        title: 'one started command',
        commands: [Em.Object.create({
          isStarted: true
        })],
        result: true
      },
      {
        title: 'one failed command',
        commands: [Em.Object.create({
          isError: true
        })],
        result: false
      },
      {
        title: 'one success command',
        commands: [Em.Object.create({
          isSuccess: true
        })],
        result: false
      },
      {
        title: 'not all commands are success',
        commands: [
          Em.Object.create({
            isSuccess: true
          }),
          Em.Object.create({
            isSuccess: false
          })
        ],
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', test.commands);
        expect(controller.get('isSubmitDisabled')).to.equal(test.result);
      });
    });
  });

  describe('#syncStopServicesCommand()', function () {

    it('No background operations', function () {
      controller.set('commands', [Em.Object.create({
        name: 'STOP_SERVICES',
        requestId: 1
      })]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('background operation is not running', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          isRunning: false
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('background operation is running but not "Stop All Services"', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          isRunning: true
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('"Stop All Services" operation is running', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          name: 'Stop All Services',
          isRunning: true,
          id: 2
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(2);
    });
  });

  describe('#manageSecureConfigs()', function () {

    beforeEach(function () {
      sinon.stub(controller, "modifySiteConfigs", Em.K);
    });
    afterEach(function () {
      controller.modifySiteConfigs.restore();
    });

    var testCases = [
      {
        title: 'serviceConfigTags, secureProperties, secureMapping are null',
        content: {
          serviceConfigTags: null,
          secureProperties: null,
          secureMapping: null
        }
      },
      {
        title: 'serviceConfigTags is null',
        content: {
          serviceConfigTags: null,
          secureProperties: [],
          secureMapping: []
        }
      },
      {
        title: 'secureProperties is null',
        content: {
          serviceConfigTags: [],
          secureProperties: null,
          secureMapping: []
        }
      },
      {
        title: 'secureMapping is null',
        content: {
          serviceConfigTags: [],
          secureProperties: [],
          secureMapping: null
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', [Em.Object.create({
          name: 'APPLY_CONFIGURATIONS'
        })]);
        controller.set('serviceConfigTags', test.content.serviceConfigTags);
        controller.set('secureProperties', test.content.secureProperties);
        controller.set('secureMapping', test.content.secureMapping);

        expect(controller.manageSecureConfigs()).to.be.false;
        expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isSuccess')).to.be.false;
        expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isError')).to.be.true;
      });
    });
    it('serviceConfigTags is empty', function () {
      controller.set('serviceConfigTags', []);
      controller.set('secureProperties', []);
      controller.set('secureMapping', []);

      expect(controller.manageSecureConfigs()).to.be.true;
    });
    it('serviceConfigTags has cluster-env site', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'cluster-env',
          configs: {}
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags').findProperty('siteName', 'cluster-env').configs.security_enabled).to.equal('false');
    });
    it('serviceConfigTags has site.xml', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'site'
        }
      ]);
      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.modifySiteConfigs.calledOnce).to.be.true;
    });
  });

  describe('#modifySiteConfigs()', function () {
    var testCases = [
      {
        title: '_serviceConfigTags and secureMapping are null',
        content: {
          secureMapping: null,
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: '_serviceConfigTags is null',
        content: {
          secureMapping: [],
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: 'secureMapping is null',
        content: {
          secureMapping: null,
          _serviceConfigTags: {}
        },
        result: false
      },
      {
        title: 'secureMapping and _serviceConfigTags are empty',
        content: {
          secureMapping: [],
          _serviceConfigTags: {
            configs: {}
          }
        },
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.modifySiteConfigs(test.content.secureMapping, test.content._serviceConfigTags)).to.equal(test.result);
      });
    });
    it('secureMapping doesn\'t contain passed siteName', function () {
      var secureMapping = [];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('secureMapping contain passed siteName but doesn\'t match config name', function () {
      var secureMapping = [
        {
          filename: 'site1.xml'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('secureMapping contain passed siteName and match config name', function () {
      var secureMapping = [
        {
          filename: 'site1.xml',
          name: 'config2'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.undefined;
    });
    it('secureMapping contain passed siteName and included in secureConfigValuesMap', function () {
      var secureMapping = [
        {
          filename: 'site1.xml',
          name: 'config2',
          nonSecureValue: 'nonSecureValue'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      controller.set('secureConfigValuesMap', {
        'config2': 'value'
      });
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.equal('nonSecureValue');
    });
  });
});

});

;require.register("test/controllers/main/admin/security/security_progress_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/security_progress_controller');
require('models/host_component');
require('models/host');

describe('App.MainAdminSecurityProgressController', function () {

  var controller = App.MainAdminSecurityProgressController.create({
    loadClusterConfigs: function () {},
    deleteComponents: function () {}
  });

  describe('#retry()', function () {

    beforeEach(function () {
      sinon.spy(controller, "startCommand");
    });
    afterEach(function () {
      controller.startCommand.restore();
    });

    it('commands are empty', function () {
      controller.set('commands', []);
      controller.retry();
      expect(controller.startCommand.called).to.be.false;
    });

    it('command is successful', function () {
      controller.set('commands', [
        Em.Object.create({
          name: 'test',
          isSuccess: true,
          isError: false,
          isStarted: true
        })
      ]);
      controller.retry();
      expect(controller.startCommand.calledOnce).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isStarted')).to.be.true;
    });

    it('command is failed', function () {
      controller.set('commands', [
        Em.Object.create({
          name: 'test',
          isSuccess: true,
          isError: true,
          isStarted: true
        })
      ]);
      controller.retry();
      expect(controller.startCommand.calledOnce).to.be.true;
      expect(controller.get('commands').findProperty('name', 'test').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isStarted')).to.be.false;
    });
  });

  describe('#updateServices()', function () {

    it('commands are empty', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', []);
      controller.updateServices();
      expect(controller.get('services')).to.be.empty;
    });

    it('command doesn\'t have polledData', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        label: 'label'
      })]);
      controller.updateServices();
      expect(controller.get('services')).to.be.empty;
    });

    it('command has polledData', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        label: 'service1',
        polledData: [
          {
            Tasks: {
              host_name: 'host1'
            }
          }
        ]
      })]);
      controller.updateServices();
      expect(controller.get('services').findProperty('name', 'service1').get('hosts')).to.eql([
        {
          name: 'host1',
          publicName: 'host1',
          logTasks: [
            {
              Tasks: {host_name: 'host1'}
            }
          ]
        }
      ]);
    });
  });

  describe('#setIndex()', function () {
    it('commandArray is empty', function () {
      var commandArray = [];
      controller.setIndex(commandArray);
      expect(commandArray).to.be.empty;
      expect(controller.get('totalSteps')).to.equal(0);
    });
    it('one command in commandArray', function () {
      var commandArray = [
        Em.Object.create({name: 'command1'})
      ];
      controller.setIndex(commandArray);
      expect(commandArray[0].get('index')).to.equal(1);
      expect(controller.get('totalSteps')).to.equal(1);
    });
    it('commands with random indexes', function () {
      var commandArray = [];
      commandArray[3] = Em.Object.create({name: 'command3'});
      commandArray[11] = Em.Object.create({name: 'command11'});
      controller.setIndex(commandArray);
      expect(commandArray[3].get('index')).to.equal(4);
      expect(commandArray[11].get('index')).to.equal(12);
      expect(controller.get('totalSteps')).to.equal(12);
    });
  });

  describe('#startCommand()', function () {

    var command = Em.Object.create({
      start: Em.K
    });

    beforeEach(function () {
      sinon.spy(command, "start");
      sinon.spy(controller, "loadClusterConfigs");
      sinon.spy(controller, "deleteComponents");
      sinon.stub(controller, "saveCommands", Em.K);
    });

    afterEach(function () {
      command.start.restore();
      controller.loadClusterConfigs.restore();
      controller.deleteComponents.restore();
      controller.saveCommands.restore();
    });

    it('number of commands doesn\'t match totalSteps', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.false;
    });

    it('commands is empty', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 0);
      expect(controller.startCommand()).to.be.false;
    });

    it('command is started and completed', function () {
      controller.set('commands', [Em.Object.create({
        isStarted: true,
        isCompleted: true
      })]);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.false;
    });

    it('command is started and incompleted', function () {
      controller.set('commands', [Em.Object.create({
        isStarted: true,
        isCompleted: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.true;
    });

    it('command parameter passed, isPolling is true', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 0);
      command.set('isPolling', true);
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(command.start.calledOnce).to.be.true;
      command.set('isPolling', false);
    });

    it('command parameter passed, name is "APPLY_CONFIGURATIONS"', function () {
      command.set('name', 'APPLY_CONFIGURATIONS');
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(controller.loadClusterConfigs.calledOnce).to.be.true;
    });

    it('command parameter passed, name is "DELETE_ATS"', function () {
      command.set('name', 'DELETE_ATS');

      sinon.stub(App.HostComponent, 'find', function() {
        return [Em.Object.create({
          id: 'APP_TIMELINE_SERVER_ats_host',
          componentName: 'APP_TIMELINE_SERVER',
          hostName: 'ats_host'
        })];
      });
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(controller.deleteComponents.calledWith('APP_TIMELINE_SERVER', 'ats_host')).to.be.true;

      App.HostComponent.find.restore();
    });

  });

  describe('#onCompleteCommand()', function () {

    beforeEach(function () {
      sinon.spy(controller, "moveToNextCommand");
      sinon.stub(controller, "saveCommands", Em.K);
    });
    afterEach(function () {
      controller.moveToNextCommand.restore();
      controller.saveCommands.restore();

    });

    it('number of commands doesn\'t match totalSteps', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('No successful commands', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('No successful commands', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('Last command is successful', function () {
      controller.set('commands', [
        Em.Object.create({
          isSuccess: false
        }),
        Em.Object.create({
          isSuccess: true
        })
      ]);
      controller.set('totalSteps', 2);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('all commands are successful', function () {
      controller.set('commands', [
        Em.Object.create({
          isSuccess: true,
          name: 'command1'
        }),
        Em.Object.create({
          isSuccess: false,
          name: 'command2'
        })
      ]);
      controller.set('totalSteps', 2);
      expect(controller.onCompleteCommand()).to.be.true;
      expect(controller.moveToNextCommand.calledWith(Em.Object.create({
        isSuccess: false,
        name: 'command2'
      }))).to.be.true;
    });
  });

  describe('#moveToNextCommand()', function () {

    beforeEach(function () {
      sinon.spy(controller, "startCommand");
    });
    afterEach(function () {
      controller.startCommand.restore();
    });

    it('No commands present', function () {
      controller.set('commands', []);
      expect(controller.moveToNextCommand()).to.be.false;
    });
    it('Only started command present', function () {
      controller.set('commands', [
        Em.Object.create({
          isStarted: true
        })
      ]);
      expect(controller.moveToNextCommand()).to.be.false;
    });
    it('Command is not started', function () {
      controller.set('commands', [
        Em.Object.create({
          isStarted: false,
          name: 'command1'
        })
      ]);
      expect(controller.moveToNextCommand()).to.be.true;
      expect(controller.startCommand.calledWith(Em.Object.create({
        isStarted: false,
        name: 'command1'
      }))).to.be.true;
    });
    it('Next command provide as argument', function () {
      var nextCommand = Em.Object.create({
        isStarted: false,
        name: 'command2'
      });
      expect(controller.moveToNextCommand(nextCommand)).to.be.true;
      expect(controller.startCommand.calledWith(Em.Object.create({
        isStarted: false,
        name: 'command2'
      }))).to.be.true;
    });
  });

  describe('#setServiceTagNames()', function () {
    var testCases = [
      {
        title: 'configs is empty object',
        content: {
          secureService: {},
          configs: {}
        },
        result: undefined
      },
      {
        title: 'secureService.sites is null',
        content: {
          secureService: {
            sites: null
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites doesn\'t contain required config tag',
        content: {
          secureService: {
            sites: []
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites contains required config tag',
        content: {
          secureService: {
            sites: ['site1']
          },
          configs: {
            site1: {
              tag: 'tag1'
            }
          }
        },
        result: {
          siteName: 'site1',
          tagName: 'tag1',
          newTagName: null,
          configs: {}
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setServiceTagNames(test.content.secureService, test.content.configs)).to.eql(test.result);
      });
    });
  });

  describe('#modifyConfigsForSecure', function () {
    var cfg = {
      properties: {
        'ui.childopts': 'value1',
        'supervisor.childopts': 'value2',
        'common_property': 'value4'
      }
    };
    var siteName = 'storm-site';
    var result = {
      'ui.childopts': 'value1 -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf',
      'supervisor.childopts': 'value2 -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf',
      'common_property': 'value4'
    };
    var propertiesToUpdate = [
      {
        siteName: 'storm-site',
        name: 'ui.childopts',
        append: ' -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf'
      },
      {
        siteName: 'storm-site',
        name: 'supervisor.childopts',
        append: ' -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf'
      }
    ];
    it("should change some storm sonfigs", function () {
      controller.set('propertiesToUpdate', propertiesToUpdate);
      expect(controller.modifyConfigsForSecure(siteName, cfg)).to.eql(result);
    });
  });
});

});

;require.register("test/controllers/main/admin/security_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security');


describe('App.MainAdminSecurityController', function () {

  var controller = App.MainAdminSecurityController.create({
    getServiceConfigsFromServer: function () {
    } ,
    services: [{serviceName: 'HDFS'}]
  });

  describe('#setServiceTagNames()', function () {
    var testCases = [
      {
        title: 'configs is empty object',
        content: {
          secureService: {},
          configs: {}
        },
        result: undefined
      },
      {
        title: 'secureService.sites is null',
        content: {
          secureService: {
            sites: null
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites doesn\'t contain required config tag',
        content: {
          secureService: {
            sites: []
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites contains required config tag',
        content: {
          secureService: {
            sites: ['site1']
          },
          configs: {
            site1: {
              tag: 'tag1'
            }
          }
        },
        result: {
          siteName: 'site1',
          tagName: 'tag1',
          newTagName: null,
          configs: {}
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setServiceTagNames(test.content.secureService, test.content.configs)).to.eql(test.result);
      });
    });
  });

  describe('#getSecurityStatusFromServerSuccessCallback()', function () {

    beforeEach(function () {
      sinon.spy(controller, 'showSecurityErrorPopup');
      sinon.spy(controller, 'getServiceConfigsFromServer');
    });
    afterEach(function () {
      controller.showSecurityErrorPopup.restore();
      controller.getServiceConfigsFromServer.restore();
    });

    it('desired_configs is empty', function () {
      var data = {Clusters: {
        desired_configs: {}
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('cluster-env is missing', function () {
      var data = {Clusters: {
        desired_configs: {
          'hdfs-site': {}
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('cluster-env and hdfs-site are correct', function () {
      var data = {Clusters: {
        desired_configs: {
          'hdfs-site': {
            tag: 1
          },
          'cluster-env': {
            tag: 2
          },
          'hadoop-env': {
            tag: 3
          }
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.get('tag.cluster-env')).to.equal(2);
      expect(controller.get('tag.hdfs-site')).to.equal(1);
      expect(controller.getServiceConfigsFromServer.called).to.equal(true);
    });
  });


  describe('#setNnHaStatus()', function () {

    beforeEach(function () {
      sinon.stub(App.db, "setIsNameNodeHa", Em.K);
    });
    afterEach(function () {
      App.db.setIsNameNodeHa.restore();
    });


    it('hdfsConfigs is null', function () {
      var hdfsConfigs = null;
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('"dfs.nameservices" is absent in hdfsConfigs', function () {
      var hdfsConfigs = {};
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('namenodesKey is absent in hdfsConfigs', function () {
      var hdfsConfigs = {
        'dfs.nameservices': 'key'
      };
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('namenodesKey is present in hdfsConfigs', function () {
      var hdfsConfigs = {
        'dfs.nameservices': 'key',
        'dfs.ha.namenodes.key': 'true'
      };
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('true').called).to.equal(true);
    });
  });

  describe('#loadUsers()', function () {

    beforeEach(function () {
      sinon.stub(App.db, "setSecureUserInfo", Em.K);
    });
    afterEach(function () {
      App.db.setSecureUserInfo.restore();
    });

    it('if defaultUserNameMap is empty then serviceUsers stays the same', function () {
      var configs = {};
      controller.set('serviceUsers', []);
      controller.set('userNameMap', {});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.be.empty;
    });

    it('if user config value is missing then use default', function () {
      var configs = {};
      controller.set('serviceUsers', []);
      controller.set('userNameMap', {
        test_user: {defaultValue: 'test', siteName: 'test-env', serviceName: 'TEST'
      }});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.eql([
        {
          "id": "puppet var",
          "name": "test_user",
          "value": "test"
        }
      ]);
    });

    it('user config value has value', function () {
      var configs = {
        'test_user': 'config-value'
      };
      controller.set('serviceUsers', []);
      controller.set('defaultUserNameMap', {
        test_user: {defaultValue: 'test', siteName: 'test-env', serviceName: 'TEST'
        }});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.eql([
        {
          "id": "puppet var",
          "name": "test_user",
          "value": "config-value"
        }
      ]);
    });
  });
});
});

;require.register("test/controllers/main/admin/serviceAccounts_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/serviceAccounts_controller');


describe('App.MainAdminServiceAccountsController', function () {

  var controller = App.MainAdminServiceAccountsController.create();

  describe('#setContentProperty()', function () {
    var testCases = [
      {
        title: 'key is null',
        content: {
          key: null,
          configName: 'cc',
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'configName is null',
        content: {
          key: 'key',
          configName: null,
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'misc configs array doesn\'t contain such a config',
        content: {
          key: 'key',
          configName: 'config1',
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'content doesn\'t contain such a key',
        content: {
          key: 'key',
          configName: 'config1',
          miscConfigs: [
            Em.Object.create({
              name: 'test_key'
            })
          ]
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'content property match config',
        content: {
          key: 'testKey',
          configName: 'test_key',
          miscConfigs: [
            Em.Object.create({
              name: 'test_key',
              value: 'testValue'
            })
          ]
        },
        result: {
          output: true,
          configValue: 'testValue'
        }
      }
    ];
    controller.set('content', Em.Object.create({testKey: 'test'}));
    testCases.forEach(function (test) {
      it(test.title, function () {
        var content = controller.get('content');
        expect(controller.setContentProperty(test.content.key, test.content.configName, test.content.miscConfigs)).to.equal(test.result.output);
        expect(content.get('testKey')).to.equal(test.result.configValue);
      });
    });
  });

  describe('#sortByOrder()', function () {
    var testCases = [
      {
        title: 'sortOrder is null',
        content: {
          sortOrder: null,
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder is empty',
        content: {
          sortOrder: [],
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder items don\'t match items of array',
        content: {
          sortOrder: ['one'],
          arrayToSort: [
            {name: 'two'}
          ]
        },
        result: []
      },
      {
        title: 'sort items in reverse order',
        content: {
          sortOrder: ['two', 'one'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['two', 'one']
      },
      {
        title: 'sort items in correct order',
        content: {
          sortOrder: ['one', 'two'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['one', 'two']
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.sortByOrder(test.content.sortOrder, test.content.arrayToSort).mapProperty('displayName')).to.eql(test.result);
      });
    });
  });

  describe('#setProxyUserGroupLabel()', function () {

    it('proxyuser_group config is absent', function () {
      var misc_configs = [];
      controller.setProxyUserGroupLabel(misc_configs);
      expect(misc_configs.findProperty('name', 'proxyuser_group')).to.be.undefined;
    });
  })
});

});

;require.register("test/controllers/main/admin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('models/service');
require('models/host_component');
require('controllers/main/admin');

describe('MainAdminController', function () {

  var controller = App.MainAdminController.create();

  describe('#isAccessAvailable()', function () {

    beforeEach(function () {
      Em.propertyDidChange(controller, 'isAccessAvailable');
    });

    it('Services do not match dependencies', function () {
      App.Service.find().clear();
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('APP_TIMELINE_SERVER is absent', function () {
      App.Service.find().clear();
      App.HostComponent.find().clear();
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('Only one YARN service installed', function () {
      App.store.load(App.Service, {
        id: 'YARN',
        service_name: 'YARN'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services installed', function () {
      App.store.load(App.Service, {
        id: 'TEZ',
        service_name: 'TEZ'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services, APP_TIMELINE_SERVER component installed', function () {
      App.store.load(App.HostComponent, {
        id: 'APP_TIMELINE_SERVER_host1',
        component_name: 'APP_TIMELINE_SERVER'
      });
      expect(controller.get("isAccessAvailable")).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/alerts_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/alerts_controller');
require('models/alert');

describe('MainAlertsController', function () {

  var controller = App.MainAlertsController.create();

  describe('#loadAlerts()', function () {

    before(function () {
      sinon.stub(controller, 'getFromServer', Em.K);
    });
    after(function () {
      controller.getFromServer.restore();
    });

    it('getFromServer should be called', function () {
      controller.set('resourceName', null);
      controller.set('isLoaded', true);
      controller.set('resourceType', null);
      controller.loadAlerts('name1', 'type1');
      expect(controller.get("isLoaded")).to.be.false;
      expect(controller.get("resourceName")).to.equal('name1');
      expect(controller.get("resourceType")).to.equal('type1');
      expect(controller.getFromServer.calledOnce).to.be.true;
    });
  });

  describe('#update()', function () {

    var clock;

    beforeEach(function () {
      clock = sinon.useFakeTimers();
      sinon.stub(controller, 'getFromServer', Em.K);
      sinon.spy(controller, 'update');
    });
    afterEach(function () {
      clock.restore();
      controller.getFromServer.restore();
      controller.update.restore();
    });

    it('isUpdating = true', function () {
      controller.set('isUpdating', true);
      expect(controller.get("updateTimer")).not.to.be.null;
      clock.tick(App.componentsUpdateInterval);
      expect(controller.getFromServer.calledOnce).to.be.true;
      expect(controller.update.calledTwice).to.be.true;
    });
    it('isUpdating = false', function () {
      controller.set('isUpdating', false);
      expect(controller.update.calledOnce).to.be.true;
    });
  });

  describe('#getFromServer()', function () {
    var obj = Em.Object.create({isNagiosInstalled: false});

    beforeEach(function () {
      sinon.stub(controller, 'getAlertsByService', Em.K);
      sinon.stub(controller, 'getAlertsByHost', Em.K);
      sinon.stub(App.router, 'get', function() {return obj.get('isNagiosInstalled')});
    });
    afterEach(function () {
      controller.getAlertsByService.restore();
      controller.getAlertsByHost.restore();
      App.router.get.restore();
    });

    it('Nagios is not installed', function () {
      obj.set('isNagiosInstalled', false);
      controller.set('isLoaded', false);
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.true;
      controller.set('isLoaded', false);
    });
    it('Nagios installed, SERVICE resource type', function () {
      obj.set('isNagiosInstalled', true);
      controller.set('resourceType', 'SERVICE');
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.false;
      expect(controller.getAlertsByService.calledOnce).to.be.true;
    });
    it('Nagios installed, HOST resource type', function () {
      obj.set('isNagiosInstalled', true);
      controller.set('resourceType', 'HOST');
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.false;
      expect(controller.getAlertsByHost.calledOnce).to.be.true;
    });
    it('Nagios installed, unknown resource type', function () {
      obj.set('isNagiosInstalled', true);
      controller.set('resourceType', 'RS1');
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.false;
      expect(controller.getAlertsByService.called).to.be.false;
      expect(controller.getAlertsByHost.called).to.be.false;
    });
  });

  describe('#getAlertsByHost()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('resourceName is null', function () {
      controller.set('resourceName', null);
      expect(controller.getAlertsByHost()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('resourceName is correct', function () {
      controller.set('resourceName', 'host1');
      expect(controller.getAlertsByHost()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getAlertsByService()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('resourceName is null', function () {
      controller.set('resourceName', null);
      expect(controller.getAlertsByService()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('resourceName is correct', function () {
      controller.set('resourceName', 'service1');
      expect(controller.getAlertsByService()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getAlertsSuccessCallback()', function () {

    var testCases = [
      {
        title: 'data is null',
        data: null,
        result: []
      },
      {
        title: 'data.alerts is null',
        data: {alerts: null},
        result: []
      },
      {
        title: 'data.alerts.detail is null',
        data: {alerts: {detail: null}},
        result: []
      },
      {
        title: 'data.alerts.detail is empty',
        data: {alerts: {detail: []}},
        result: []
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('isLoaded', false);
        controller.getAlertsSuccessCallback(test.data);
        expect(controller.get('alerts')).to.eql(test.result);
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

    var data = {alerts: {detail: [
      {
        description: 't1',
        service_name: "s1",
        status_time: 1,
        status: 'OK',
        output: 'o1',
        host_name: 'h1',
        last_status_time: 1
      }
    ]}};
    var testCasesOfStatus = [
      {
        title: 'data.alerts.detail is correct, OK status',
        status: 'OK',
        result: '0'
      },
      {
        title: 'data.alerts.detail is correct, WARNING status',
        status: 'WARNING',
        result: '1'
      },
      {
        title: 'data.alerts.detail is correct, CRITICAL status',
        status: 'CRITICAL',
        result: '2'
      },
      {
        title: 'data.alerts.detail is correct, PASSIVE status',
        status: 'PASSIVE',
        result: '3'
      },
      {
        title: 'data.alerts.detail is correct, unknown status',
        status: '',
        result: '4'
      }
    ];
    testCasesOfStatus.forEach(function (test) {
      it(test.title, function () {
        controller.set('isLoaded', false);
        data.alerts.detail[0].status = test.status;
        controller.getAlertsSuccessCallback(data);
        expect(controller.get('alerts.length')).to.equal(1);
        expect(controller.get('alerts').objectAt(0).get('status')).to.equal(test.result);
        expect(controller.get('isLoaded')).to.be.true;
      });
    });
  });

  describe('#getAlertsErrorCallback()', function () {
    it('isLoaded was false', function () {
      controller.set('isLoaded', false);
      controller.getAlertsErrorCallback();
      expect(controller.get('isLoaded')).to.be.true;
    });
    it('isLoaded was true', function () {
      controller.set('isLoaded', true);
      controller.getAlertsErrorCallback();
      expect(controller.get('isLoaded')).to.be.true;
    });
  });
});
});

;require.register("test/controllers/main/app_contoller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('controllers/main/apps_controller');

describe('MainAppsController', function () {


   describe('#iTotalDisplayRecordsObserver()', function () {
     it('should set number of filtered jobs when switching to all jobs', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("paginationObject.iTotalDisplayRecords", 5);
       expect(mainAppsController.get('filterObject.filteredDisplayRecords')).to.equal(5);
     })
   });


   describe('#filterObject.onRunTypeChange()', function () {
     it('should set sSearch_2 of filterObject when changing value of filterObject.runType', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.runType", "MapReduce");
       expect(mainAppsController.get('filterObject.sSearch_2')).to.equal("mr");
       mainAppsController.set("filterObject.runType", "Hive");
       expect(mainAppsController.get('filterObject.sSearch_2')).to.equal("hive");
       mainAppsController.set("filterObject.runType", "Pig");
       expect(mainAppsController.get('filterObject.sSearch_2')).to.equal("pig");
     })
   });

   describe('#filterObject.onJobsChange()', function () {
     it('should set minJobs,maxJobs of filterObject when changing value of filterObject.jobs', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.jobs", ">3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("3");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("");
       mainAppsController.set("filterObject.jobs", "<3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("3");
       mainAppsController.set("filterObject.jobs", "3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("3");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("3");
       mainAppsController.set("filterObject.jobs", "=3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("3");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("3");
     })
   });

   describe('#filterObject.onDurationChange()', function () {
     it('should set minDuration,maxDuration of filterObject when changing value of filterObject.duration', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.duration", ">3h");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal(10799640);
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal("");
       mainAppsController.set("filterObject.duration", "<6m");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal("");
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal(360060);
       mainAppsController.set("filterObject.duration", "10s");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal(9990);
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal(10010);
       mainAppsController.set("filterObject.duration", "1");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal(990);
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal(1010);
     })
   });

   describe('#filterObject.onRunDateChange()', function () {
     it('should set minStartTime,maxStartTime of filterObject when changing value of filterObject.runDate', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.runDate", "Any");
       expect(mainAppsController.get('filterObject.minStartTime')).to.equal("");
       mainAppsController.set("filterObject.runDate", "Past 1 Day");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-86400000)-1000,((new Date().getTime())-86400000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 2 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-172800000)-1000,((new Date().getTime())-172800000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 7 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-604800000)-1000,((new Date().getTime())-604800000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 14 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-1209600000)-1000,((new Date().getTime())-1209600000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 30 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-2592000000)-1000,((new Date().getTime())-2592000000)+1000);
     })
   });

   describe('#filterObject.createAppLink(), #filterObject.valueObserver()', function () {
     var mainAppsController = App.MainAppsController.create();
     mainAppsController.set('content.length', 20);
     it('should set runUrl of filterObject when changing value for any filter', function () {
       mainAppsController.set("filterObject.sSearch_0", "0");
       mainAppsController.set("filterObject.sSearch_1", "workflowName");
       mainAppsController.set("filterObject.sSearch_2", "pig");
       mainAppsController.set("filterObject.sSearch_3", "admin");
       mainAppsController.set("filterObject.minJobs", "1");
       mainAppsController.set("filterObject.maxJobs", "2");
       mainAppsController.set("filterObject.minDuration", "1000");
       mainAppsController.set("filterObject.maxDuration", "2000");
       mainAppsController.set("filterObject.minStartTime", "999");
       mainAppsController.set("filterObject.maxStartTime", "1000");
       mainAppsController.set("filterObject.sSearch", "searchTerm");
       mainAppsController.set("filterObject.iDisplayLength", "10");
       mainAppsController.set("filterObject.iDisplayStart", "10");
       mainAppsController.set("filterObject.iSortCol_0", "1");
       mainAppsController.set("filterObject.sSortDir_0", "ASC");
       expect(mainAppsController.get('runUrl')).to.equal("/jobhistory/datatable?" +
           "sSearch_0=0" +
           "&sSearch_1=workflowName" +
           "&sSearch_2=pig" +
           "&sSearch_3=admin" +
           "&minJobs=1" +
           "&maxJobs=2" +
           "&minDuration=1000" +
           "&maxDuration=2000" +
           "&minStartTime=999" +
           "&maxStartTime=1000" +
           "&sSearch=searchTerm" +
           "&iDisplayLength=10" +
           "&iDisplayStart=10" +
           "&iSortCol_0=1" +
           "&sSortDir_0=ASC");
       expect(mainAppsController.get('filterObject.viewType')).to.equal('filtered');
     });

     it('should set viewType to "all" when set iDisplayLength, iDisplayStart, iSortCol_0, sSortDir_0', function () {
       mainAppsController.set("filterObject.sSearch_0", "");
       mainAppsController.set("filterObject.sSearch_1", "");
       mainAppsController.set("filterObject.sSearch_2", "");
       mainAppsController.set("filterObject.sSearch_3", "");
       mainAppsController.set("filterObject.minJobs", "");
       mainAppsController.set("filterObject.maxJobs", "");
       mainAppsController.set("filterObject.minDuration", "");
       mainAppsController.set("filterObject.maxDuration", "");
       mainAppsController.set("filterObject.minStartTime", "");
       mainAppsController.set("filterObject.maxStartTime", "");
       mainAppsController.set("filterObject.sSearch", "");
       mainAppsController.set("filterObject.iDisplayLength", "10");
       mainAppsController.set("filterObject.iDisplayStart", "10");
       mainAppsController.set("filterObject.iSortCol_0", "1");
       mainAppsController.set("filterObject.sSortDir_0", "ASC");
       expect(mainAppsController.get('filterObject.viewType')).to.equal('all');
     });
   });




 });


});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_cpuWaitIO_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_cpuWaitIO');

describe('App.MainChartHeatmapCpuWaitIOMetric', function () {

  var tests = [
    {
      json: {
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.4
              }
            }
          }
        ]
      },
      m: 'One host',
      e: {'dev01.hortonworks.com': '40.0'}
    },
    {
      json: {
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.4
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.34566
              }
            }
          }
        ]
      },
      m: 'Two hosts',
      e: {'dev01.hortonworks.com': '40.0', 'dev02.hortonworks.com': '34.6'}
    },
    {
      json: {
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.4
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
              }
            }
          }
        ]
      },
      m: 'Two hosts, One without metric',
      e: {'dev01.hortonworks.com': '40.0'}
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapCpuWaitIOMetric = App.MainChartHeatmapCpuWaitIOMetric.create();

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapCpuWaitIOMetric.metricMapper(test.json);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_bytesread_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_bytesread');

describe('App.MainChartHeatmapDFSBytesReadMetric', function () {

  var tests = [
    {i: 0, e: 0},
    {i: 0.5 * 1024* 1024, e: 0.5},
    {i: 1024* 1024, e: 1},
    {i: 10.5 * 1024 * 1024,e: 10.5}
  ];

  describe('#transformValue()', function() {
    var mainChartHeatmapDFSBytesReadMetric = App.MainChartHeatmapDFSBytesReadMetric.create();

    tests.forEach(function(test) {
      it(test.i + ' bytes to ' + test.e + ' MB', function() {
        var r = mainChartHeatmapDFSBytesReadMetric.transformValue(test.i);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_byteswritten_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_byteswritten');

describe('App.MainChartHeatmapDFSBytesWrittenMetric', function () {

  var tests = [
    {i: 0, e: 0},
    {i: 0.5 * 1024* 1024, e: 0.5},
    {i: 1024* 1024, e: 1},
    {i: 10.5 * 1024 * 1024,e: 10.5}
  ];

  describe('#transformValue()', function() {
    var mainChartHeatmapDFSBytesWrittenMetric = App.MainChartHeatmapDFSBytesWrittenMetric.create();

    tests.forEach(function(test) {
      it(test.i + ' bytes to ' + test.e + ' MB', function() {
        var r = mainChartHeatmapDFSBytesWrittenMetric.transformValue(test.i);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');

describe('App.MainChartHeatmapDFSMetrics', function () {

  var tests = [
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 285
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 285},
      m: 'One host_component'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 285
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 124
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 285, 'dev02.hortonworks.com': 124},
      m: 'Two host_components'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 285
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {

              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 285},
      m: 'Two host_components, one without metric'
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapDFSMetrics = App.MainChartHeatmapDFSMetrics.create();
    mainChartHeatmapDFSMetrics.set('defaultMetric', 'metrics.jvm.gcTimeMillis');

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapDFSMetrics.metricMapper(test.json);
        expect(r).to.eql(test.result);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_diskspaceused_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_diskspaceused');

describe('App.MainChartHeatmapDiskSpaceUsedMetric', function () {

  var tests = Em.A([
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          }
        ]
      },
      m: 'One host',
      e: {'dev01.hortonworks.com': 11.37}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          }
        ]
      },
      m: 'Two hosts',
      e: {'dev01.hortonworks.com': 11.37, 'dev02.hortonworks.com': 11.37}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {

            }
          }
        ]
      },
      m: 'Two hosts, One without metric',
      e: {'dev01.hortonworks.com': 11.37}
    }
  ]);

  describe('#metricMapper()', function() {
    var mainChartHeatmapDiskSpaceUsedMetric = App.MainChartHeatmapDiskSpaceUsedMetric.create();

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapDiskSpaceUsedMetric.metricMapper(test.json);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase');

describe('App.MainChartHeatmapHbaseMetrics', function () {

  var tests = [
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 0.0
                }
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 0},
      m: 'One host_component'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 0.0
                }
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 1.0
                }
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 0, 'dev02.hortonworks.com': 1},
      m: 'Two host_components'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 0.0
                }
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {

                }
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 0},
      m: 'Two host_components, one without metric'
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapHbaseMetrics = App.MainChartHeatmapHbaseMetrics.create();
    mainChartHeatmapHbaseMetrics.set('defaultMetric', 'metrics.hbase.regionserver.readRequestsCount');

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapHbaseMetrics.metricMapper(test.json);
        expect(r).to.eql(test.result);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_memoryused_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_memoryused');

describe('App.MainChartHeatmapMemoryUsedMetric', function () {

  var tests = [
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          }
        ]
      },
      m: 'One host',
      e: {'dev01.hortonworks.com': '63.6'}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          }
        ]
      },
      m: 'Two hosts',
      e: {'dev01.hortonworks.com': '63.6', 'dev02.hortonworks.com': '63.6'}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {

            }
          }
        ]
      },
      m: 'Two hosts, One without metric',
      e: {'dev01.hortonworks.com': '63.6'}
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapMemoryUsedMetric = App.MainChartHeatmapMemoryUsedMetric.create();

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapMemoryUsedMetric.metricMapper(test.json);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');

describe('MainChartHeatmapMetric', function () {

  var mainChartHeatmapMetric = App.MainChartHeatmapMetric.create({});

  describe('#formatLegendNumber', function () {
    var tests = [
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to 0',i:0,e:0},
      {m:'1 to 1',i:1,e:1},
      {m:'1.23 to 1.2',i:1.23,e:1.2}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN' + ' ', function () {
      expect(isNaN(mainChartHeatmapMetric.formatLegendNumber(NaN))).to.equal(true);
    });
  });

  describe('#refreshHostSlots', function() {
    beforeEach(function() {
      App.set('apiPrefix', '/api/v1');
      App.set('clusterName', 'tdk');
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    mainChartHeatmapMetric  = App.MainChartHeatmapMetric.create({});
    mainChartHeatmapMetric.set('ajaxIndex', 'hosts.metrics.host_component');
    mainChartHeatmapMetric.set('ajaxData', {
      serviceName: 'SERVICE',
      componentName: 'COMPONENT'
    });
    mainChartHeatmapMetric.set('defaultMetric', 'default.metric');

    it('Should load proper URL', function() {
      mainChartHeatmapMetric.refreshHostSlots();
      expect($.ajax.args[0][0].url.endsWith('/api/v1/clusters/tdk/services/SERVICE/components/COMPONENT?fields=host_components/default/metric')).to.equal(true);
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_yarn_ResourceUsed_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_yarn');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_yarn_ResourceUsed');

describe('App.MainChartHeatmapYarnResourceUsedMetric', function () {

  var mainChartHeatmapYarnResourceUsedMetric = App.MainChartHeatmapYarnResourceUsedMetric.create({});

  describe('#metricMapper', function () {
    var tests = [
      {
        m: 'Correct JSON #1',
        i: {
          ServiceComponentInfo: {
            cluster_name: "c1",
            component_name: "NODEMANAGER",
            service_name: "YARN"
          },
          host_components: [{
            HostRoles: {
              cluster_name: "c1",
              component_name: "NODEMANAGER",
              host_name: "host1"
            },
            metrics: {
              yarn: {
                AllocatedGB: 0,
                AvailableGB: 2
              }
            }
          }]
        },
        e: {
          length: 1,
          val: '0.0',
          host: 'host1'
        }
      },
      {
        m: 'Correct JSON #2',
        i: {
          ServiceComponentInfo: {
            cluster_name: "c1",
            component_name: "NODEMANAGER",
            service_name: "YARN"
          },
          host_components: [{
            HostRoles: {
              cluster_name: "c1",
              component_name: "NODEMANAGER",
              host_name: "host1"
            },
            metrics: {
              yarn: {
                AllocatedGB: 1,
                AvailableGB: 2
              }
            }
          }]
        },
        e: {
          length: 1,
          val: '33.3',
          host: 'host1'
        }
      },
      {
        m: 'Correct JSON #3',
        i: {
          ServiceComponentInfo: {
            cluster_name: "c1",
            component_name: "NODEMANAGER",
            service_name: "YARN"
          },
          host_components: [{
            HostRoles: {
              cluster_name: "c1",
              component_name: "NODEMANAGER",
              host_name: "host1"
            },
            metrics: {
              yarn: {
                AllocatedGB: 0,
                AvailableGB: 0
              }
            }
          }]
        },
        e: {
          length: 1,
          val: 'Unknown',
          host: 'host1'
        }
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function () {
        var result = mainChartHeatmapYarnResourceUsedMetric.metricMapper(test.i),
          length = Em.keys(result).length;
        expect(length).to.equal(test.e.length);
        if (test.e.host) {
          expect(result.hasOwnProperty(test.e.host)).to.equal(true);
          expect(result[test.e.host]).to.equal(test.e.val);
        }
      });
    });
  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_yarn');

describe('App.MainChartHeatmapYarnMetrics', function () {

  var tests = [
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 10
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 10},
      m: 'One host_component'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 10
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 20
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 10, 'dev02.hortonworks.com': 20},
      m: 'Two host_components'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 10
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {

              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 10},
      m: 'Two host_components, one without metric'
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapYarnMetrics = App.MainChartHeatmapYarnMetrics.create();
    mainChartHeatmapYarnMetrics.set('defaultMetric', 'metrics.jvm.memHeapUsedM');

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapYarnMetrics.metricMapper(test.json);
        expect(r).to.eql(test.result);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/rack');
require('controllers/main/charts/heatmap');

describe('MainChartsHeatmapController', function () {

  describe('#validation()', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      selectedMetric: Ember.Object.create({maximumValue: 100})
    });
    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 5);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", 'qwerty');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", '100%');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 1000);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(1000);
    })
  });

  describe('#showHeatMapMetric()', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      selectedMetric: Ember.Object.create({maximumValue: 100}),
      loadMetrics: function () {
      }
    });
    controller.set("selectedMetric", 100);
    it('should not set selectedMetric event.context if it is not defined', function () {
      controller.showHeatMapMetric({});
      expect(controller.get('selectedMetric')).to.equal(100);
    });
    it('should set selectedMetric event.context if it is defined', function () {
      controller.showHeatMapMetric({context: 5});
      expect(controller.get('selectedMetric')).to.equal(5);
    });
  });

  describe('#loadMetrics()', function () {
    var controller = App.MainChartsHeatmapController.create({
      testPassed: false,
      allMetrics: [],
      inputMaximum: 10
    });
    controller.set('selectedMetric', Ember.Object.create({
      maximumValue: 100,
      refreshHostSlots: function () {
        controller.set('testPassed', true);
      }
    }));
    controller.loadMetrics();
    it('should set inputMaximum as selectedMetric.maximumValue', function () {
      expect(controller.get('inputMaximum')).to.equal(100);
    });
    it('should call refreshHostSlots from selectedMetric', function () {
      expect(controller.get('testPassed')).to.equal(true);
    });
  });

  describe('#rackClass', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      racks: [1]
    });
    it('should return "span12" for 1 cluster rack', function () {
      expect(controller.get('rackClass')).to.equal('span12');
    });
    it('should return "span6" for 2 cluster racks', function () {
      controller.set('racks', [1, 2]);
      expect(controller.get('rackClass')).to.equal('span6');
    });
    it('should return "span4" for 3 cluster racks', function () {
      controller.set('racks', [1, 2, 3]);
      expect(controller.get('rackClass')).to.equal('span4');
    });
  });
});


});

;require.register("test/controllers/main/dashboard/config_history_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/dashboard/config_history_controller');

describe('MainConfigHistoryController', function () {

  var controller = App.MainConfigHistoryController.create();

  describe('#realUrl', function () {
    it('cluster name is empty', function () {
      App.set('clusterName', '');
      expect(controller.get('realUrl')).to.equal('/api/v1/clusters//configurations/service_config_versions?<parameters>fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note&minimal_response=true');
    });
    it('cluster name is "mycluster"', function () {
      App.set('clusterName', 'mycluster');
      expect(controller.get('realUrl')).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?<parameters>fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note&minimal_response=true');
    });
  });
  describe('#load()', function () {
    it('', function () {
      sinon.stub(controller, 'updateTotalCounter', Em.K);

      controller.load();
      expect(controller.updateTotalCounter.calledOnce).to.be.true;

      controller.updateTotalCounter.restore();
    });
  });
  describe('#loadConfigVersionsToModel()', function () {
    it('', function () {
      sinon.stub(App.HttpClient, 'get', Em.K);
      sinon.stub(controller, 'getUrl', Em.K);
      sinon.stub(controller, 'getQueryParameters', function(){
        return [1];
      });

      controller.loadConfigVersionsToModel();
      expect(App.HttpClient.get.calledOnce).to.be.true;
      expect(controller.getQueryParameters.calledOnce).to.be.true;
      expect(controller.getUrl.calledWith([1])).to.be.true;


      controller.getUrl.restore();
      controller.getQueryParameters.restore();
      App.HttpClient.get.restore();
    });
  });

  describe('#updateTotalCounter()', function () {
    it('', function () {
      sinon.stub(App.ajax, 'send', Em.K);

      controller.updateTotalCounter();
      expect(App.ajax.send.calledOnce).to.be.true;

      App.ajax.send.restore();
    });
  });

  describe('#updateTotalCounterSuccess()', function () {
    it('', function () {
      controller.updateTotalCounterSuccess({itemTotal: 1});
      expect(controller.get('totalCount')).to.equal(1);
    });
  });
  describe('#getUrl()', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return {
          computeParameters: function () {
            return 'params'
          }
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
      App.get.restore();
    });
    it('testMode is true', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      expect(controller.getUrl()).to.equal('/data/configurations/service_versions.json');
    });
    it('query params is empty', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      expect(controller.getUrl()).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note&minimal_response=true');
    });
    it('query params is correct', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      expect(controller.getUrl({})).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?paramsfields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note&minimal_response=true');
    });
  });

  describe('#doPolling()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'load', function(){
        return {done: Em.K};
      });
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      this.clock.restore();
      controller.load.restore();
    });
    it('isPolling false', function () {
      controller.set('isPolling', false);
      controller.doPolling();
      this.clock.tick(App.componentsUpdateInterval);
      expect(controller.load.called).to.be.false;
    });
    it('isPolling true', function () {
      controller.set('isPolling', true);
      controller.doPolling();
      this.clock.tick(App.componentsUpdateInterval);
      expect(controller.load.calledOnce).to.be.true;
    });
  });
});


});

;require.register("test/controllers/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
var App = require('app');

require('models/alert'); 
App.Alert.FIXTURES = [{ status: 'ok' }, { status: 'corrupt' }, { status: 'corrupt',}];
require('controllers/main/dashboard');
 
describe('MainDashboard', function () {
 
  var controller = App.MainDashboardController.create();
  
  describe('#alertsCount', function () {
    it('should return 2 if 2 alerts has status corrupt', function () {
        expect(controller.get('alertsCount')).to.equal(2);
    })
  })
})
*/
});

;require.register("test/controllers/main/host/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/wizard');
require('controllers/main/host/add_controller');
require('models/host_component');
require('models/service');
require('mappers/server_data_mapper');

describe('App.AddHostController', function () {

  var controller = App.AddHostController.create({
    testDBHosts: null,
    getDBProperty: function () {
      return this.get('testDBHosts');
    },
    setDBProperty: function () {
    },
    loadClients: function () {
    }
  });

  beforeEach(function () {
    sinon.spy(controller, "setDBProperty");
  });
  afterEach(function () {
    controller.setDBProperty.restore();
  });

  describe('#removeHosts()', function () {
    var testCases = [
      {
        title: 'No hosts, db is empty',
        content: {
          hosts: [],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Host is passed, db is empty',
        content: {
          hosts: [
            {hostName: 'host1'}
          ],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Passed host different from hosts in db',
        content: {
          hosts: [
            {hostName: 'host1'}
          ],
          dbHosts: {
            'host2': {}
          }
        },
        result: {
          'host2': {}
        }
      },
      {
        title: 'Passed host match host in db',
        content: {
          hosts: [
            {hostName: 'host1'}
          ],
          dbHosts: {
            'host1': {}
          }
        },
        result: {}
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('testDBHosts', test.content.dbHosts);
        controller.removeHosts(test.content.hosts);
        expect(controller.setDBProperty.calledWith('hosts', test.result)).to.be.true;
      });
    });
  });

  describe('#sortServiceConfigGroups()', function () {
    var testCases = [
      {
        title: 'No selected services',
        selectedServices: [
          {configGroups: []}
        ],
        result: [
          {configGroups: []}
        ]
      },
      {
        title: 'Only one group is present',
        selectedServices: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ],
        result: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ]
      },
      {
        title: 'Reverse order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'b2'}},
            {ConfigGroup: {group_name: 'a1'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      },
      {
        title: 'Correct order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.sortServiceConfigGroups(test.selectedServices);
        expect(test.selectedServices).to.eql(test.result);
      });
    });
  });

  describe('#loadServiceConfigGroupsBySlaves()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        slaveComponentHosts: null,
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        slaveComponentHosts: [],
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Component does not have hosts',
        slaveComponentHosts: [
          {hosts: []}
        ],
        result: {
          output: true,
          selectedServices: []
        }
      },
      {
        title: 'Only client component is present',
        slaveComponentHosts: [
          {
            hosts: [
              {hostName: 'host1'}
            ],
            componentName: 'CLIENT'
          }
        ],
        result: {
          output: true,
          selectedServices: []
        }
      }
    ];

    controller.set('content.configGroups', [
      {
        ConfigGroup: {
          tag: 'HDFS',
          group_name: 'HDFS test'
        }
      }
    ]);
    testCases.forEach(function (test) {
      it(test.title, function () {
        var selectedServices = [];
        controller.set('content.slaveComponentHosts', test.slaveComponentHosts);
        expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.equal(test.result.output);
        expect(selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#loadServiceConfigGroupsByClients()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        content: {
          slaveComponentHosts: null,
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        content: {
          slaveComponentHosts: [],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client does not have hosts',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: []
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client has hosts, but clients is empty',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: [
                {hostName: 'host1'}
              ]
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('content.slaveComponentHosts', test.content.slaveComponentHosts);
        controller.set('content.clients', test.content.clients);
        expect(controller.loadServiceConfigGroupsByClients(test.content.selectedServices)).to.equal(test.result.output);
        expect(test.content.selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#installServices()', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, "send");
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('No hosts', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {});
      expect(controller.installServices()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('Cluster name is empty', function () {
      controller.set('content.cluster', {name: ''});
      controller.set('testDBHosts', {'host1': {}});
      expect(controller.installServices()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('Cluster name is correct and hosts are present', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {'host1': {isInstalled: false}});
      expect(controller.installServices()).to.be.true;
      expect(App.ajax.send.called).to.be.true;
    });
  });

  describe('#getClientsToInstall', function () {
    var services = [
      Em.Object.create({
        serviceName: 'service1'
      }),
      Em.Object.create({
        serviceName: 'service2'
      })
    ];
    var components = [
      Em.Object.create({
        componentName: 'comp1',
        displayName: 'comp1',
        serviceName: 'service1',
        isClient: true
      }),
      Em.Object.create({
        componentName: 'comp2',
        displayName: 'comp2',
        serviceName: 'service1',
        isClient: true
      }),
      Em.Object.create({
        componentName: 'comp3',
        displayName: 'comp3',
        serviceName: 'service2',
        isClient: false
      }),
      Em.Object.create({
        componentName: 'comp4',
        displayName: 'comp4',
        serviceName: 'service3',
        isClient: true
      })
    ];
    var clients = [
      {
        component_name: 'comp1',
        display_name: 'comp1',
        isInstalled: false
      },
      {
        component_name: 'comp2',
        display_name: 'comp2',
        isInstalled: false
      }
    ];
    it("generatel list of clients to install", function () {
      expect(controller.getClientsToInstall(services, components)).to.eql(clients);
    })
  })
});

});

;require.register("test/controllers/main/host/configs_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/configs_service');


describe('App.MainHostServiceConfigsController', function () {

  var controller = App.MainHostServiceConfigsController.create({
    host: Em.Object.create()
  });


  describe('#filterServiceConfigs()', function () {
    var testCases = [
      {
        title: 'configCategories is empty',
        content: {
          configCategories: [],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Category hostComponentNames is null',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: null})
          ],
          hostComponents: []
        },
        result: [
          Em.Object.create({hostComponentNames: null})
        ]
      },
      {
        title: 'Components of host are empty',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Host components do not match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp2'
            }
          ]
        },
        result: []
      },
      {
        title: 'Host components match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp1'
            }
          ]
        },
        result: [
          Em.Object.create({hostComponentNames: ['comp1']})
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('host.hostComponents', test.content.hostComponents);
        expect(controller.filterServiceConfigs(test.content.configCategories)).to.eql(test.result);
      });
    });
  });

});

});

;require.register("test/controllers/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/details');
require('models/service');
require('models/host_component');
var batchUtils = require('utils/batch_scheduled_requests');
var componentsUtils = require('utils/components');
var controller;

describe('App.MainHostDetailsController', function () {


  beforeEach(function () {
    sinon.stub(App.ajax, 'send').returns({
      then: Em.K
    });
    controller = App.MainHostDetailsController.create({
      content: Em.Object.create()
    });
  });
  afterEach(function () {
    App.ajax.send.restore();
  });

  describe('#routeHome()', function () {
    it('transiotion to dashboard', function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      controller.routeHome();
      expect(App.router.transitionTo.calledWith('main.dashboard.index')).to.be.true;
      App.router.transitionTo.restore();
    });
  });

  describe('#routeToService()', function () {
    it('transiotion to dashboard', function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      controller.routeToService({context: {'service': 'service'}});
      expect(App.router.transitionTo.calledWith('main.services.service.summary', {'service': 'service'})).to.be.true;
      App.router.transitionTo.restore();
    });
  });

  describe('#startComponent()', function () {
    it('call sendComponentCommand', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'comp'
        })
      };
      sinon.stub(App, 'showConfirmationPopup', function (callback) {
        callback();
      });
      sinon.stub(controller, 'sendComponentCommand');
      controller.startComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      expect(controller.sendComponentCommand.calledWith(Em.Object.create({
        displayName: 'comp'
      })), Em.I18n.t('requestInfo.startHostComponent') + " comp", App.HostComponentStatus.started).to.be.true;
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
    });
  });

  describe('#stopComponent()', function () {
    it('call sendComponentCommand', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'comp'
        })
      };
      sinon.stub(App, 'showConfirmationPopup', function (callback) {
        callback();
      });
      sinon.stub(controller, 'sendComponentCommand');
      controller.stopComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      expect(controller.sendComponentCommand.calledWith(Em.Object.create({
        displayName: 'comp'
      })), Em.I18n.t('requestInfo.stopHostComponent') + " comp", App.HostComponentStatus.started).to.be.true;
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
    });
  });

  describe('#sendComponentCommand()', function () {
    it('single component', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({
        service: {serviceName: 'S1'},
        componentName: 'COMP1'
      });

      controller.sendComponentCommand(component, {}, 'state');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.host.host_component.update');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        "hostName": "host1",
        "context": {},
        "component": Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP1'
        }),
        "HostRoles": {
          "state": "state"
        },
        "componentName": "COMP1",
        "serviceName": "S1"
      });
    });
    it('multiple component', function () {
      controller.set('content.hostName', 'host1');
      var component = [
        Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP1'
        }),
        Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP2'
        })
      ];

      controller.sendComponentCommand(component, {}, 'state');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.host.host_components.update');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        "hostName": "host1",
        "context": {},
        "component": [
          Em.Object.create({
            service: {serviceName: 'S1'},
            componentName: 'COMP1'
          }),
          Em.Object.create({
            service: {serviceName: 'S1'},
            componentName: 'COMP2'
          })
        ],
        "HostRoles": {
          "state": "state"
        },
        "query": "HostRoles/component_name.in(COMP1,COMP2)"
      });
    });
  });

  describe('#sendComponentCommandSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
      controller.mimicWorkStatusChange.restore();
    });
    it('testMode, starting component', function () {
      var params = {
        component: Em.Object.create({}),
        HostRoles: {
          state: App.HostComponentStatus.started
        }
      };

      App.set('testMode', true);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
      expect(controller.mimicWorkStatusChange.calledWith(Em.Object.create({
        workStatus: App.HostComponentStatus.starting
      }), App.HostComponentStatus.starting, App.HostComponentStatus.started)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode, stopping component', function () {
      var params = {
        component: Em.Object.create({}),
        HostRoles: {
          state: App.HostComponentStatus.stopped
        }
      };

      App.set('testMode', true);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
      expect(controller.mimicWorkStatusChange.calledWith(Em.Object.create({
        workStatus: App.HostComponentStatus.stopping
      }), App.HostComponentStatus.stopping, App.HostComponentStatus.stopped)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode, stopping component', function () {
      var params = {
        component: Em.Object.create({}),
        HostRoles: {
          state: App.HostComponentStatus.stopped
        }
      };

      App.set('testMode', false);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#ajaxErrorCallback()', function () {
    it('call componentsUtils.ajaxErrorCallback', function () {
      sinon.stub(componentsUtils, 'ajaxErrorCallback', Em.K);
      controller.ajaxErrorCallback('request', 'ajaxOptions', 'error', 'opt', 'params');
      expect(componentsUtils.ajaxErrorCallback.calledWith('request', 'ajaxOptions', 'error', 'opt', 'params')).to.be.true;
      componentsUtils.ajaxErrorCallback.restore();
    });
  });

  describe('#showBackgroundOperationsPopup()', function () {
    var mock = {
      done: function (callback) {
        callback(this.initValue);
      }
    };
    var bgController = {
      showPopup: Em.K
    };
    beforeEach(function () {
      var stub = sinon.stub(App.router, 'get');
      stub.withArgs('applicationController').returns({
        dataLoading: function () {
          return mock;
        }
      });
      stub.withArgs('backgroundOperationsController').returns(bgController);
      sinon.spy(bgController, 'showPopup');
      sinon.spy(mock, 'done');
    });
    afterEach(function () {
      bgController.showPopup.restore();
      mock.done.restore();
      App.router.get.restore();
    });
    it('initValue is true, callback is undefined', function () {
      mock.initValue = true;
      controller.showBackgroundOperationsPopup();
      expect(mock.done.calledOnce).to.be.true;
      expect(bgController.showPopup.calledOnce).to.be.true;
    });
    it('initValue is false, callback is defined', function () {
      mock.initValue = false;
      var callback = sinon.stub();
      controller.showBackgroundOperationsPopup(callback);
      expect(mock.done.calledOnce).to.be.true;
      expect(bgController.showPopup.calledOnce).to.be.false;
      expect(callback.calledOnce).to.be.true;
    });
  });


  describe('#serviceActiveComponents', function () {

    it('No host-components', function () {
      controller.set('content', {hostComponents: []});
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });

    it('No host-components in active state', function () {
      controller.set('content', {hostComponents: [Em.Object.create({
        service: {
          isInPassive: true
        }
      })]});
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });
    it('Host-components in active state', function () {
      controller.set('content', {hostComponents: [Em.Object.create({
        service: {
          isInPassive: false
        }
      })]});
      expect(controller.get('serviceActiveComponents')).to.eql([Em.Object.create({
        service: {
          isInPassive: false
        }
      })]);
    });
  });

  describe('#serviceNonClientActiveComponents', function () {

    it('No active host-components', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.set('serviceActiveComponents', []);
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });

    it('Active host-component is client', function () {
      controller.reopen({serviceActiveComponents: [Em.Object.create({
        isClient: true
      })]});
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });
    it('Active host-component is not client', function () {
      controller.reopen({serviceActiveComponents: [Em.Object.create({
        isClient: false
      })]});
      expect(controller.get('serviceNonClientActiveComponents')).to.eql([Em.Object.create({
        isClient: false
      })]);
    });
  });

  describe('#deleteComponent()', function () {
    it('confirm popup should be displayed', function () {
      var event = {
        context: Em.Object.create({})
      };
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(controller, '_doDeleteHostComponent', Em.K);

      var popup = controller.deleteComponent(event);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller._doDeleteHostComponent.calledWith(Em.Object.create({}))).to.be.true;
      App.ModalPopup.show.restore();
      controller._doDeleteHostComponent.restore();
    });
  });

  describe('#mimicWorkStatusChange()', function () {

    var clock;
    beforeEach(function () {
      clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      clock.restore()
    });

    it('change status of object', function () {
      var entity = Em.Object.create({
        workStatus: ''
      });
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity.get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity.get('workStatus')).to.equal('STATE2');
    });
    it('change status of objects in array', function () {
      var entity = [Em.Object.create({
        workStatus: ''
      })];
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity[0].get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity[0].get('workStatus')).to.equal('STATE2');
    });
  });

  describe('#upgradeComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.upgradeComponent({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#restartComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.restartComponent({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledOnce).to.be.true;
    });
  });

  describe('#securityEnabled', function () {
    it('', function () {
      sinon.stub(App.router, 'get').withArgs('mainAdminSecurityController.securityEnabled').returns(true);

      controller.propertyDidChange('securityEnabled');
      expect(controller.get('securityEnabled')).to.be.true;
      App.router.get.restore();
    });
  });


  describe('#addComponent()', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "addClientComponent", Em.K);
      sinon.stub(controller, "primary", Em.K);
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: "HDFS_CLIENT"
      })]});
      controller.reopen({
        securityEnabled: false
      });
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.addClientComponent.restore();
      controller.primary.restore();
    });

    it('add ZOOKEEPER_SERVER', function () {
      var event = {context: Em.Object.create({
        componentName: 'ZOOKEEPER_SERVER'
      })};
      var popup = controller.addComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledWith(Em.Object.create({
        componentName: 'ZOOKEEPER_SERVER'
      }))).to.be.true;
    });
    it('add slave component, securityEnabled = true', function () {
      var event = {context: Em.Object.create({
        componentName: 'HIVE_CLIENT'
      })};
      controller.set('securityEnabled', true);
      var popup = controller.addComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledWith(Em.Object.create({
        componentName: 'HIVE_CLIENT'
      }))).to.be.true;
    });
    it('add slave component, securityEnabled = false', function () {
      var event = {context: Em.Object.create({
        componentName: 'HIVE_CLIENT'
      })};
      controller.set('securityEnabled', false);
      controller.addComponent(event);
      expect(controller.addClientComponent.calledWith(Em.Object.create({
        componentName: 'HIVE_CLIENT'
      }))).to.be.true;
    });
  });

  describe('#formatClientsMessage()', function () {
    var testCases = [
      {
        title: 'subComponentNames is null',
        client: Em.Object.create({
          subComponentNames: null,
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS'
      },
      {
        title: 'subComponentNames is empty',
        client: Em.Object.create({
          subComponentNames: [],
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS'
      },
      {
        title: 'displayName is null',
        client: Em.Object.create({
          subComponentNames: ['DATANODE'],
          displayName: null
        }),
        result: ' (DataNode)'
      },
      {
        title: 'displayName is CLIENTS',
        client: Em.Object.create({
          subComponentNames: ['DATANODE'],
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS (DataNode)'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.formatClientsMessage(test.client)).to.equal(test.result);
      });
    });
  });

  describe('#addClientComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(controller, "primary", Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      controller.primary.restore();
    });

    it('not CLIENT component', function () {
      var component = Em.Object.create({'componentName': 'Comp1'});
      var popup = controller.addClientComponent(component);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledWith(Em.Object.create({'componentName': 'Comp1'}))).to.be.true;
    });
    it('CLIENT components, with empty subComponentNames', function () {
      var component = Em.Object.create({
        componentName: 'CLIENTS',
        subComponentNames: []
      });
      var popup = controller.addClientComponent(component);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledOnce).to.be.false;
    });
    it('CLIENT components, with two sub-component', function () {
      var component = Em.Object.create({
        componentName: 'CLIENTS',
        subComponentNames: ['DATANODE', 'TASKTRACKER']
      });
      var popup = controller.addClientComponent(component);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledTwice).to.be.true;
    });
  });

  describe('#primary()', function () {
    it('Query should be sent', function () {
      var component = Em.Object.create({
        componentName: 'COMP1',
        displayName: 'comp1'
      });
      controller.primary(component);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#installNewComponentSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data.Requests is null', function () {
      var data = {Requests: null};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is null', function () {
      var data = {Requests: {id: null}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is correct', function () {
      var data = {Requests: {id: 1}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {component: []})).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "sendRefreshComponentConfigsCommand", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendRefreshComponentConfigsCommand.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.refreshComponentConfigs({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendRefreshComponentConfigsCommand.calledOnce).to.be.true;
    });
  });

  describe('#sendRefreshComponentConfigsCommand()', function () {
    it('Query should be sent', function () {
      var component = Em.Object.create({
        service: {},
        componentName: 'COMP1',
        host: {}
      });
      controller.sendRefreshComponentConfigsCommand(component, {});
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#loadConfigs()', function () {
    it('Query should be sent', function () {
      controller.loadConfigs();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#constructConfigUrlParams()', function () {

    it('URL params should be empty', function () {
      var data = {};
      App.Service.find().clear();
      expect(controller.constructConfigUrlParams(data)).to.eql([]);
    });
    it('isHaEnabled = true', function () {
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      var data = {Clusters: {desired_configs: {'core-site': {tag: 1}}}};
      App.HostComponent.find().clear();
      App.set('currentStackVersion', 'HDP-2.0.2');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=core-site&tag=1)']);
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
    });
    it('HBASE is installed', function () {
      App.store.load(App.Service, {
        id: 'HBASE',
        service_name: 'HBASE'
      });
      var data = {Clusters: {desired_configs: {'hbase-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=hbase-site&tag=1)']);
      App.Service.find().clear();
    });
    it('HIVE is installed', function () {
      App.store.load(App.Service, {
        id: 'HIVE',
        service_name: 'HIVE'
      });
      var data = {Clusters: {desired_configs: {'webhcat-site': {tag: 1}, 'hive-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=webhcat-site&tag=1)', '(type=hive-site&tag=1)']);
      App.Service.find().clear();
    });
    it('STORM is installed', function () {
      App.store.load(App.Service, {
        id: 'STORM',
        service_name: 'STORM'
      });
      var data = {Clusters: {desired_configs: {'storm-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=storm-site&tag=1)']);
      App.Service.find().clear();
    });
    it('YARN for 2.2 stack is installed', function () {
      App.set('currentStackVersion', 'HDP-2.2.0');
      App.store.load(App.Service, {
        id: 'YARN',
        service_name: 'YARN'
      });
      var data = {Clusters: {desired_configs: {'yarn-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=yarn-site&tag=1)']);
      App.set('currentStackVersion', 'HDP-2.0.1');
      App.Service.find().clear();
    });
    it('isRMHaEnabled true', function () {
      sinon.stub(App, 'get').withArgs('isRMHaEnabled').returns(true);
      var data = {Clusters: {desired_configs: {'yarn-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=yarn-site&tag=1)']);
      App.get.restore();
    });
  });

  describe('#loadConfigsSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "constructConfigUrlParams", function () {
        return this.get('mockUrlParams');
      });
    });
    afterEach(function () {
      controller.constructConfigUrlParams.restore();
    });

    it('url params is empty', function () {
      controller.set('mockUrlParams', []);
      expect(controller.loadConfigsSuccessCallback()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('url params are correct', function () {
      controller.set('mockUrlParams', ['param1']);
      expect(controller.loadConfigsSuccessCallback()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#saveZkConfigs()', function () {

    beforeEach(function () {
      sinon.stub(controller, "getZkServerHosts", Em.K);
      sinon.stub(controller, "concatZkNames", Em.K);
      sinon.stub(controller, "setZKConfigs", Em.K);
    });
    afterEach(function () {
      controller.getZkServerHosts.restore();
      controller.concatZkNames.restore();
      controller.setZKConfigs.restore();
    });

    it('data.items is empty', function () {
      var data = {items: []};
      controller.saveZkConfigs(data);
      expect(App.ajax.send.called).to.be.false;
    });
    it('data.items has one item', function () {
      var data = {items: [
        {
          type: 'type1',
          properties: {}
        }
      ]};
      controller.saveZkConfigs(data);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
    it('data.items has two items', function () {
      var data = {items: [
        {
          type: 'type1',
          properties: {}
        },
        {
          type: 'type2',
          properties: {}
        }
      ]};
      controller.saveZkConfigs(data);
      expect(App.ajax.send.calledTwice).to.be.true;
    });
  });

  describe('#setZKConfigs()', function () {
    it('configs is null', function () {
      expect(controller.setZKConfigs(null)).to.be.false;
    });
    it('zks is null', function () {
      expect(controller.setZKConfigs({}, '', null)).to.be.false;
    });
    it('isHaEnabled = true', function () {
      var configs = {'core-site': {}};
      App.HostComponent.find().clear();
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      App.set('currentStackVersion', 'HDP-2.0.2');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"core-site": {
        "ha.zookeeper.quorum": "host1:2181"
      }});
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
    });
    it('hbase-site is present', function () {
      var configs = {'hbase-site': {}};
      expect(controller.setZKConfigs(configs, '', ['host1', 'host2'])).to.be.true;
      expect(configs).to.eql({"hbase-site": {
        "hbase.zookeeper.quorum": "host1,host2"
      }});
    });
    it('webhcat-site is present', function () {
      var configs = {'webhcat-site': {}};
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"webhcat-site": {
        "templeton.zookeeper.hosts": "host1:2181"
      }});
    });
    it('hive-site is present and stack < 2.2', function () {
      var version = App.get('currentStackVersion');
      var configs = {'hive-site': {}};
      App.set('currentStackVersion', 'HDP-2.1.0');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"hive-site": {
        'hive.cluster.delegation.token.store.zookeeper.connectString': "host1:2181"
      }});
      App.set('currentStackVersion', version);
    });
    it('hive-site is present and stack > 2.2', function () {
      var version = App.get('currentStackVersion');
      var configs = {'hive-site': {}};
      App.set('currentStackVersion', 'HDP-2.2.0');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"hive-site": {
        'hive.cluster.delegation.token.store.zookeeper.connectString': "host1:2181",
        'hive.zookeeper.quorum': "host1:2181"
      }});
      App.set('currentStackVersion', version);
    });
    it('yarn-site is present and stack > 2.2', function () {
      var version = App.get('currentStackVersion');
      var configs = {'yarn-site': {}};
      App.set('currentStackVersion', 'HDP-2.2.0');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"yarn-site": {
        'hadoop.registry.zk.quorum': "host1:2181"
      }});
      App.set('currentStackVersion', version);
    });
    it('storm-site is present', function () {
      var configs = {'storm-site': {}};
      expect(controller.setZKConfigs(configs, '', ["host1", 'host2'])).to.be.true;
      expect(configs).to.eql({"storm-site": {
        "storm.zookeeper.servers": "['host1','host2']"
      }});
    });
    it('isRMHaEnabled true', function () {
      var configs = {'yarn-site': {}};
      sinon.stub(App, 'get').withArgs('isRMHaEnabled').returns(true);
      expect(controller.setZKConfigs(configs, 'host1:2181', ['host1', 'host2'])).to.be.true;
      expect(configs).to.eql({"yarn-site": {
        "yarn.resourcemanager.zk-address": "host1,host2"
      }});
      App.get.restore();
    });
  });

  describe('#concatZkNames()', function () {
    it('No ZooKeeper hosts', function () {
      expect(controller.concatZkNames([])).to.equal('');
    });
    it('One ZooKeeper host', function () {
      expect(controller.concatZkNames(['host1'])).to.equal('host1:2181');
    });
    it('Two ZooKeeper hosts', function () {
      expect(controller.concatZkNames(['host1', 'host2'])).to.equal('host1:2181,host2:2181');
    });
  });

  describe('#getZkServerHosts()', function () {

    beforeEach(function () {
      controller.set('content', {});
    });

    afterEach(function () {
      App.HostComponent.find.restore();
    });

    it('No ZooKeeper hosts, fromDeleteHost = false', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return []
      });
      controller.set('fromDeleteHost', false);
      expect(controller.getZkServerHosts()).to.be.empty;
    });

    it('No ZooKeeper hosts, fromDeleteHost = true', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return []
      });
      controller.set('fromDeleteHost', true);
      expect(controller.getZkServerHosts()).to.be.empty;
      expect(controller.get('fromDeleteHost')).to.be.false;
    });

    it('One ZooKeeper host, fromDeleteHost = false', function () {
      controller.set('fromDeleteHost', false);
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {id: 'ZOOKEEPER_SERVER_host1',
            componentName: 'ZOOKEEPER_SERVER',
            hostName: 'host1'
          }
        ]
      });
      expect(controller.getZkServerHosts()).to.eql(['host1']);
    });

    it('One ZooKeeper host match current host name, fromDeleteHost = true', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {id: 'ZOOKEEPER_SERVER_host1',
            componentName: 'ZOOKEEPER_SERVER',
            hostName: 'host1'
          }
        ]
      });
      controller.set('fromDeleteHost', true);
      controller.set('content.hostName', 'host1');
      expect(controller.getZkServerHosts()).to.be.empty;
      expect(controller.get('fromDeleteHost')).to.be.false;
    });

    it('One ZooKeeper host does not match current host name, fromDeleteHost = true', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {id: 'ZOOKEEPER_SERVER_host1',
            componentName: 'ZOOKEEPER_SERVER',
            hostName: 'host1'
          }
        ]
      });
      controller.set('fromDeleteHost', true);
      controller.set('content.hostName', 'host2');
      expect(controller.getZkServerHosts()[0]).to.equal("host1");
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
  });

  describe('#installComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('popup should be displayed', function () {
      var event = {context: Em.Object.create()};
      var popup = controller.installComponent(event);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#decommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runDecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runDecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.decommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runDecommission.calledOnce).to.be.true;
    });
  });

  describe('#recommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runRecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runRecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.recommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runRecommission.calledOnce).to.be.true;
    });
  });

  describe('#runDecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doDecommission", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doDecommission.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runDecommission('host1', 'HDFS');
      expect(controller.doDecommission.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
    });
    it('YARN service', function () {
      controller.runDecommission('host1', 'YARN');
      expect(controller.doDecommission.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
    });
    it('MAPREDUCE service', function () {
      controller.runDecommission('host1', 'MAPREDUCE');
      expect(controller.doDecommission.calledWith('host1', 'MAPREDUCE', "JOBTRACKER", "TASKTRACKER")).to.be.true;
    });
    it('HBASE service', function () {
      sinon.stub(controller, 'warnBeforeDecommission', Em.K);
      controller.runDecommission('host1', 'HBASE');
      expect(controller.warnBeforeDecommission.calledWith('host1')).to.be.true;
      controller.warnBeforeDecommission.restore();
    });
  });

  describe('#runRecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doRecommissionAndStart", Em.K);
      sinon.stub(controller, "doRecommissionAndRestart", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doRecommissionAndStart.restore();
      controller.doRecommissionAndRestart.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runRecommission('host1', 'HDFS');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('YARN service', function () {
      controller.runRecommission('host1', 'YARN');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('MAPREDUCE service', function () {
      controller.runRecommission('host1', 'MAPREDUCE');
      expect(controller.doRecommissionAndRestart.calledWith('host1', 'MAPREDUCE', "JOBTRACKER", "TASKTRACKER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('HBASE service', function () {
      controller.runRecommission('host1', 'HBASE');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HBASE', "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doDecommission()', function () {
    it('Query should be sent', function () {
      controller.doDecommission('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doDecommissionRegionServer()', function () {
    it('Query should be sent', function () {
      controller.doDecommissionRegionServer('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#warnBeforeDecommission()', function () {
    beforeEach(function () {
      sinon.stub(controller, "showHbaseActiveWarning", Em.K);
      sinon.stub(controller, "checkRegionServerState", Em.K);
    });
    afterEach(function () {
      controller.checkRegionServerState.restore();
      controller.showHbaseActiveWarning.restore();
    });

    it('Component in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'ON'
      })]);
      controller.warnBeforeDecommission('host1');
      expect(controller.checkRegionServerState.calledOnce).to.be.true;
    });
    it('Component is not in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'OFF'
      })]);
      controller.warnBeforeDecommission('host1');
      expect(controller.showHbaseActiveWarning.calledOnce).to.be.true;
    });
  });

  describe('#checkRegionServerState()', function () {
    it('', function () {
      expect(controller.checkRegionServerState('host1')).to.be.an('object');
      expect(App.ajax.send.getCall(0).args[0].data.hostNames).to.equal('host1');
    });
  });

  describe('#checkRegionServerStateSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, "doDecommissionRegionServer", Em.K);
      sinon.stub(controller, "showRegionServerWarning", Em.K);
    });
    afterEach(function () {
      controller.doDecommissionRegionServer.restore();
      controller.showRegionServerWarning.restore();
    });

    it('Decommission all regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1,host2'});
      expect(controller.showRegionServerWarning.calledOnce).to.be.true;
    });
    it('Decommission one of two regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1'});
      expect(controller.doDecommissionRegionServer.calledWith('host1', "HBASE", "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
    });
    it('Decommission one of three regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          },
          {
            HostRoles: {
              host_name: 'host3'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1'});
      expect(controller.doDecommissionRegionServer.calledWith('host1', "HBASE", "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
    });
  });

  describe('#showRegionServerWarning()', function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it('', function () {
      controller.showRegionServerWarning();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#doRecommissionAndStart()', function () {
    it('Query should be sent', function () {
      controller.doRecommissionAndStart('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#decommissionSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data is null', function () {
      expect(controller.decommissionSuccessCallback(null)).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data has Requests', function () {
      var data = {Requests: []};
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('data has resources', function () {
      var data = {resources: [
        {RequestSchedule: {}}
      ]};
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doRecommissionAndRestart()', function () {
    it('Query should be sent', function () {
      controller.doRecommissionAndRestart('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doAction()', function () {

    beforeEach(function () {
      sinon.stub(controller, "validateAndDeleteHost", Em.K);
      sinon.stub(controller, "doStartAllComponents", Em.K);
      sinon.stub(controller, "doStopAllComponents", Em.K);
      sinon.stub(controller, "doRestartAllComponents", Em.K);
      sinon.stub(controller, "onOffPassiveModeForHost", Em.K);
    });

    afterEach(function () {
      controller.validateAndDeleteHost.restore();
      controller.doStartAllComponents.restore();
      controller.doStopAllComponents.restore();
      controller.doRestartAllComponents.restore();
      controller.onOffPassiveModeForHost.restore();
    });

    it('"deleteHost" action', function () {
      var option = {context: {action: "deleteHost"}};
      controller.doAction(option);
      expect(controller.validateAndDeleteHost.calledOnce).to.be.true;
    });

    it('"startAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doStartAllComponents.calledOnce).to.be.true;
    });

    it('"startAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doStartAllComponents.called).to.be.false;
    });

    it('"stopAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doStopAllComponents.calledOnce).to.be.true;
    });

    it('"stopAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doStopAllComponents.called).to.be.false;
    });

    it('"restartAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doRestartAllComponents.calledOnce).to.be.true;
    });

    it('"restartAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doRestartAllComponents.called).to.be.false;
    });

    it('"onOffPassiveModeForHost" action', function () {
      var option = {context: {action: "onOffPassiveModeForHost"}};
      controller.doAction(option);
      expect(controller.onOffPassiveModeForHost.calledWith({action: "onOffPassiveModeForHost"})).to.be.true;
    });
  });

  describe('#onOffPassiveModeForHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "hostPassiveModeRequest", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.hostPassiveModeRequest.restore();
    });

    it('popup should be displayed, active = true', function () {
      var popup = controller.onOffPassiveModeForHost({active: true});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('ON')).to.be.true;
    });
    it('popup should be displayed, active = false', function () {
      var popup = controller.onOffPassiveModeForHost({active: false});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('OFF')).to.be.true;
    });
  });

  describe('#hostPassiveModeRequest()', function () {
    it('Query should be sent', function () {
      controller.hostPassiveModeRequest('', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doStartAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      controller.reopen({serviceActiveComponents: []});
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('serviceNonClientActiveComponents is empty', function () {
      controller.reopen({
        serviceNonClientActiveComponents: []
      });
      controller.doStartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is correct', function () {
      controller.reopen({
        serviceNonClientActiveComponents: [
          {}
        ]
      });
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      var popup = controller.doStartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendComponentCommand.calledWith(
        [
          {}
        ],
        Em.I18n.t('hosts.host.maintainance.startAllComponents.context'),
        App.HostComponentStatus.started)
      ).to.be.true;
      controller.sendComponentCommand.restore();
    });
  });

  describe('#doStopAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      controller.reopen({serviceActiveComponents: []});
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('serviceNonClientActiveComponents is empty', function () {
      controller.reopen({
        serviceNonClientActiveComponents: []
      });
      controller.doStopAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });

    it('serviceNonClientActiveComponents is correct', function () {
      controller.reopen({
        serviceNonClientActiveComponents: [
          {}
        ]
      });
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      var popup = controller.doStopAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendComponentCommand.calledWith(
        [
          {}
        ],
        Em.I18n.t('hosts.host.maintainance.stopAllComponents.context'),
        App.HostComponentStatus.stopped)
      ).to.be.true;
      controller.sendComponentCommand.restore();
    });
  });

  describe('#doRestartAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('serviceActiveComponents is empty', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });

    it('serviceActiveComponents is correct', function () {
      controller.reopen({
        serviceActiveComponents: [
          {}
        ]
      });
      sinon.stub(batchUtils, 'restartHostComponents', Em.K);

      var popup = controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith(
        [
          {}
        ])
      ).to.be.true;
      batchUtils.restartHostComponents.restore();

    });
  });

  describe('#getHostComponentsInfo()', function () {

    var result = {
      zkServerInstalled: false,
      lastComponents: [],
      masterComponents: [],
      runningComponents: [],
      nonDeletableComponents: [],
      unknownComponents: []
    };

    it('content.hostComponents is null', function () {
      controller.set('content', {hostComponents: null});
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });
    it('content.hostComponents is empty', function () {
      controller.set('content', {hostComponents: []});
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });
    it('content.hostComponents has ZOOKEEPER_SERVER', function () {
      App.HostComponent.find().clear();
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: 'ZOOKEEPER_SERVER',
        workStatus: 'INIT',
        isDeletable: true
      })]});
      expect(controller.getHostComponentsInfo().zkServerInstalled).to.be.true;
    });
    it('content.hostComponents has last component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: 'TASKTRACKER',
        displayName: 'TaskTracker',
        workStatus: 'INIT',
        isDeletable: true
      })]});
      expect(controller.getHostComponentsInfo().lastComponents).to.eql(['TaskTracker']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has master non-deletable component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'INIT',
        isDeletable: false,
        isMaster: true,
        displayName: 'ZK1'
      })]});
      expect(controller.getHostComponentsInfo().masterComponents).to.eql(['ZK1']);
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has running component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'STARTED',
        isDeletable: true,
        displayName: 'ZK1'
      })]});
      expect(controller.getHostComponentsInfo().runningComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has non-deletable component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'INIT',
        isDeletable: false,
        displayName: 'ZK1'
      })]});
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has component with UNKNOWN state', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {hostComponents: [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'UNKNOWN',
        isDeletable: false,
        displayName: 'ZK1'
      })]});
      expect(controller.getHostComponentsInfo().unknownComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
  });

  describe('#validateAndDeleteHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "getHostComponentsInfo", function () {
        return this.get('mockHostComponentsInfo');
      });
      sinon.stub(controller, "raiseDeleteComponentsError", Em.K);
      sinon.stub(controller, "confirmDeleteHost", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.getHostComponentsInfo.restore();
      controller.raiseDeleteComponentsError.restore();
      controller.confirmDeleteHost.restore();
    });

    it('App.supports.deleteHost = false', function () {
      App.supports.deleteHost = false;
      expect(controller.validateAndDeleteHost()).to.be.false;
      App.supports.deleteHost = true;
    });
    it('masterComponents exist', function () {
      controller.set('mockHostComponentsInfo', {masterComponents: [
        {}
      ]});
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([
        {}
      ], 'masterList')).to.be.true;
    });
    it('nonDeletableComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [
          {}
        ]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([
        {}
      ], 'nonDeletableList')).to.be.true;
    });
    it('runningComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [
          {}
        ]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([
        {}
      ], 'runningList')).to.be.true;
    });
    it('zkServerInstalled = true', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: true
      });
      var popup = controller.validateAndDeleteHost();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.confirmDeleteHost.calledWith([], [])).to.be.true;
    });
    it('zkServerInstalled = false', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: false
      });
      controller.validateAndDeleteHost();
      expect(controller.confirmDeleteHost.calledWith([], [])).to.be.true;
    });
  });

  describe('#raiseDeleteComponentsError()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, "show", Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('Popup should be displayed', function () {
      controller.raiseDeleteComponentsError([], '');
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#confirmDeleteHost()', function () {
    it('Popup should be displayed', function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(controller, 'doDeleteHost');

      var popup = controller.confirmDeleteHost([], []);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.doDeleteHost.calledOnce).to.be.true;
      App.ModalPopup.show.restore();
      controller.doDeleteHost.restore();
    });
  });

  describe('#restartAllStaleConfigComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('popup should be displayed', function () {
      controller.set('content', {componentsWithStaleConfigs: [
        {}
      ]});
      var popup = controller.restartAllStaleConfigComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([
        {}
      ])).to.be.true;
    });
  });

  describe('#moveComponent()', function () {
    it('popup should be displayed', function () {
      var mock = {
        saveComponentToReassign: Em.K,
        getSecurityStatus: Em.K,
        setCurrentStep: Em.K
      };
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(App.router, 'get').withArgs('reassignMasterController').returns(mock);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(mock, "saveComponentToReassign");
      sinon.spy(mock, "getSecurityStatus");
      sinon.spy(mock, "setCurrentStep");

      var popup = controller.moveComponent({context: {}});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.router.get.calledWith('reassignMasterController')).to.be.true;
      expect(mock.saveComponentToReassign.calledWith({})).to.be.true;
      expect(mock.getSecurityStatus.calledOnce).to.be.true;
      expect(mock.setCurrentStep.calledWith('1')).to.be.true;
      expect(App.router.transitionTo.calledWith('reassign')).to.be.true;

      App.showConfirmationPopup.restore();
      App.router.get.restore();
      App.router.transitionTo.restore();
      mock.saveComponentToReassign.restore();
      mock.getSecurityStatus.restore();
      mock.setCurrentStep.restore();

    });
  });

  describe('#refreshConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('No components', function () {
      var event = {context: []};
      controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('No components with stale configs', function () {
      var event = {context: [Em.Object.create({
        staleConfigs: false
      })]};
      controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('Components with stale configs', function () {
      var event = {context: [Em.Object.create({
        staleConfigs: true
      })]};
      var popup = controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([Em.Object.create({
        staleConfigs: true
      })])).to.be.true;
    });
  });

  describe('#getTotalComponent()', function () {

    beforeEach(function () {
      sinon.stub(App.SlaveComponent, 'find', function () {
        return Em.Object.create({
          componentName: "SLAVE",
          totalCount: 1
        });
      });
      sinon.stub(App.ClientComponent, 'find', function () {
        return Em.Object.create({
          componentName: "CLIENT",
          totalCount: 1
        });
      });
      sinon.stub(App.HostComponent, 'find', function () {
        return [Em.Object.create({
          componentName: "MASTER",
          totalCount: 1
        })]
      });
    });
    afterEach(function () {
      App.SlaveComponent.find.restore();
      App.ClientComponent.find.restore();
      App.HostComponent.find.restore();
    });

    it('component is slave', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "SLAVE",
        isSlave: true
      }))).to.equal(1);
    });
    it('component is client', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "CLIENT",
        isClient: true
      }))).to.equal(1);
    });
    it('component is master', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "MASTER"
      }))).to.equal(1);
    });
    it('unknown component', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "UNKNOWN"
      }))).to.equal(0);
    });
  });
  describe('#downloadClientConfigs()', function () {

    beforeEach(function () {
      sinon.stub($, 'fileDownload', function() {
        return {
          fail: function() { return false; }
        }
      });
    });
    afterEach(function () {
      $.fileDownload.restore();
    });

    it('should launch $.fileDownload method', function () {
      controller.downloadClientConfigs({
        context: Em.Object.create({
          componentName: 'name'
        })
      });
      expect($.fileDownload.calledOnce).to.be.true;
    });
  });

  describe('#executeCustomCommands', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.executeCustomCommand({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#_doDeleteHostComponent()', function () {
    it('single component', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({componentName: 'COMP'});
      controller._doDeleteHostComponent(component);
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host_component');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        componentName: 'COMP',
        hostName: 'host1'
      });
    });
    it('all components', function () {
      controller.set('content.hostName', 'host1');
      controller._doDeleteHostComponent(null);
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        componentName: '',
        hostName: 'host1'
      });
    });
  });

  describe('#_doDeleteHostComponentSuccessCallback()', function () {
    it('ZOOKEEPER_SERVER component', function () {
      var data = {
        componentName: 'ZOOKEEPER_SERVER'
      }
      sinon.stub(controller, 'loadConfigs', Em.K);
      controller._doDeleteHostComponentSuccessCallback({}, {}, data);
      expect(controller.get('_deletedHostComponentResult')).to.be.null;
      expect(controller.get('fromDeleteZkServer')).to.be.true;
      expect(controller.loadConfigs.calledOnce).to.be.true;
      controller.loadConfigs.restore();
    });
    it('Not ZOOKEEPER_SERVER component', function () {
      var data = {
        componentName: 'COMP'
      }
      controller.set('fromDeleteZkServer', false);
      controller._doDeleteHostComponentSuccessCallback({}, {}, data);
      expect(controller.get('_deletedHostComponentResult')).to.be.null;
      expect(controller.get('fromDeleteZkServer')).to.be.false;
    });
  });

  describe('#upgradeComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
    });
    afterEach(function () {
      controller.mimicWorkStatusChange.restore();
      controller.showBackgroundOperationsPopup.restore();
    });
    it('testMode is true', function () {
      App.set('testMode', true);

      controller.upgradeComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.calledWith("COMP", App.HostComponentStatus.starting, App.HostComponentStatus.started)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode is false', function () {
      App.set('testMode', false);

      controller.upgradeComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigsSuccessCallback()', function () {
    it('call showBackgroundOperationsPopup', function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      controller.refreshComponentConfigsSuccessCallback();
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
      controller.showBackgroundOperationsPopup.restore();
    });
  });

  describe('#checkZkConfigs()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'removeObserver');
      sinon.stub(controller, 'loadConfigs');
    });
    afterEach(function () {
      controller.loadConfigs.restore();
      controller.removeObserver.restore();
      App.router.get.restore();
    });
    it('No operations of ZOOKEEPER_SERVER', function () {
      sinon.stub(App.router, 'get').withArgs('backgroundOperationsController.services').returns([]);
      controller.checkZkConfigs();
      expect(controller.removeObserver.called).to.be.false;
      expect(controller.loadConfigs.called).to.be.false;
    });
    it('Operation of ZOOKEEPER_SERVER running', function () {
      sinon.stub(App.router, 'get').withArgs('backgroundOperationsController.services').returns([Em.Object.create({
        id: 1,
        isRunning: true
      })]);
      controller.set('zkRequestId', 1);
      controller.checkZkConfigs();
      expect(controller.removeObserver.called).to.be.false;
      expect(controller.loadConfigs.called).to.be.false;
    });
    it('Operation of ZOOKEEPER_SERVER finished', function () {
      sinon.stub(App.router, 'get').withArgs('backgroundOperationsController.services').returns([Em.Object.create({
        id: 1
      })]);
      var clock = sinon.useFakeTimers();
      controller.set('zkRequestId', 1);
      controller.checkZkConfigs();
      expect(controller.removeObserver.calledWith('App.router.backgroundOperationsController.serviceTimestamp', controller, controller.checkZkConfigs)).to.be.true;
      clock.tick(App.get('componentsUpdateInterval'));
      expect(controller.loadConfigs.calledOnce).to.be.true;
      clock.restore();
    });
  });

  describe('#_doDeleteHostComponentErrorCallback()', function () {
    it('call showBackgroundOperationsPopup', function () {
      controller._doDeleteHostComponentErrorCallback({}, 'textStatus', {}, {url: 'url'});
      expect(controller.get('_deletedHostComponentResult')).to.be.eql({xhr: {}, url: 'url', method: 'DELETE'});
    });
  });

  describe('#installComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
    });
    afterEach(function () {
      controller.mimicWorkStatusChange.restore();
      controller.showBackgroundOperationsPopup.restore();
    });
    it('testMode is true', function () {
      App.set('testMode', true);

      controller.installComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.calledWith("COMP", App.HostComponentStatus.installing, App.HostComponentStatus.stopped)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode is false', function () {
      App.set('testMode', false);

      controller.installComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#showHbaseActiveWarning()', function () {
    it('popup should be displayed', function () {
      sinon.spy(App.ModalPopup, "show");
      var popup = controller.showHbaseActiveWarning(Em.Object.create({service: {}}));
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      App.ModalPopup.show.restore();
    });
  });

  describe('#updateHost()', function () {
    it('popup should be displayed', function () {
      sinon.stub(batchUtils, "infoPassiveState", Em.K);
      controller.updateHost({}, {}, {passive_state: 'state'});
      expect(controller.get('content.passiveState')).to.equal('state');
      expect(batchUtils.infoPassiveState.calledWith('state')).to.be.true;
      batchUtils.infoPassiveState.restore();
    });
  });

  describe('#updateComponentPassiveState()', function () {
    it('popup should be displayed', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({
        componentName: 'COMP1'
      });
      controller.updateComponentPassiveState(component, 'state', 'message');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        "hostName": "host1",
        "componentName": "COMP1",
        "component": component,
        "passive_state": "state",
        "context": "message"
      });
    });
  });

  describe('#updateHostComponent()', function () {
    it('popup should be displayed', function () {
      sinon.stub(batchUtils, "infoPassiveState", Em.K);
      var params = {
        component: Em.Object.create(),
        passive_state: 'state'
      }
      controller.updateHostComponent({}, {}, params);
      expect(params.component.get('passiveState')).to.equal('state');
      expect(batchUtils.infoPassiveState.calledWith('state')).to.be.true;
      batchUtils.infoPassiveState.restore();
    });
  });

  describe('#toggleMaintenanceMode()', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'updateComponentPassiveState');
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.updateComponentPassiveState.restore();
    });
    it('passive state is ON', function () {
      var event = {context: Em.Object.create({
        passiveState: 'ON'
      })};
      var popup = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.updateComponentPassiveState.calledWith(Em.Object.create({
        passiveState: 'ON'
      }), 'OFF')).to.be.true;
    });
    it('passive state is OFF', function () {
      var event = {context: Em.Object.create({
        passiveState: 'OFF'
      })};
      var popup = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.updateComponentPassiveState.calledWith(Em.Object.create({
        passiveState: 'OFF'
      }), 'ON')).to.be.true;
    });
  });

  describe('#reinstallClients()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'sendComponentCommand');
    });
    afterEach(function () {
      controller.sendComponentCommand.restore();
    });
    it('No clients to install', function () {
      var event = {context: [
        Em.Object.create({
          workStatus: 'INSTALLED'
        })
      ]};
      controller.reinstallClients(event);
      expect(controller.sendComponentCommand.called).to.be.false;
    });
    it('No clients to install', function () {
      var event = {context: [
        Em.Object.create({
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          workStatus: 'INIT'
        }),
        Em.Object.create({
          workStatus: 'INSTALL_FAILED'
        })
      ]};
      controller.reinstallClients(event);
      expect(controller.sendComponentCommand.calledWith([
        Em.Object.create({
          workStatus: 'INIT'
        }),
        Em.Object.create({
          workStatus: 'INSTALL_FAILED'
        })], Em.I18n.t('host.host.details.installClients'), 'INSTALLED')).to.be.true;
    });
  });

  describe("#executeCustomCommandSuccessCallback()", function () {
    it("BO popup should be shown", function () {
      var mock = {
        showPopup: Em.K
      };
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'showPopup');
      var data = {
        Requests: {
          id: 1
        }
      };
      controller.executeCustomCommandSuccessCallback(data, {}, {});

      expect(App.router.get.calledWith('backgroundOperationsController')).to.be.true;
      expect(mock.showPopup.calledOnce).to.be.true;
      App.router.get.restore();
      mock.showPopup.restore();
    });
  });

  describe("#executeCustomCommandErrorCallback()", function () {
    beforeEach(function () {
      sinon.stub($, 'parseJSON');
      sinon.spy(App, 'showAlertPopup');
    });
    afterEach(function () {
      App.showAlertPopup.restore();
      $.parseJSON.restore();
    });
    it("data empty", function () {
      controller.executeCustomCommandErrorCallback(null);

      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.called).to.be.false;
    });
    it("responseText empty", function () {
      var data = {
        responseText: null
      };
      controller.executeCustomCommandErrorCallback(data);

      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.called).to.be.false;
    });
    it("data empty", function () {
      var data = {
        responseText: "test"
      };
      controller.executeCustomCommandErrorCallback(data);
      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.calledWith('test')).to.be.true;
    });
  });

  describe("#doDeleteHost()", function() {
    beforeEach(function(){
      controller.set('fromDeleteHost', false);
      controller.set('content.hostName', 'host1');
      sinon.stub(controller, '_doDeleteHostComponent', function (comp, callback) {
        callback();
      });
    });
    afterEach(function(){
      controller._doDeleteHostComponent.restore();
    });
    it("Host has no components", function() {
      controller.set('content.hostComponents', Em.A([]));
      controller.doDeleteHost(Em.K);
      expect(controller.get('fromDeleteHost')).to.be.true;
      expect(App.ajax.send.getCall(0).args[0].data.hostName).to.be.equal('host1');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host');
    });
    it("Host has components", function() {
      controller.set('content.hostComponents', Em.A([Em.Object.create({
        componentName: 'COMP1'
      })]));
      controller.doDeleteHost(Em.K);
      expect(controller._doDeleteHostComponent.calledWith(Em.Object.create({
        componentName: 'COMP1'
      }))).to.be.true;
      expect(controller.get('fromDeleteHost')).to.be.true;
      expect(App.ajax.send.getCall(0).args[0].data.hostName).to.be.equal('host1');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host');
    });
  });

  describe("#deleteHostSuccessCallback", function() {
    it("call updateHost", function() {
      var mock = {
        updateHost: function(callback){
          callback();
        },
        getAllHostNames: Em.K
      };
      sinon.stub(App.router, 'get').withArgs('updateController').returns(mock).withArgs('clusterController').returns(mock);
      sinon.spy(mock, 'updateHost');
      sinon.spy(mock, 'getAllHostNames');
      sinon.stub(controller, 'loadConfigs', Em.K);
      sinon.stub(App.router, 'transitionTo', Em.K);

      controller.deleteHostSuccessCallback();
      expect(App.router.get.calledWith('updateController')).to.be.true;
      expect(mock.updateHost.calledOnce).to.be.true;
      expect(controller.loadConfigs.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('hosts.index')).to.be.true;
      expect(App.router.get.calledWith('clusterController')).to.be.true;
      expect(mock.getAllHostNames.calledOnce).to.be.true;

      App.router.get.restore();
      mock.updateHost.restore();
      mock.getAllHostNames.restore();
      controller.loadConfigs.restore();
      App.router.transitionTo.restore();
    });
  });

  describe("#deleteHostErrorCallback", function() {
    it("call defaultErrorHandler", function() {
      sinon.stub(controller, 'loadConfigs', Em.K);
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
      controller.deleteHostErrorCallback({status: 'status', statusText: "statusText"}, 'textStatus', 'errorThrown', {url: 'url'});
      expect(controller.loadConfigs.calledOnce).to.be.true;
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
      App.ajax.defaultErrorHandler.restore();
      controller.loadConfigs.restore();
    });
  });
});

});

;require.register("test/controllers/main/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var validator = require('utils/validator');
require('utils/batch_scheduled_requests');
require('controllers/main/host');
require('mappers/server_data_mapper');

describe('MainHostController', function () {

  var hostController;

  // @todo add unit tests after bulk ops reimplementing
  describe('#bulkOperation', function() {

    beforeEach(function() {
      hostController = App.MainHostController.create({});
      sinon.stub(hostController, 'bulkOperationForHostsRestart', Em.K);
      sinon.stub(hostController, 'bulkOperationForHosts', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsRestart', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsDecommission', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponents', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostsPassiveState', Em.K);
    });

    afterEach(function() {
      hostController.bulkOperationForHosts.restore();
      hostController.bulkOperationForHostsRestart.restore();
      hostController.bulkOperationForHostComponentsRestart.restore();
      hostController.bulkOperationForHostComponentsDecommission.restore();
      hostController.bulkOperationForHostComponents.restore();
      hostController.bulkOperationForHostsPassiveState.restore();

    });

    it('RESTART for hosts', function() {
      var operationData = {
        action: 'RESTART'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsRestart.calledOnce).to.equal(true);
    });

    it('START for hosts', function() {
      var operationData = {
        action: 'STARTED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('STOP for hosts', function() {
      var operationData = {
        action: 'INSTALLED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('PASSIVE_STATE for hosts', function() {
      var operationData = {
        action: 'PASSIVE_STATE'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsPassiveState.calledOnce).to.equal(true);
    });

    it('RESTART for hostComponents', function() {
      var operationData = {
        action: 'RESTART',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsRestart.calledOnce).to.equal(true);
    });

    it('START for hostComponents', function() {
      var operationData = {
        action: 'STARTED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('STOP for hostComponents', function() {
      var operationData = {
        action: 'INSTALLED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('DECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

    it('RECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION_OFF',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

  });

  describe('#getRegExp()', function() {
    before(function() {
      hostController = App.MainHostController.create({});
    });

    var message = '`{0}` should convert to `{1}`',
      tests = [
        { value: '.*', expected: '.*' },
        { value: '.', expected: '.*' },
        { value: '.*.*', expected: '.*' },
        { value: '*', expected: '^$' },
        { value: '........', expected: '.*' },
        { value: '........*', expected: '.*' },
        { value: 'a1', expected: '.*a1.*' },
        { value: 'a1.', expected: '.*a1.*' },
        { value: 'a1...', expected: '.*a1.*' },
        { value: 'a1.*', expected: '.*a1.*' },
        { value: 'a1.*.a2.a3', expected: '.*a1.*.a2.a3.*' },
        { value: 'a1.*.a2...a3', expected: '.*a1.*.a2...a3.*' }
      ]

    tests.forEach(function(test){
      it(message.format(test.value, test.expected), function() {
        expect(hostController.getRegExp(test.value)).to.be.equal(test.expected);
      });
    });
  });

  describe('#warnBeforeDecommissionSuccess()', function () {
    var mock = {
      showHbaseActiveWarning: Em.K,
      checkRegionServerState: Em.K
    };
    beforeEach(function () {
      hostController = App.MainHostController.create({});
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'showHbaseActiveWarning');
      sinon.spy(mock, 'checkRegionServerState');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.showHbaseActiveWarning.restore();
      mock.checkRegionServerState.restore();
    });

    it('items length more than 0', function () {
      hostController.warnBeforeDecommissionSuccess({items: [1]}, {}, {});
      expect(mock.showHbaseActiveWarning.calledOnce).to.be.true;
    });
    it('items length equal 0', function () {
      hostController.warnBeforeDecommissionSuccess({items: []}, {}, {hostNames: 'host1'});
      expect(mock.checkRegionServerState.calledWith('host1')).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/mirroring/edit_dataset_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/mirroring/edit_dataset_controller');
require('models/target_cluster');
require('views/main/mirroring/edit_dataset_view');

describe('App.MainMirroringEditDataSetController', function () {

  describe('#clearStep', function () {
    it('should clear all fields, error flags and messages', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      var formFeilds = mainMirroringEditDataSetController.get('formFields');
      formFeilds.set('datasetName', 'test');
      sinon.spy(mainMirroringEditDataSetController, 'clearErrors');
      mainMirroringEditDataSetController.clearStep();
      expect(mainMirroringEditDataSetController.clearErrors.calledOnce).to.be.true;
      Em.keys(formFeilds).forEach(function (field) {
        expect(formFeilds[field]).to.be.null;
      });
      mainMirroringEditDataSetController.clearErrors.restore();
    });
  });

  describe('#clearErrors', function () {
    it('should clear all error messages and flags', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      Em.keys(errors).forEach(function (error) {
        errors[error] = true;
      }, this);
      Em.keys(errorMessages).forEach(function (errorMessage) {
        errorMessages[errorMessage] = 'test';
      }, this);
      mainMirroringEditDataSetController.clearErrors();
      Em.keys(errors).forEach(function (error) {
        expect(errors[error]).to.be.false;
      });
      Em.keys(errorMessages).forEach(function (errorMessage) {
        expect(errorMessages[errorMessage]).to.be.empty;
      });
    });
  });

  describe('#showAddPopup', function () {
    it('should show popup and set isEdit as false', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      sinon.spy(App.ModalPopup, 'show');
      mainMirroringEditDataSetController.showAddPopup();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.get('isEdit')).to.be.false;
      App.ModalPopup.show.restore();
    });
  });

  describe('#showEditPopup', function () {
    it('should show popup,set isEdit as true and set dataset id', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var dataset = Ember.Object.create({
        id: 'test'
      });
      sinon.spy(App.ModalPopup, 'show');
      mainMirroringEditDataSetController.showEditPopup(dataset);
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      expect(mainMirroringEditDataSetController.get('isEdit')).to.be.true;
      expect(mainMirroringEditDataSetController.get('datasetIdToEdit')).to.equal('test');
      App.ModalPopup.show.restore();
    });
  });

  describe('#showPopup', function () {
    it('should show dataset popup and save its view', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      sinon.spy(App.ModalPopup, 'show');
      mainMirroringEditDataSetController.showPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      expect(mainMirroringEditDataSetController.get('popup')).to.not.be.empty;
      App.ModalPopup.show.restore();
    });
  });

  describe('#applyValidation', function () {
    it('should add observers to all fields to validate form', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      sinon.spy(mainMirroringEditDataSetController, 'validate');
      mainMirroringEditDataSetController.applyValidation();
      expect(mainMirroringEditDataSetController.validate.calledOnce).to.be.true;
      Em.keys(mainMirroringEditDataSetController.get('formFields')).forEach(function (field) {
        expect(mainMirroringEditDataSetController.hasObserverFor('formFields.' + field)).to.be.true;
      });
      mainMirroringEditDataSetController.validate.restore();
    });
  });

  var testCases = [
    {
      day: '01/01/2001',
      hours: '00',
      minutes: '00',
      middayPeriod: 'AM',
      result: new Date('01/01/2001 00:00 AM'),
      message: 'should return date object'
    },
    {
      day: '06/05/2014',
      hours: '12',
      minutes: '59',
      middayPeriod: 'PM',
      result: new Date('06/05/2014 12:59 PM'),
      message: 'should return date object'
    },
    {
      day: '',
      hours: '00',
      minutes: '00',
      middayPeriod: 'AM',
      result: null,
      message: 'should return null if there are empty fields'
    }
  ];

  describe('#scheduleStartDate', function () {
    testCases.forEach(function (test) {
      it(test.message, function () {
        var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
          formFields: Ember.Object.create({
            datasetStartDate: test.day,
            hoursForStart: test.hours,
            minutesForStart: test.minutes,
            middayPeriodForStart: test.middayPeriod
          })
        });
        expect(mainMirroringEditDataSetController.get('scheduleStartDate')).to.deep.equal(test.result);
      });
    });
  });

  describe('#scheduleEndDate', function () {
    testCases.forEach(function (test) {
      it(test.message, function () {
        var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
          formFields: Ember.Object.create({
            datasetEndDate: test.day,
            hoursForEnd: test.hours,
            minutesForEnd: test.minutes,
            middayPeriodForEnd: test.middayPeriod
          })
        });
        expect(mainMirroringEditDataSetController.get('scheduleEndDate')).to.deep.equal(test.result);
      });
    });
  });

  var formFields = Ember.Object.create({
    datasetName: 'test',
    datasetTargetClusterName: 'test',
    datasetSourceDir: '/test',
    datasetTargetDir: '/test',
    datasetStartDate: '01/19/2038',
    hoursForStart: '03',
    minutesForStart: '15',
    middayPeriodForStart: 'AM',
    datasetEndDate: '01/19/2039',
    hoursForEnd: '03',
    minutesForEnd: '15',
    middayPeriodForEnd: 'AM',
    datasetFrequency: '1',
    repeatOptionSelected: 'days'
  })

  describe('#validate', function () {
    it('should set an error for empty fields', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      mainMirroringEditDataSetController.validate();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      Em.keys(errors).forEach(function (error) {
        expect(errors[error]).to.be.true;
      });
      Em.keys(errorMessages).forEach(function (errorMessage) {
        expect(errorMessages[errorMessage]).to.equal(Em.I18n.t('mirroring.required.error'));
      });
    });
    it('should set an error if start date is after end date', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var formFields = mainMirroringEditDataSetController.get('formFields');
      formFields.set('datasetStartDate', '04/07/2014');
      formFields.set('hoursForStart', '11');
      formFields.set('minutesForStart', '00');
      formFields.set('middayPeriodForStart', 'PM');
      formFields.set('datasetEndDate', '04/07/2014');
      formFields.set('hoursForEnd', '11');
      formFields.set('minutesForEnd', '00');
      formFields.set('middayPeriodForEnd', 'AM');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isEndDateError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.endDate')).to.equal(Em.I18n.t('mirroring.dateOrder.error'));
    });
    it('should set an error if start date is in the past', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var formFields = mainMirroringEditDataSetController.get('formFields');
      formFields.set('datasetStartDate', '04/07/2014');
      formFields.set('hoursForStart', '11');
      formFields.set('minutesForStart', '00');
      formFields.set('middayPeriodForStart', 'AM');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isStartDateError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.startDate')).to.equal(Em.I18n.t('mirroring.startDate.error'));
    });
    it('should set an error if repeat field value consist not only form digits', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var formFields = mainMirroringEditDataSetController.get('formFields');
      formFields.set('datasetFrequency', 'test');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isFrequencyError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.frequency')).to.equal(Em.I18n.t('mirroring.required.invalidNumberError'));
      formFields.set('datasetFrequency', '100test');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isFrequencyError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.frequency')).to.equal(Em.I18n.t('mirroring.required.invalidNumberError'));
    });
    it('should not set errors if all fields are filled correctly', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        formFields: formFields
      });
      mainMirroringEditDataSetController.validate();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      Em.keys(errors).forEach(function (error) {
        expect(errors[error]).to.be.false;
      });
      Em.keys(errorMessages).forEach(function (errorMessage) {
        expect(errorMessages[errorMessage]).to.be.empty;
      });
    });
  });

  describe('#addZero', function () {
    it('should add 0 for numbers less than 10', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.addZero(1)).to.equal('01');
      expect(mainMirroringEditDataSetController.addZero(9)).to.equal('09');
      expect(mainMirroringEditDataSetController.addZero(0)).to.equal('00');
    });
    it('should not add 0 for numbers greater than 9', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.addZero(10)).to.equal('10');
      expect(mainMirroringEditDataSetController.addZero(99)).to.equal('99');
    });
  });

  describe('#toTZFormat', function () {
    it('should convert date to TZ format', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.toTZFormat(new Date(Date.UTC(2014, 0, 1, 1, 1)))).to.equal('2014-01-01T01:01Z');
      expect(mainMirroringEditDataSetController.toTZFormat(new Date(Date.UTC(2014, 11, 31, 23, 59)))).to.equal('2014-12-31T23:59Z');
    });
  });

  describe('#toAMPMHours', function () {
    it('should convert time to 12-hours format', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.toAMPMHours(13)).to.equal('01');
      expect(mainMirroringEditDataSetController.toAMPMHours(20)).to.equal('08');
      expect(mainMirroringEditDataSetController.toAMPMHours(24)).to.equal('12');
      expect(mainMirroringEditDataSetController.toAMPMHours(0)).to.equal('12');
    });
    it('should not convert time if argument is less than 12', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.toAMPMHours(1)).to.equal('01');
      expect(mainMirroringEditDataSetController.toAMPMHours(8)).to.equal('08');
      expect(mainMirroringEditDataSetController.toAMPMHours(11)).to.equal('11');
    });
  });

  describe('#save', function () {
    it('should create XML and send it to server', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        popup: Ember.Object.create({
          isSaving: false
        })
      });
      sinon.spy(mainMirroringEditDataSetController, 'createDatasetXML');
      sinon.spy(mainMirroringEditDataSetController, 'sendDatasetToServer');
      mainMirroringEditDataSetController.save();
      expect(mainMirroringEditDataSetController.createDatasetXML.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.sendDatasetToServer.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.true;
      mainMirroringEditDataSetController.createDatasetXML.restore();
      mainMirroringEditDataSetController.sendDatasetToServer.restore();
    });
  });

  describe('#createDatasetXML', function () {
    it('should create XML-fromatted data', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        formFields: formFields
      });
      var startDate = new Date('01/19/2038 03:15 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '');
      var endDate = new Date('01/19/2039 03:15 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '');
      var expectedResult = '<?xml version="1.0"?><feed description="" name="' + App.mirroringDatasetNamePrefix + 'test" xmlns="uri:falcon:feed:0.1"><frequency>days(1)' +
        '</frequency><clusters><cluster name="' + App.get('clusterName') + '" type="source"><validity start="' + startDate + '" end="' + endDate +
        '"/><retention limit="days(7)" action="delete"/></cluster><cluster name="test" type="target"><validity start="' + startDate + '" end="' + endDate +
        '"/><retention limit="months(1)" action="delete"/><locations><location type="data" path="/test" /></locations></cluster></clusters><locations><location type="data" path="' +
        '/test" /></locations><ACL owner="hue" group="users" permission="0755" /><schema location="/none" provider="none"/></feed>';
      var result = mainMirroringEditDataSetController.createDatasetXML();
      expect(result).to.equal(expectedResult);
    });
  });

  describe('#sendDatasetToServer', function () {
    var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
      formFields: formFields
    });
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it('should send data with correct dataset name', function () {
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].data.name).to.equal(App.mirroringDatasetNamePrefix + formFields.datasetName);
    });
    it('should send data from param', function () {
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].data.entity).to.equal('test');
    });
    it('should use edit request if isEdit is true', function () {
      mainMirroringEditDataSetController.set('isEdit', true);
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].name).to.equal('mirroring.update_entity');
    });
    it('should use create request if isEdit is false', function () {
      mainMirroringEditDataSetController.set('isEdit', false);
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].name).to.equal('mirroring.create_new_dataset');
    });
  });

  describe('#onSaveSuccess', function () {
    it('should hide popup and load data', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        popup: Ember.Object.create({
          isSaving: true,
          hide: function () {
          }
        })
      });
      App.router.set('mainMirroringController', Ember.Object.create({
        loadData: function () {
        }
      }));
      sinon.spy(mainMirroringEditDataSetController.get('popup'), 'hide');
      sinon.spy(App.router.get('mainMirroringController'), 'loadData');
      mainMirroringEditDataSetController.onSaveSuccess();
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.false;
      expect(App.router.get('mainMirroringController').loadData.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.get('popup').hide.calledOnce).to.be.true;
      mainMirroringEditDataSetController.get('popup').hide.restore();
      App.router.get('mainMirroringController').loadData.restore();
    });
  });

  describe('#onSaveError', function () {
    var mainMirroringEditDataSetController;
    beforeEach(function () {
      mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        popup: Ember.Object.create({
          isSaving: true
        })
      });
      sinon.stub(App, 'showAlertPopup', Em.K);
    });
    afterEach(function () {
      App.showAlertPopup.restore();
    });
    it('shouldn\'t show error popup and enable button', function () {
      mainMirroringEditDataSetController.onSaveError(null);
      expect(App.showAlertPopup.calledOnce).to.be.false;
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.false;
    });
    it('should show error popup and enable button', function () {
      mainMirroringEditDataSetController.onSaveError({responseText: '<message>test</message>'});
      expect(App.showAlertPopup.args[0][1]).to.be.equal(Em.I18n.t('mirroring.manageClusters.error') + ': test');
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.false;
    });
  });

  describe('#saveDisabled', function () {
    it('should return true if there are some errors', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      mainMirroringEditDataSetController.set('errors.isNameError', true);
      expect(mainMirroringEditDataSetController.get('saveDisabled')).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/service/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/wizard');
require('controllers/main/service/add_controller');
var addServiceController = null;

describe('App.AddServiceController', function() {

  beforeEach(function () {
    addServiceController = App.AddServiceController.create({});
  });

  describe('#installAdditionalClients', function() {

    var t = {
      additionalClients: {
        componentName: "TEZ_CLIENT",
        hostNames: ["hostName1", "hostName2"]
      },
      additionalClientsWithoutHosts: {
        componentName: "TEZ_CLIENT",
        hostNames: []
      },
      RequestInfo: {
        "context": Em.I18n.t('requestInfo.installHostComponent') + ' ' + App.format.role("TEZ_CLIENT"),
        "query": "HostRoles/component_name=TEZ_CLIENT&HostRoles/host_name.in(hostName1,hostName2)"
      },
      Body: {
        HostRoles: {
          state: 'INSTALLED'
        }
      }
    };

    beforeEach(function () {
      sinon.spy($, 'ajax');
      sinon.stub(App, 'get', function(k) {
        if ('clusterName' === k) return 'tdk';
        return Em.get(App, k);
      });
    });

    afterEach(function () {
      $.ajax.restore();
      App.get.restore();
    });

    it('send request to install client', function () {
      addServiceController.set("content.additionalClients", [t.additionalClients]);
      addServiceController.installAdditionalClients();
      expect($.ajax.calledOnce).to.equal(true);

      expect(JSON.parse($.ajax.args[0][0].data).Body).to.deep.eql(t.Body);
      expect(JSON.parse($.ajax.args[0][0].data).RequestInfo).to.eql(t.RequestInfo);
    });

    it('should not send request to install client', function () {
      addServiceController.set("content.additionalClients", [t.additionalClientsWithoutHosts]);
      expect($.ajax.called).to.be.false;
    });

  });

  describe('#generateDataForInstallServices', function() {
    var tests = [{
      selected: ["YARN","HBASE"],
      res: {
        "context": Em.I18n.t('requestInfo.installServices'),
        "ServiceInfo": {"state": "INSTALLED"},
        "urlParams": "ServiceInfo/service_name.in(YARN,HBASE)"
      }
    },
    {
      selected: ['OOZIE'],
      res: {
        "context": Em.I18n.t('requestInfo.installServices'),
        "ServiceInfo": {"state": "INSTALLED"},
        "urlParams": "ServiceInfo/service_name.in(OOZIE,HDFS,YARN,MAPREDUCE,MAPREDUCE2)"
      }
    }
    ]
    tests.forEach(function(t){
      it('should generate data with ' + t.selected.join(","), function () {
        expect(addServiceController.generateDataForInstallServices(t.selected)).to.be.eql(t.res);
      });
    });


  });
});

});

;require.register("test/controllers/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/info/configs');
var batchUtils = require('utils/batch_scheduled_requests');
var mainServiceInfoConfigsController = null;
describe("App.MainServiceInfoConfigsController", function () {

  beforeEach(function () {
    mainServiceInfoConfigsController = App.MainServiceInfoConfigsController.create({});
  });

  describe("#showSavePopup", function () {
    var tests = [
      {
        path: false,
        callback: null,
        action: "onSave",
        m: "save configs without path/callback",
        results: [
          {
            method: "restartServicePopup",
            called: true
          }
        ]
      },
      {
        path: true,
        callback: true,
        action: "onSave",
        m: "save configs with path/callback",
        results: [
          {
            method: "restartServicePopup",
            called: true
          }
        ]
      },
      {
        path: false,
        callback: false,
        action: "onDiscard",
        m: "discard changes without path/callback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          }
        ]
      },
      {
        path: false,
        callback: true,
        action: "onDiscard",
        m: "discard changes with callback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "callback",
            called: true
          },
          {
            field: "hash",
            value: "hash"
          }
        ]
      },
      {
        path: true,
        callback: null,
        action: "onDiscard",
        m: "discard changes with path",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            field: "forceTransition",
            value: true
          }
        ]
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "restartServicePopup", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
      App.router.route = Em.K;
    });
    afterEach(function () {
      mainServiceInfoConfigsController.restartServicePopup.restore();
      mainServiceInfoConfigsController.getHash.restore();
    });

    tests.forEach(function (t) {
      t.results.forEach(function (r) {
        it(t.m + " " + r.method + " " + r.field, function () {
          if (t.callback) {
            t.callback = sinon.stub();
          }
          mainServiceInfoConfigsController.showSavePopup(t.path, t.callback)[t.action]();
          if (r.method) {
            if (r.method === 'callback') {
              expect(t.callback.calledOnce).to.equal(r.called);
            } else {
              expect(mainServiceInfoConfigsController[r.method].calledOnce).to.equal(r.called);
            }
          } else if (r.field) {
            expect(mainServiceInfoConfigsController.get(r.field)).to.equal(r.value);
          }
        }, this);
      });
    }, this);
  });

  describe("#hasUnsavedChanges", function () {
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
    });
    afterEach(function () {
      mainServiceInfoConfigsController.getHash.restore();
    });

    it("with unsaved", function () {
      mainServiceInfoConfigsController.set("hash", "hash1");
      expect(mainServiceInfoConfigsController.hasUnsavedChanges()).to.equal(true);
    });

    it("without unsaved", function () {
      mainServiceInfoConfigsController.set("hash", "hash");
      expect(mainServiceInfoConfigsController.hasUnsavedChanges()).to.equal(false);
    });
  });

  describe("#manageConfigurationGroup", function () {
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "manageConfigurationGroups", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.manageConfigurationGroups.restore();
    });
    it("run manageConfigurationGroups", function () {
      mainServiceInfoConfigsController.manageConfigurationGroup();
      expect(mainServiceInfoConfigsController.manageConfigurationGroups.calledOnce).to.equal(true);
    });
  });

  describe("#addOverrideProperty", function () {
    var serviceConfigProperty = Em.Object.create({
      overrides: []
    });

    var newSCP = App.ServiceConfigProperty.create(serviceConfigProperty);
    newSCP.set('value', '');
    newSCP.set('isOriginalSCP', false);
    newSCP.set('parentSCP', serviceConfigProperty);
    newSCP.set('isEditable', true);

    it("add new overridden property", function () {
      mainServiceInfoConfigsController.addOverrideProperty(serviceConfigProperty);
      expect(serviceConfigProperty.get("overrides")[0]).to.eql(newSCP);
    });
  });

  describe("#showComponentsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          'publicHostName1': ['TaskTracker'],
          'publicHostName2': ['JobTracker', 'TaskTracker']
        },
        components: "2 TaskTrackers, 1 JobTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.components'))
      },
      {
        input: {
          'publicHostName1': ['TaskTracker']
        },
        components: "1 TaskTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.component'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
      mainServiceInfoConfigsController.set("content", {restartRequiredHostsAndComponents: ""});
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
      mainServiceInfoConfigsController.set("content", undefined);
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with components", function () {
        mainServiceInfoConfigsController.set("content.restartRequiredHostsAndComponents", t.input);
        mainServiceInfoConfigsController.showComponentsShouldBeRestarted();
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.components, t.text)).to.equal(true);
      });
    });
  });

  describe("#showHostsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          'publicHostName1': ['TaskTracker'],
          'publicHostName2': ['JobTracker', 'TaskTracker']
        },
        hosts: "publicHostName1, publicHostName2",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.hosts'))
      },
      {
        input: {
          'publicHostName1': ['TaskTracker']
        },
        hosts: "publicHostName1",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.host'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
      mainServiceInfoConfigsController.set("content", {restartRequiredHostsAndComponents: ""});
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
      mainServiceInfoConfigsController.set("content", undefined);
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with hosts", function () {
        mainServiceInfoConfigsController.set("content.restartRequiredHostsAndComponents", t.input);
        mainServiceInfoConfigsController.showHostsShouldBeRestarted();
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.hosts, t.text)).to.equal(true);
      });
    });
  });

  describe("#rollingRestartStaleConfigSlaveComponents", function () {
    var tests = [
      {
        componentName: {
          context: "ComponentName"
        },
        displayName: "displayName",
        passiveState: "ON"
      },
      {
        componentName: {
          context: "ComponentName1"
        },
        displayName: "displayName1",
        passiveState: "OFF"
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", {displayName: "", passiveState: ""});
      sinon.stub(batchUtils, "launchHostComponentRollingRestart", Em.K);
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
    });
    tests.forEach(function (t) {
      it("trigger rollingRestartStaleConfigSlaveComponents", function () {
        mainServiceInfoConfigsController.set("content.displayName", t.displayName);
        mainServiceInfoConfigsController.set("content.passiveState", t.passiveState);
        mainServiceInfoConfigsController.rollingRestartStaleConfigSlaveComponents(t.componentName);
        expect(batchUtils.launchHostComponentRollingRestart.calledWith(t.componentName.context, t.displayName, t.passiveState == "ON", true)).to.equal(true);
      });
    });
  });

  describe("#restartAllStaleConfigComponents", function () {
    beforeEach(function () {
      sinon.stub(batchUtils, "restartAllServiceHostComponents", Em.K);
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
    });
    it("trigger restartAllServiceHostComponents", function () {
      mainServiceInfoConfigsController.restartAllStaleConfigComponents().onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });
  });

  describe("#doCancel", function () {
    beforeEach(function () {
      sinon.stub(Em.run, 'once', Em.K);
    });
    afterEach(function () {
      Em.run.once.restore();
    });
    it("trigger onConfigGroupChange", function () {
      mainServiceInfoConfigsController.doCancel();
      expect(Em.run.once.calledWith(mainServiceInfoConfigsController, "onConfigGroupChange")).to.equal(true);
    });
  });

  describe("#getCurrentServiceComponents", function () {
    var t = Em.Object.create({
      content: Em.Object.create({
        hostComponents: [
          Em.Object.create({
            componentName: "componentName1",
            displayName: "displayName1"
          }),
          Em.Object.create({
            componentName: "componentName2",
            displayName: "displayName2"
          })
        ]
      }),
      validComponents: Em.A([
        Em.Object.create({
          componentName: "componentName1",
          displayName: "displayName1",
          selected: false
        }),
        Em.Object.create({
          componentName: "componentName2",
          displayName: "displayName2",
          selected: false
        })
      ])
    });

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", { hostComponents: Em.A([])});
    });

    it("get current service components", function () {
      mainServiceInfoConfigsController.get("content.hostComponents").push(t.content.hostComponents[0]);
      var com = mainServiceInfoConfigsController.get("getCurrentServiceComponents");
      expect(com[0]).to.eql(t.validComponents[0]);
    });
  });

  describe("#getMasterComponentHostValue", function () {
    var tests = [
      {
        content: {
          hostComponents: [
            Em.Object.create({
              componentName: "componentName1",
              hostName: "hostName"
            })
          ]
        },
        result: "hostName",
        multiple: false,
        m: "returns hostname"
      },
      {
        content: {
          hostComponents: [
            Em.Object.create({
              componentName: "componentName2",
              hostName: "hostName1"
            }),
            Em.Object.create({
              componentName: "componentName2",
              hostName: "hostName2"
            })
          ]
        },
        result: ["hostName1","hostName2"],
        multiple: true,
        m: "returns hostnames"
      }
    ];
    tests.forEach(function(t){
      beforeEach(function () {
        mainServiceInfoConfigsController.set("content", { hostComponents: []});
      });

      it(t.m, function () {
        mainServiceInfoConfigsController.set("content.hostComponents", t.content.hostComponents);
        expect(mainServiceInfoConfigsController.getMasterComponentHostValue(t.content.hostComponents[0].componentName, t.multiple)).to.eql(t.result);
      });
    });
  });

  describe("#setServerConfigValue", function () {

    it("parsing storm.zookeeper.servers property in non standart method", function () {
      expect(mainServiceInfoConfigsController.setServerConfigValue("storm.zookeeper.servers", ["a", "b"])).to.equal('[\'a\',\'b\']');
    });
    it("parsing default properties", function () {
      expect(mainServiceInfoConfigsController.setServerConfigValue("any.other.property", "value")).to.equal("value");
    });
  });

  describe("#createSiteObj", function () {

    var tests = [
      {
        siteName: "hdfs-site",
        tagName: "version1",
        siteObj: Em.A([
          {
            name: "property1",
            value: "value1"
          },
          {
            name: "property2",
            value: "value2&lt;"
          },
          {
            name: "property_heapsize",
            value: "value3"
          },
          {
            name: "property_permsize",
            value: "value4m"
          }
        ]),
        result: {
          "type": "hdfs-site",
          "tag": "version1",
          "properties": {
            "property1": "value1",
            "property2": "value2&lt;",
            "property_heapsize": "value3m",
            "property_permsize": "value4m"
          }
        },
        m: "default"
      },
      {
        siteName: "falcon-startup.properties",
        tagName: "version1",
        siteObj: Em.A([
          {
            name: "property1",
            value: "value1"
          },
          {
            name: "property2",
            value: "value2&lt;"
          }
        ]),
        result: {
          "type": "falcon-startup.properties",
          "tag": "version1",
          "properties": {
            "property1": "value1",
            "property2": "value2&lt;"
          }
        },
        m: "for falcon-startup.properties"

      }
    ];
    tests.forEach(function (t) {
      it("create site object " + t.m, function () {
        expect(mainServiceInfoConfigsController.createSiteObj(t.siteName, t.tagName, t.siteObj)).to.deep.eql(t.result)
      });
    });
  });

  describe("#createCoreSiteObj", function () {

    var tests = [
      {
        tagName: "version1",
        uiConfigs: Em.A([
          Em.Object.create({
            name: "property1",
            value: "value1",
            filename: "core-site.xml"
          }),
          Em.Object.create({
            name: "property2",
            value: "value2&lt;",
            filename: "core-site.xml"
          })
        ]),
        result: {
          "type": "core-site",
          "tag": "version1",
          "properties": {
            "property1": "value1",
            "property2": "value2&lt;"
          }
        }
      }
    ];
    tests.forEach(function (t) {
      it("create core object", function () {
        mainServiceInfoConfigsController.set("uiConfigs", t.uiConfigs);
        expect(mainServiceInfoConfigsController.createCoreSiteObj(t.tagName)).to.deep.eql(t.result);
      });
    });
  });

  describe("#doPUTClusterConfigurationSites", function () {
      var sc = [
      Em.Object.create({
        configs: [
          Em.Object.create({
            name: '_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: '_newsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: '_maxnewsize',
            value: '1024m'
          })
        ]
      })
    ],
    scExc = [
      Em.Object.create({
        configs: [
          Em.Object.create({
            name: 'hadoop_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'yarn_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'nodemanager_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'resourcemanager_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'apptimelineserver_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'jobhistory_heapsize',
            value: '1024m'
          })
        ]
      })
    ];
    beforeEach(function () {
      sinon.stub(App.router, 'getClusterName', function() {
        return 'clName';
      });
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
      App.router.getClusterName.restore();
    });
    it("ajax request to put clsuter cfg", function () {
      mainServiceInfoConfigsController.set('stepConfigs', sc);
      expect(mainServiceInfoConfigsController.doPUTClusterConfigurationSites([])).to.equal(mainServiceInfoConfigsController.get("doPUTClusterConfigurationSiteResult"));
      expect(App.ajax.send.calledOnce).to.be.true;
    });
    it('values should be parsed', function () {
      mainServiceInfoConfigsController.set('stepConfigs', sc);
      mainServiceInfoConfigsController.doPUTClusterConfigurationSites([]);
      expect(mainServiceInfoConfigsController.get('stepConfigs')[0].get('configs').mapProperty('value').uniq()).to.eql(['1024m']);
    });
    it('values should not be parsed', function () {
      mainServiceInfoConfigsController.set('stepConfigs', scExc);
      mainServiceInfoConfigsController.doPUTClusterConfigurationSites([]);
      expect(mainServiceInfoConfigsController.get('stepConfigs')[0].get('configs').mapProperty('value').uniq()).to.eql(['1024m']);
    });
  });

  describe("#isConfigChanged", function () {

    var tests = [
      {
        loadedConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "true"
        },
        savingConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "true"
        },
        m: "configs doesn't changed",
        res: false
      },
      {
        loadedConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "true"
        },
        savingConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "false"
        },
        m: "configs changed",
        res: true
      },
      {
        loadedConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase"
        },
        savingConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "false"
        },
        m: "add new config",
        res: true
      }
    ];

    tests.forEach(function(t){
      it(t.m, function () {
        expect(mainServiceInfoConfigsController.isConfigChanged(t.loadedConfig, t.savingConfig)).to.equal(t.res);
      });
    });
  });

  describe("#addDynamicProperties", function() {

    var tests = [
      {
        stepConfigs: [Em.Object.create({
          serviceName: "HIVE",
          configs: []
        })],
        content: Em.Object.create({
          serviceName: "HIVE"
        }),
        m: "add dynamic property",
        addDynamic: true
      },
      {
        stepConfigs: [Em.Object.create({
          serviceName: "HIVE",
          configs: [
            Em.Object.create({
              name: "templeton.hive.properties"
            })
          ]
        })],
        content: Em.Object.create({
          serviceName: "HIVE"
        }),
        m: "don't add dynamic property (already included)",
        addDynamic: false
      },
      {
        stepConfigs: [Em.Object.create({
          serviceName: "HDFS",
          configs: []
        })],
        content: Em.Object.create({
          serviceName: "HDFS"
        }),
        m: "don't add dynamic property (wrong service)",
        addDynamic: false
      }
    ];
    var dynamicProperty = {
      "name": "templeton.hive.properties",
      "templateName": ["hivemetastore_host"],
      "foreignKey": null,
      "value": "hive.metastore.local=false,hive.metastore.uris=thrift://<templateName[0]>:9083,hive.metastore.sasl.enabled=yes,hive.metastore.execute.setugi=true,hive.metastore.warehouse.dir=/apps/hive/warehouse",
      "filename": "webhcat-site.xml"
    };



    tests.forEach(function(t) {
      it(t.m, function() {
        mainServiceInfoConfigsController.set("content", t.content);
        mainServiceInfoConfigsController.set("stepConfigs", t.stepConfigs);
        var configs = [];
        mainServiceInfoConfigsController.addDynamicProperties(configs);
        if (t.addDynamic){
          expect(configs.findProperty("name","templeton.hive.properties")).to.deep.eql(dynamicProperty);
        }
      });
    });
  });

  describe("#loadUiSideConfigs", function () {

    var t = {
      configMapping: [
        {
          foreignKey: null,
          templateName: "",
          value: "default",
          name: "name1",
          filename: "filename1"
        },
        {
          foreignKey: "notNull",
          templateName: "",
          value: "default2",
          name: "name2",
          filename: "filename2"
        }
      ],
      configMappingf: [
        {
          foreignKey: null,
          templateName: "",
          value: "default",
          name: "name1",
          filename: "filename1"
        }
      ],
      valueWithOverrides: {
        "value": "default",
        "overrides": {
          "value1": "value1",
          "value2": "value2"
        }
      },
      uiConfigs: [
        {
          "id": "site property",
          "name": "name1",
          "value": "default",
          "filename": "filename1",
          "overrides": {
            "value1": "value1",
            "value2": "value2"
          }
        }
      ]
    };

    beforeEach(function(){
      sinon.stub(mainServiceInfoConfigsController, "addDynamicProperties", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getGlobConfigValueWithOverrides", function () {
        return t.valueWithOverrides
      });
    });

    afterEach(function(){
      mainServiceInfoConfigsController.addDynamicProperties.restore();
      mainServiceInfoConfigsController.getGlobConfigValueWithOverrides.restore();
    });

    it("load ui config", function() {
      expect(mainServiceInfoConfigsController.loadUiSideConfigs(t.configMapping)[0]).to.deep.equal(t.uiConfigs[0]);
      expect(mainServiceInfoConfigsController.addDynamicProperties.calledWith(t.configMappingf)).to.equal(true);
    });
  });

  describe("#formatConfigValues", function () {
    var t = {
      configs: [
        Em.Object.create({ name: "p1", value: " v1 v1 ", displayType: "" }),
        Em.Object.create({ name: "p2", value: true, displayType: "" }),
        Em.Object.create({ name: "p3", value: " d1 ", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: " d1 d2 d3 ", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: " v ", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1 ", displayType: "advanced" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1 ", displayType: "advanced" })
      ],
      result: [
        Em.Object.create({ name: "p1", value: " v1 v1", displayType: "" }),
        Em.Object.create({ name: "p2", value: "true", displayType: "" }),
        Em.Object.create({ name: "p3", value: "d1", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: "d1,d2,d3", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: "v", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1", displayType: "advanced" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1", displayType: "advanced" })
      ]
    };

    it("format config values", function () {
      mainServiceInfoConfigsController.formatConfigValues(t.configs);
      expect(t.configs).to.deep.equal(t.result);
    });

  });

  describe("#createConfigObject", function() {
    var tests = [
      {
        siteName: "core-site",
        serviceName: "HDFS",
        method: "createCoreSiteObj"
      },
      {
        siteName: "core-site",
        serviceName: "ANY",
        method: false
      },
      {
        siteName: "any",
        method: "createSiteObj"
      },
      {
        siteName: "mapred-queue-acls",
        method: false,
        capacitySchedulerUi: false
      },
      {
        siteName: "mapred-queue-acls",
        method: "createSiteObj",
        capacitySchedulerUi: true
      }
    ];

    var capacitySchedulerUi = App.supports.capacitySchedulerUi;
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "createCoreSiteObj", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "createSiteObj", Em.K);
      mainServiceInfoConfigsController.set("content", {});
    });

    afterEach(function() {
      mainServiceInfoConfigsController.createCoreSiteObj.restore();
      mainServiceInfoConfigsController.createSiteObj.restore();
      App.supports.capacitySchedulerUi = capacitySchedulerUi;
    });

    tests.forEach(function(t) {
      it("create object for " + t.siteName + " run method " + t.method, function() {
        App.supports.capacitySchedulerUi = t.capacitySchedulerUi;
        mainServiceInfoConfigsController.set("content.serviceName", t.serviceName);
        mainServiceInfoConfigsController.createConfigObject(t.siteName, "versrion1");
        if (t.method) {
          expect(mainServiceInfoConfigsController[t.method].calledOnce).to.equal(true);
        } else {
          expect(mainServiceInfoConfigsController["createCoreSiteObj"].calledOnce).to.equal(false);
          expect(mainServiceInfoConfigsController["createSiteObj"].calledOnce).to.equal(false);
        }
      });
    });
  });

  describe("#putConfigGroupChanges", function() {

    var t = {
      data: {
        ConfigGroup: {
          id: "id"
        }
      },
      request: [{
        ConfigGroup: {
          id: "id"
        }
      }]
    };

    beforeEach(function() {
      sinon.spy($,"ajax");
    });
    afterEach(function() {
      $.ajax.restore();
    });

    it("updates configs groups", function() {
      mainServiceInfoConfigsController.putConfigGroupChanges(t.data);
      expect(JSON.parse($.ajax.args[0][0].data)).to.deep.equal(t.request);
    });
  });

  describe("#setValueForCheckBox", function() {
    var tests = [
      {
        serviceConfigPropertyInput: Em.Object.create({
          value: "true",
          defaultValue: "true",
          displayType: 'checkbox'
        }),
        serviceConfigProperty: Em.Object.create({
          value: true,
          defaultValue: true,
          displayType: 'checkbox'
        })
      },
      {
        serviceConfigPropertyInput: Em.Object.create({
          value: "false",
          defaultValue: "false",
          displayType: 'checkbox'
        }),
        serviceConfigProperty: Em.Object.create({
          value: false,
          defaultValue: false,
          displayType: 'checkbox'
        })
      },
      {
        serviceConfigPropertyInput: Em.Object.create({
          value: "false",
          defaultValue: "false"
        }),
        serviceConfigProperty: Em.Object.create({
          value: "false",
          defaultValue: "false"
        })
      }
    ];
    tests.forEach(function(t) {
      it("set " + t.serviceConfigPropertyInput.value, function(){
        var serviceConfigProperty = t.serviceConfigPropertyInput;
        mainServiceInfoConfigsController.setValueForCheckBox(serviceConfigProperty);
        expect(serviceConfigProperty).to.eql(t.serviceConfigProperty);
      });
    });
  });

  describe("#setEditability", function () {

    var tests = [
      {
        isAdmin: true,
        isHostsConfigsPage: false,
        defaultGroupSelected: true,
        isReconfigurable: true,
        isEditable: true,
        m: ""
      },
      {
        isAdmin: false,
        isHostsConfigsPage: false,
        defaultGroupSelected: true,
        isReconfigurable: true,
        isEditable: false,
        m: "(non admin)"
      },
      {
        isAdmin: true,
        isHostsConfigsPage: true,
        defaultGroupSelected: true,
        isReconfigurable: true,
        isEditable: false,
        m: "(isHostsConfigsPage)"
      },
      {
        isAdmin: true,
        isHostsConfigsPage: false,
        defaultGroupSelected: false,
        isReconfigurable: true,
        isEditable: false,
        m: "(defaultGroupSelected is false)"
      },
      {
        isAdmin: true,
        isHostsConfigsPage: false,
        defaultGroupSelected: true,
        isReconfigurable: false,
        isEditable: false,
        m: "(isReconfigurable is false)"
      }
    ];

    var a = App.get('isAdmin');
    afterEach(function () {
      App.set('isAdmin', a);
    });
    tests.forEach(function(t) {
      it("set isEditable " + t.isEditable + t.m, function(){
        App.set('isAdmin', t.isAdmin);
        mainServiceInfoConfigsController.set("isHostsConfigsPage", t.isHostsConfigsPage);
        var serviceConfigProperty = Em.Object.create({
          isReconfigurable: t.isReconfigurable
        });
        mainServiceInfoConfigsController.setEditability(serviceConfigProperty, t.defaultGroupSelected);
        expect(serviceConfigProperty.get("isEditable")).to.equal(t.isEditable);
      });
    });
  });

  describe("#checkOverrideProperty", function () {
    var tests = [{
      overrideToAdd: {
        name: "name1",
        filename: "filename1"
      },
      componentConfig: {
        configs: [
          {
            name: "name1",
            filename: "filename2"
          },
          {
            name: "name1",
            filename: "filename1"
          }
        ]
      },
      add: true,
      m: "add property"
    },
      {
        overrideToAdd: {
          name: "name1"
        },
        componentConfig: {
          configs: [
            {
              name: "name2"
            }
          ]
        },
        add: false,
        m: "don't add property, different names"
      },
      {
        overrideToAdd: {
          name: "name1",
          filename: "filename1"
        },
        componentConfig: {
          configs: [
            {
              name: "name1",
              filename: "filename2"
            }
          ]
        },
        add: false,
        m: "don't add property, different filenames"
      },
      {
        overrideToAdd: null,
        componentConfig: {},
        add: false,
        m: "don't add property, overrideToAdd is null"
      }];

    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController,"addOverrideProperty", Em.K)
    });
    afterEach(function() {
      mainServiceInfoConfigsController.addOverrideProperty.restore();
    });
    tests.forEach(function(t) {
      it(t.m, function() {
        mainServiceInfoConfigsController.set("overrideToAdd", t.overrideToAdd);
        mainServiceInfoConfigsController.checkOverrideProperty(t.componentConfig);
        if(t.add) {
          expect(mainServiceInfoConfigsController.addOverrideProperty.calledWith(t.overrideToAdd)).to.equal(true);
          expect(mainServiceInfoConfigsController.get("overrideToAdd")).to.equal(null);
        } else {
          expect(mainServiceInfoConfigsController.addOverrideProperty.calledOnce).to.equal(false);
        }
      });
    });
  });

  describe("#setValuesForOverrides", function() {
    var tests = [
      {
        overrides: [
          {name: "override1"},
          {name: "override2"}
        ],
        _serviceConfigProperty: {},
        serviceConfigProperty: Em.Object.create({overrides: Em.A([])}),
        defaultGroupSelected: true
      }
    ];
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "createNewSCP", function(override) {return {name: override.name}})
    });
    afterEach(function() {
      mainServiceInfoConfigsController.createNewSCP.restore();
    });
    tests.forEach(function(t) {
      it("set values for overrides. use createNewSCP method to do this", function() {
        var serviceConfigProperty = t.serviceConfigProperty;
        mainServiceInfoConfigsController.setValuesForOverrides(t.overrides, serviceConfigProperty, t.serviceConfigProperty, t.defaultGroupSelected);
        expect(serviceConfigProperty.get("overrides")[0]).to.eql(t.overrides[0]);
        expect(serviceConfigProperty.get("overrides")[1]).to.eql(t.overrides[1]);
      });
    });
  });

  describe("#createConfigProperty", function() {
    var tests = [
      {
        _serviceConfigProperty: {
          overrides: {

          }
        },
        defaultGroupSelected: true,
        restartData: {},
        serviceConfigsData: {},
        serviceConfigProperty: {
          overrides: null,
          isOverridable: true
        }
      }];
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "setValueForCheckBox", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setValidator", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setValuesForOverrides", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setEditability", Em.K);
    });
    afterEach(function() {
      mainServiceInfoConfigsController.setValueForCheckBox.restore();
      mainServiceInfoConfigsController.setValidator.restore();
      mainServiceInfoConfigsController.setValuesForOverrides.restore();
      mainServiceInfoConfigsController.setEditability.restore();
    });
    tests.forEach(function(t) {
      it("create service config. run methods to correctly set object fileds", function() {
        var result = mainServiceInfoConfigsController.createConfigProperty(t._serviceConfigProperty, t.defaultGroupSelected, t.restartData, t.serviceConfigsData);
        expect(mainServiceInfoConfigsController.setValueForCheckBox.calledWith(t.serviceConfigProperty));
        expect(mainServiceInfoConfigsController.setValidator.calledWith(t.serviceConfigProperty, t.serviceConfigsData));
        expect(mainServiceInfoConfigsController.setValuesForOverrides.calledWith(t._serviceConfigProperty.overrides, t._serviceConfigProperty, t.serviceConfigProperty, t.defaultGroupSelected));
        expect(mainServiceInfoConfigsController.setValidator.calledWith(t.serviceConfigProperty, t.defaultGroupSelected));
        expect(result.getProperties('overrides','isOverridable')).to.eql(t.serviceConfigProperty);
      });
    });
  });

  describe("#createNewSCP", function() {
    var tests = [
      {
        overrides: {
          value: "value",
          group: {
            value: "group1"
          }
        },
        _serviceConfigProperty: {},
        serviceConfigProperty: Em.Object.create({
          value: "parentSCP",
          supportsFinal: true
        }),
        defaultGroupSelected: true,

        newSCP: {
          value: "value",
          isOriginalSCP: false,
          parentSCP:Em.Object.create({
            value: "parentSCP",
            supportsFinal: true
          }),
          group: {
            value: "group1"
          },
          isEditable: false
        }
      }
    ];
    tests.forEach(function(t) {
      it("", function() {
        var newSCP = mainServiceInfoConfigsController.createNewSCP(t.overrides, t._serviceConfigProperty, t.serviceConfigProperty, t.defaultGroupSelected);
        expect(newSCP.getProperties("value", "isOriginalSCP", "parentSCP", "group", "isEditable")).to.eql(t.newSCP);
      });
    });
  });

  describe("setCompareDefaultGroupConfig", function () {
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "getComparisonConfig").returns("compConfig");
      sinon.stub(mainServiceInfoConfigsController, "getMockComparisonConfig").returns("mockConfig");
      sinon.stub(mainServiceInfoConfigsController, "hasCompareDiffs").returns(true);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.getComparisonConfig.restore();
      mainServiceInfoConfigsController.getMockComparisonConfig.restore();
      mainServiceInfoConfigsController.hasCompareDiffs.restore();
    });
    it("expect that setCompareDefaultGroupConfig will not run anything", function () {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({}).compareConfigs.length).to.equal(0);
    });
    it("expect that setCompareDefaultGroupConfig will not run anything", function () {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({}, {}).compareConfigs.length).to.equal(0);
    });
    it("expect that serviceConfig.compareConfigs will be getMockComparisonConfig", function () {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isUserProperty: true}, null)).to.eql({compareConfigs: ["mockConfig"], isUserProperty: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function () {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isUserProperty: true}, {})).to.eql({compareConfigs: ["compConfig"], isUserProperty: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function () {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isReconfigurable: true}, {})).to.eql({compareConfigs: ["compConfig"], isReconfigurable: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function () {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isReconfigurable: true, isMock: true}, {})).to.eql({compareConfigs: ["compConfig"], isReconfigurable: true, isMock: true, isComparison: true, hasCompareDiffs: true});
    });
  });

  describe("#trackRequest()", function () {
    after(function(){
      mainServiceInfoConfigsController.set('requestInProgress', null);
    });
    it("should set requestInProgress", function () {
      mainServiceInfoConfigsController.trackRequest({'request': {}});
      expect(mainServiceInfoConfigsController.get('requestInProgress')).to.eql({'request': {}});
    });
  });
});

describe("#setCompareDefaultGroupConfig", function() {

  describe('#showSaveConfigsPopup', function () {

    var bodyView;

    describe('#bodyClass', function () {
      beforeEach(function() {
        sinon.stub(App.ajax, 'send', Em.K);
        // default implementation
        bodyView = mainServiceInfoConfigsController.showSaveConfigsPopup().get('bodyClass').create({
          parentView: Em.View.create()
        });
      });

      afterEach(function() {
        App.ajax.send.restore();
      });

      describe('#componentsFilterSuccessCallback', function () {
        it('check components with unknown state', function () {
          bodyView = mainServiceInfoConfigsController.showSaveConfigsPopup('', true, '', {}, '', 'unknown', '').get('bodyClass').create({
            parentView: Em.View.create()
          });
          bodyView.componentsFilterSuccessCallback({
            items: [
              {
                ServiceComponentInfo: {
                  total_count: 4,
                  started_count: 2,
                  installed_count: 1,
                  component_name: 'c1'
                },
                host_components: [
                  {HostRoles: {host_name: 'h1'}}
                ]
              }
            ]
          });
          var unknownHosts = bodyView.get('unknownHosts');
          expect(unknownHosts.length).to.equal(1);
          expect(unknownHosts[0]).to.eql({name: 'h1', components: 'C1'});
        });
      });
    });
  });

});

});

;require.register("test/controllers/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');
require('ember');
require('models/host_component');
require('views/common/modal_popup');
require('mixins/common/userPref');
require('controllers/application');
require('controllers/global/background_operations_controller');
require('controllers/global/cluster_controller');
require('controllers/main/service/reassign_controller');
require('controllers/main/service/item');
var batchUtils = require('utils/batch_scheduled_requests');

describe('App.MainServiceItemController', function () {

  describe('#setStartStopState', function () {
    var tests = [
      {
        serviceController: {
          serviceName: "YARN"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active because all services are running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HBASE"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active button because current service is running'
      },
      {
        serviceController: {
          serviceName: "HDFS"
        },
        backgroundOperationsController: {
          services: [

          ]
        },
        isPending: true,
        m: 'pending is true - backgroundOperationsController.services is empty'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: false,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - operation is not running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HDFS"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - current service is not running'
      }
    ];

    tests.forEach(function (test) {
      it(test.m, function () {
        sinon.stub(App.router, 'get', function(k) {
          if ('backgroundOperationsController.services' === k) return test.backgroundOperationsController.services;
          return Em.get(App.router, k);
        });
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.serviceController.serviceName}});
        mainServiceItemController.setStartStopState();
        App.router.get.restore();
        expect(mainServiceItemController.get('isPending')).to.equal(test.isPending);
      });
    })
  });

  describe('#reassignMaster()', function () {
    var tests = [
      {
        host_components: [
          {componentName: "RESOURCEMANGER"}
        ],
        componentName: "RESOURCEMANGER",
        result: true,
        m: 'run reassignMaster'
      },
      {
        host_components: [
          {componentName: "RESOURCEMANGER"}
        ],
        componentName: "DATANODE",
        result: false,
        m: 'don\t run reassignMaster'
      }
    ];

    tests.forEach(function (test) {
      var reassignMasterController = App.ReassignMasterController.create({currentStep: ''});

      beforeEach(function () {
        sinon.stub(reassignMasterController, 'saveComponentToReassign', Em.K);
        sinon.stub(reassignMasterController, 'getSecurityStatus', Em.K);
        sinon.stub(reassignMasterController, 'setCurrentStep', Em.K);
      });

      afterEach(function () {
        reassignMasterController.saveComponentToReassign.restore();
        reassignMasterController.getSecurityStatus.restore();
        reassignMasterController.setCurrentStep.restore();
      });

      it(test.m, function () {
        sinon.stub(App.router, 'transitionTo', Em.K);
        var mainServiceItemController = App.MainServiceItemController.create({});
        sinon.stub(App.HostComponent, 'find', function() {
          return test.host_components
        });
        sinon.stub(App.router, 'get', function(k) {
          if ('reassignMasterController' === k) return reassignMasterController;
          return Em.get(App.router, k);
        });
        mainServiceItemController.reassignMaster(test.componentName);
        expect(reassignMasterController.saveComponentToReassign.calledOnce).to.equal(test.result);
        expect(reassignMasterController.getSecurityStatus.calledOnce).to.equal(test.result);
        expect(reassignMasterController.setCurrentStep.calledOnce).to.equal(test.result);
        App.HostComponent.find.restore();
        App.router.transitionTo.restore();
        App.router.get.restore();
      });
    }, this);
  });

  describe("#doAction", function () {

    var el = document.createElement("BUTTON");
    el.disabled = false;
    var tests = [
      {
        event: {
          target: el,
          context: {
            action: 'runSmokeTest'
          }
        },
        m: "run runSmokeTest"
      },
      {
        event: {
          target: el,
          context: {
            action: 'refreshConfigs'
          }
        },
        m: "run refreshConfigs"
      },
      {
        event: {
          target: el,
          context: {
            action: 'restartAllHostComponents'
          }
        },
        m: "run restartAllHostComponents"
      },
      {
        event: {
          target: el,
          context: {
            action: 'rollingRestart'
          }
        },
        m: "run rollingRestart"
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = App.MainServiceItemController.create({});
      mainServiceItemController.set(test.event.context.action, Em.K);
      beforeEach(function () {
        sinon.spy(mainServiceItemController, test.event.context.action);
      });
      afterEach(function () {
        mainServiceItemController[test.event.context.action].restore();
      });
      it(test.m, function () {
        mainServiceItemController.doAction(test.event);
        expect(mainServiceItemController[test.event.context.action].calledOnce).to.equal(!test.event.target.disabled);
      });
    });
  });

  describe("#startStopPopupPrimary", function () {


    var tests = [
      {
        data: {
          "serviceName": "HDFS",
          "state": "STARTED",
          "query": Em.Object.create({ServiceInfo: "FAIL"})
        },
        request: {
          "RequestInfo": {
            "context": "_PARSE_.START.HDFS"
          },
          "Body": {
            "ServiceInfo": {
              "state": "STARTED"
            }
          }
        },
        m: "Start HDFS"
      },
      {
        data: {
          "serviceName": "YARN",
          "state": "STOPPED",
          "query": Em.Object.create({ServiceInfo: "FAIL"})
        },
        request: {
          "RequestInfo": {
            "context": "_PARSE_.STOP.YARN"
          },
          "Body": {
            "ServiceInfo": {
              "state": "STOPPED"
            }
          }
        },
        m: "Stop YARN"
      }
    ];

    beforeEach(function () {
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      $.ajax.restore();
    });


    tests.forEach(function (test) {
      it('', function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName}});
        mainServiceItemController.startStopPopupPrimary(test.data.state, test.data.query);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).Body.ServiceInfo.state).to.equal(test.request.Body.ServiceInfo.state);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.request.RequestInfo.context);

        expect(mainServiceItemController.get('isStopDisabled')).to.equal(true);
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(true);
      });
    });


  });

  describe("#startService , #stopService", function () {
    var mainServiceItemController = App.MainServiceItemController.create({startStopPopup: Em.K});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopup");
    });
    afterEach(function () {
      mainServiceItemController.startStopPopup.restore();
    });
    it("start service", function () {
      mainServiceItemController.startService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.started)).to.equal(true);
    });
    it("stop service", function () {
      mainServiceItemController.stopService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.stopped)).to.equal(true);
    });
  });


  describe("#turnOnOffPassive", function () {
    var mainServiceItemController = App.MainServiceItemController.create({turnOnOffPassiveRequest: Em.K});
    beforeEach(function () {
      sinon.spy(batchUtils, "turnOnOffPassiveRequest");
      mainServiceItemController.set('content', {serviceName: ''});
    });
    afterEach(function () {
      batchUtils.turnOnOffPassiveRequest.restore();
    });
    it("turns on/off passive mode for service", function () {
      mainServiceItemController.turnOnOffPassive({}).onPrimary();
      expect(batchUtils.turnOnOffPassiveRequest.calledOnce).to.equal(true);
    });
  });

  describe("#runSmokeTest", function () {
    var tests = [
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STARTED"
        },
        startSmoke: true,
        serviceName: "MAPREDUCE2",
        m: "don't run smoke test primary for MAPREDUCE2"
      },
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STOPPED"
        },
        startSmoke: false,
        serviceName: "MAPREDUCE2",
        m: "run smoke test primary for MAPREDUCE2"
      },
      {
        m: "run smoke test primary for all services (not MAPREDUCE2)",
        startSmoke: true,
        default: true
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = test.default ? App.MainServiceItemController.create({runSmokeTestPrimary: Em.K}) :
        App.MainServiceItemController.create({content: {serviceName: test.serviceName}, runSmokeTestPrimary: Em.K});
      beforeEach(function () {
        sinon.spy(mainServiceItemController, "runSmokeTestPrimary");
      });
      afterEach(function () {
        mainServiceItemController.runSmokeTestPrimary.restore();
      });
      it(test.m, function () {
        if (!test.default) {
          App.store.load(App.Service, test.content);
        }
        mainServiceItemController.runSmokeTest({}).onPrimary();
        expect(mainServiceItemController.runSmokeTestPrimary.calledOnce).to.equal(test.startSmoke);
      });
    });
  });

  describe("#startStopPopup", function () {
    var el = document.createElement("BUTTON");
    el.disabled = false;
    var event = {
      target: el
    };
    var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: "HDFS"}});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopupPrimary");
    });
    afterEach(function () {
      mainServiceItemController.startStopPopupPrimary.restore();
    });
    it("start start/stop service popup", function () {
      mainServiceItemController.startStopPopup(event, "").onPrimary();
      expect(mainServiceItemController.startStopPopupPrimary.calledOnce).to.equal(true);
    });
  });

  describe("#restartAllHostComponents", function () {
    var temp = batchUtils.restartAllServiceHostComponents;
    beforeEach(function () {
      batchUtils.restartAllServiceHostComponents = Em.K;
      sinon.spy(batchUtils, "restartAllServiceHostComponents");
      sinon.stub(App.Service, 'find', function() {
        return Em.Object.create({serviceTypes: []});
      });
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
      batchUtils.restartAllServiceHostComponents = temp;
      App.Service.find.restore();
    });

    var mainServiceItemController = App.MainServiceItemController.create({content: {displayName: "HDFS"}});

    it("start restartAllHostComponents for service", function () {
      mainServiceItemController.restartAllHostComponents({}).onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });
  });

  describe("#rollingRestart", function () {
    var temp = batchUtils.launchHostComponentRollingRestart;
    beforeEach(function () {
      batchUtils.launchHostComponentRollingRestart = Em.K;
      sinon.spy(batchUtils, "launchHostComponentRollingRestart");
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
      batchUtils.launchHostComponentRollingRestart = temp;
    });

    var mainServiceItemController = App.MainServiceItemController.create();

    it("start restartAllHostComponents for service", function () {
      mainServiceItemController.rollingRestart();
      expect(batchUtils.launchHostComponentRollingRestart.calledOnce).to.equal(true);
    });
  });

  describe("#isStartDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not red"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is red and pending is false"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {healthStatus: test.content.healthStatus}, isPending: test.isPending});
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#isSopDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is green and pending is false"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not green"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: test.content, isPending: test.isPending});
        expect(mainServiceItemController.get('isStopDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#runRebalancer", function () {
    it("run rebalancer", function () {
      sinon.stub(App.router, 'get', function(k) {
        if ('applicationController' === k) {
          return Em.Object.create({
            dataLoading: function() {
              return {done: Em.K}
            }
          });
        }
        return Em.get(App.router, k);
      });
      var mainServiceItemController = App.MainServiceItemController.create({content: {runRebalancer: false}});
      mainServiceItemController.runRebalancer().onPrimary();
      expect(mainServiceItemController.get("content.runRebalancer")).to.equal(true);
      App.router.get.restore();
    });
  });

  describe("#runCompaction", function () {
    it("run compaction", function () {
      sinon.stub(App.router, 'get', function(k) {
        if ('applicationController' === k) {
          return Em.Object.create({
            dataLoading: function() {
              return {done: Em.K}
            }
          });
        }
        return Em.get(App.router, k);
      });
      var mainServiceItemController = App.MainServiceItemController.create({content: {runCompaction: false}});
      mainServiceItemController.runCompaction().onPrimary();
      expect(mainServiceItemController.get("content.runCompaction")).to.equal(true);
      App.router.get.restore();
    });
  });

  describe("#runSmokeTestPrimary", function () {
    var tests = [
      {
        data: {
          'serviceName': "HDFS",
          'displayName': "HDFS",
          'query': "test"
        },
        "RequestInfo": {
          "context": "HDFS Service Check",
          "command" : "HDFS_SERVICE_CHECK"
        },
        "Requests/resource_filters": [{"service_name" : "HDFS"}]
      }
    ];
    tests.forEach(function (test) {

      var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName,
        displayName: test.data.displayName}});
      beforeEach(function () {
        mainServiceItemController.set("runSmokeTestErrorCallBack", Em.K);
        mainServiceItemController.set("runSmokeTestSuccessCallBack", Em.K);
        sinon.spy($, 'ajax');
      });

      afterEach(function () {
        $.ajax.restore();
      });

      it('send request to run smoke test', function () {

        mainServiceItemController.runSmokeTestPrimary(test.data.query);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.RequestInfo.context);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.command).to.equal(test.RequestInfo.command);
        expect(JSON.parse($.ajax.args[0][0].data)["Requests/resource_filters"][0].serviceName).to.equal(test["Requests/resource_filters"][0].serviceName);
      });
    });
  });


  describe('#downloadClientConfigs()', function () {

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        hostComponents: [
          Em.Object.create({
            isClient: true
          })
        ]
      }
    });

    beforeEach(function () {
      sinon.stub($, 'fileDownload', function() {
        return {
          fail: function() { return false; }
        }
      });
    });
    afterEach(function () {
      $.fileDownload.restore();
    });

    it('should launch $.fileDownload method', function () {
      mainServiceItemController.downloadClientConfigs();
      expect($.fileDownload.calledOnce).to.be.true;
    });
  });

  describe('#startLdapKnox() and #stopLdapKnox() should call startStopLdapKnox once: ', function () {


    var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: 'KNOX',
      displayName: 'Knox'}});

    beforeEach(function () {
      sinon.stub(mainServiceItemController, 'startStopLdapKnox', function(){
        return true;
      });
    });
    afterEach(function () {
      mainServiceItemController.startStopLdapKnox.restore();
    });

    var tests = [
      {
        methodName: 'startLdapKnox',
        callback: mainServiceItemController.startLdapKnox
      },
      {
        methodName: 'stopLdapKnox',
        callback: mainServiceItemController.stopLdapKnox
      }
    ];

    tests.forEach(function(test){
      it(test.methodName + ' should call startStopLdapKnox method', function () {
        test.callback.call(mainServiceItemController);
        expect(mainServiceItemController.startStopLdapKnox.calledOnce).to.be.true;
      });
    },this);

  });

  describe("#executeCustomCommand", function () {
    var data = {
      data: {
        'serviceName': "SAMPLESRV",
        'displayName': "SAMPLESRV",
        'query': "test"
      },
      "RequestInfo": {
        "context": "Execute Custom Commands",
        "command" : "SAMPLESRVCUSTOMCOMMANDS"
      },
      "Requests/resource_filters": [{"service_name" : "SAMPLESRV"}]
    };

    var context = {
      label: 'Execute Custom Commands',
      service: data.data.serviceName,
      component: data.data.serviceName,
      command: data.RequestInfo.command
    };

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: data.data.serviceName,
        displayName: data.data.displayName
      }
    });

    before(function () {
      mainServiceItemController.set("executeCustomCommandErrorCallback", Em.K);
      mainServiceItemController.set("executeCustomCommandSuccessCallback", Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });

    after(function () {
      App.showConfirmationPopup.restore();
    });

    it('shows a confirmation popup', function () {
      mainServiceItemController.executeCustomCommand(context);
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
    });
  });
});

});

;require.register("test/controllers/main/service/manage_config_groups_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var c;
describe('App.ManageConfigGroupsController', function() {
  var controller = App.ManageConfigGroupsController.create({});

  beforeEach(function() {
    c = App.ManageConfigGroupsController.create({});
  });

  describe('Host Name converting', function() {
    describe('#convertHostNames', function() {
      var hosts = [
        Em.Object.create({
          hostName: 'internal-1.com',
          publicHostName: 'external-1.com'
        }),
        Em.Object.create({
          hostName: 'internal-2.com',
          publicHostName: 'external-2.com'
        }),
        Em.Object.create({
          hostName: 'internal-3.com',
          publicHostName: 'external-3.com'
        })
      ];

      describe('#hostsToPublic', function() {
        beforeEach(function() {
          controller = App.ManageConfigGroupsController.create({
            clusterHosts: Em.A(hosts)
          });
        });

        var tests = [
          {
            hostsList: ['internal-1.com', 'internal-2.com', 'internal-3.com'],
            e: ['external-1.com', 'external-2.com', 'external-3.com']
          },
          {
            hostsList: 'internal-2.com',
            e: 'external-2.com'
          }
        ];
        var message = 'should convert internal host names `{0}` to external host names `{1}`';
        tests.forEach(function(test) {
          it(message.format(test.hostsList, test.e), function() {
            expect(controller.hostsToPublic(test.hostsList)).to.eql(test.e);
          });
        });
      });

      describe('#publicToHostName', function() {
        beforeEach(function() {
          controller = App.ManageConfigGroupsController.create({
            clusterHosts: Em.A(hosts)
          });
        });

        var tests = [
          {
            hostsList: ['external-1.com', 'external-2.com', 'external-3.com'],
            e: ['internal-1.com', 'internal-2.com', 'internal-3.com']
          },
          {
            hostsList: 'external-2.com',
            e: 'internal-2.com'
          }
        ];
        var message = 'should convert internal host names `{0}` to external host names `{1}`';
        tests.forEach(function(test) {
          it(message.format(test.hostsList, test.e), function() {
            expect(controller.publicToHostName(test.hostsList)).to.eql(test.e);
          });
        });
      });
    });

  });

  describe('#deleteHosts', function() {
    var hosts = [
      Em.Object.create({
        hostName: 'internal-1.com',
        publicHostName: 'external-1.com'
      }),
      Em.Object.create({
        hostName: 'internal-2.com',
        publicHostName: 'external-2.com'
      }),
      Em.Object.create({
        hostName: 'internal-3.com',
        publicHostName: 'external-3.com'
      })
    ];

    beforeEach(function() {
      controller = App.ManageConfigGroupsController.create({
        clusterHosts: hosts
      });
    });

    var createConfigGroupWithParentMock = function(groupHosts, groupPublicHosts, allHosts) {
      var parentCGHosts = allHosts.filter(function(host) {
        return !groupHosts.contains(host.get('hostName'));
      });
      return Em.Object.create({
        parentConfigGroup: {
          hosts: parentCGHosts.mapProperty('hostName'),
          publicHosts: parentCGHosts.mapProperty('publicHostName')
        },
        hosts: groupHosts,
        publicHosts: groupPublicHosts
      });
    };

    var tests = [
      {
        selectedHosts: ['external-1.com', 'external-2.com'],
        selectedConfigGroup: createConfigGroupWithParentMock(
          ['internal-1.com', 'internal-2.com'],
          ['external-1.com', 'external-2.com'], hosts),
        e: []
      },
      {
        selectedHosts: ['external-1.com'],
        selectedConfigGroup: createConfigGroupWithParentMock(
          ['internal-1.com', 'internal-2.com'],
          ['external-1.com', 'external-2.com'], hosts),
        e: ['external-2.com']
      }
    ];

    tests.forEach(function(test) {
      it('should remove {0}'.format(test.selectedHosts.slice(0)), function() {
        controller.reopen({
          selectedHosts: test.selectedHosts,
          selectedConfigGroup: test.selectedConfigGroup
        });
        controller.deleteHosts();
        expect(controller.get('selectedConfigGroup.publicHosts').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#addHostsCallback', function() {

    beforeEach(function() {

      c.reopen({
        selectedConfigGroup: Em.Object.create({
          hosts: ['h1'],
          publicHosts: ['p_h1'],
          parentConfigGroup: Em.Object.create({
            hosts: ['h2', 'h3'],
            publicHosts: ['p_h2', 'p_h3']
          })
        })
      });

      sinon.stub(c, 'hostsToPublic', function(s) {return 'p_' + s;});

    });

    afterEach(function() {
      c.hostsToPublic.restore();
    });

    it('should set hosts to selectedConfigGroup and remove them form default group', function () {

      c.addHostsCallback(['h2', 'h3']);

      expect(c.get('selectedConfigGroup.hosts')).to.include.members(['h1','h2','h3']);
      expect(c.get('selectedConfigGroup.publicHosts')).to.include.members(['p_h1','p_h2','p_h3']);
      expect(c.get('selectedConfigGroup.parentConfigGroup.hosts').toArray()).to.be.empty;
      expect(c.get('selectedConfigGroup.parentConfigGroup.publicHosts').toArray()).to.be.empty;
    });

  });

});

});

;require.register("test/controllers/main/service/reassign/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/service/reassign/step2_controller');
require('models/host_component');

describe('App.ReassignMasterWizardStep2Controller', function () {


  var controller = App.ReassignMasterWizardStep2Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create({}),
      services: []
    }),
    renderComponents: Em.K,
    multipleComponents: []
  });
  controller.set('_super', Em.K);

  describe('#loadStep', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'loadComponents', Em.K);
      sinon.stub(controller, 'loadStepCallback', Em.K);
      sinon.stub(controller, 'rebalanceSingleComponentHosts', Em.K);
    });

    afterEach(function () {
      App.router.send.restore();
      controller.clearStep.restore();
      controller.loadStepCallback.restore();
      controller.loadComponents.restore();
      controller.rebalanceSingleComponentHosts.restore();
    });

    it('SECONDARY_NAMENODE is absent, reassign component is NAMENODE', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'isHaEnabled') return true;
        return Em.get(App, k);
      });
      controller.set('content.reassign.component_name', 'NAMENODE');
      controller.set('content.masterComponentHosts', []);

      controller.loadStep();
      expect(controller.get('showCurrentHost')).to.be.false;
      expect(controller.get('componentToRebalance')).to.equal('NAMENODE');
      expect(controller.get('rebalanceComponentHostsCounter')).to.equal(1);
      App.get.restore();
    });
    it('SECONDARY_NAMENODE is present, reassign component is NAMENODE', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'isHaEnabled') return false;
        return Em.get(App, k);
      });
      controller.set('content.reassign.component_name', 'NAMENODE');
      controller.set('content.masterComponentHosts', [
        {
          component: 'SECONDARY_NAMENODE'
        }
      ]);

      controller.loadStep();
      expect(controller.get('showCurrentHost')).to.be.true;
      expect(controller.rebalanceSingleComponentHosts.calledWith('NAMENODE'));
      App.get.restore();
    });
    it('SECONDARY_NAMENODE is absent, reassign component is not NAMENODE', function () {
      controller.set('content.reassign.component_name', 'COMP');
      controller.set('content.masterComponentHosts', []);

      controller.loadStep();
      expect(controller.get('showCurrentHost')).to.be.true;
      expect(controller.rebalanceSingleComponentHosts.calledWith('COMP'));
    });
    it('if HA is enabled then multipleComponents should contain NAMENODE', function () {
      controller.get('multipleComponents').clear();
      sinon.stub(App, 'get', function (k) {
        if (k === 'isHaEnabled') return true;
        return Em.get(App, k);
      });

      controller.loadStep();
      expect(controller.get('multipleComponents')).to.contain('NAMENODE');
      expect(controller.get('multipleComponents')).to.have.length(1);
      App.get.restore();
    });
  });

  describe('#loadComponents', function () {
    it('masterComponentHosts is empty', function () {
      controller.set('content.masterComponentHosts', []);
      controller.set('content.reassign.host_id', 1);

      expect(controller.loadComponents()).to.be.empty;
      expect(controller.get('currentHostId')).to.equal(1);
    });
    it('masterComponentHosts does not contain reassign component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [Em.Object.create({
          componentName: 'COMP1',
          serviceName: 'SERVICE'
        })];
      });
      controller.set('content.masterComponentHosts', [{
        component: 'COMP1',
        hostName: 'host1'
      }]);
      controller.set('content.reassign.host_id', 1);
      controller.set('content.reassign.component_name', 'COMP2');

      expect(controller.loadComponents()).to.eql([
        {
          "component_name": "COMP1",
          "display_name": "Comp1",
          "selectedHost": "host1",
          "isInstalled": true,
          "serviceId": "SERVICE",
          "isServiceCoHost": false,
          "color": "grey"
        }
      ]);
      expect(controller.get('currentHostId')).to.equal(1);

      App.HostComponent.find.restore();
    });
    it('masterComponentHosts contains reassign component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [Em.Object.create({
          componentName: 'COMP1',
          serviceName: 'SERVICE'
        })];
      });
      controller.set('content.masterComponentHosts', [{
        component: 'COMP1',
        hostName: 'host1'
      }]);
      controller.set('content.reassign.host_id', 1);
      controller.set('content.reassign.component_name', 'COMP1');

      expect(controller.loadComponents()).to.eql([
        {
          "component_name": "COMP1",
          "display_name": "Comp1",
          "selectedHost": "host1",
          "isInstalled": true,
          "serviceId": "SERVICE",
          "isServiceCoHost": false,
          "color": "green"
        }
      ]);
      expect(controller.get('currentHostId')).to.equal(1);

      App.HostComponent.find.restore();
    });
  });

  describe('#rebalanceSingleComponentHosts', function () {
    it('hosts is empty', function () {
      controller.set('hosts', []);

      expect(controller.rebalanceSingleComponentHosts()).to.be.false;
    });
    it('currentHostId matches one available host', function () {
      controller.set('hosts', [Em.Object.create({
        host_name: 'host1'
      })]);
      controller.set('currentHostId', 'host1');

      expect(controller.rebalanceSingleComponentHosts()).to.be.false;
    });

    var testCases = [
      {
        title: 'selectedHost = currentHostId and component_name = content.reassign.component_name',
        arguments: {
          selectedHost: 'host1',
          reassignComponentName: 'COMP1'
        },
        result: 'host3'
      },
      {
        title: 'selectedHost not equal to currentHostId and component_name = content.reassign.component_name',
        arguments: {
          selectedHost: 'host2',
          reassignComponentName: 'COMP1'
        },
        result: 'host2'
      },
      {
        title: 'selectedHost = currentHostId and component_name not equal to content.reassign.component_name',
        arguments: {
          selectedHost: 'host1',
          reassignComponentName: 'COMP2'
        },
        result: 'host1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('hosts', [
          Em.Object.create({
            host_name: 'host3'
          }),
          Em.Object.create({
            host_name: 'host2'
          })
        ]);
        controller.set('currentHostId', 'host1');
        controller.set('content.reassign.component_name', test.arguments.reassignComponentName);
        controller.set('selectedServicesMasters', [Em.Object.create({
          component_name: 'COMP1',
          selectedHost: test.arguments.selectedHost
        })]);

        expect(controller.rebalanceSingleComponentHosts('COMP1')).to.be.true;
        expect(controller.get('selectedServicesMasters')[0].get('selectedHost')).to.equal(test.result);
        expect(controller.get('selectedServicesMasters')[0].get('availableHosts').mapProperty('host_name')).to.eql(['host2', 'host3']);
      });
    });
  });

  describe('#updateIsSubmitDisabled', function () {
    var hostComponents = [];
    var isSubmitDisabled = false;

    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return hostComponents;
      });
      sinon.stub(controller, '_super', function() {
        return isSubmitDisabled;
      });
    });
    afterEach(function () {
      App.HostComponent.find.restore();
      controller._super.restore();
    });
    it('No host-components, reassigned equal 0', function () {
      expect(controller.updateIsSubmitDisabled()).to.be.true;
      expect(controller.get('submitDisabled')).to.be.true;
    });
    it('Reassign component match existed components, reassigned equal 0', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [Em.Object.create({
        componentName: 'COMP1',
        hostName: 'host1'
      })];
      controller.set('servicesMasters', [{
        selectedHost: 'host1'
      }]);

      expect(controller.updateIsSubmitDisabled()).to.be.true;
      expect(controller.get('submitDisabled')).to.be.true;
    });
    it('Reassign component do not match existed components, reassigned equal 1', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [Em.Object.create({
        componentName: 'COMP1',
        hostName: 'host1'
      })];
      controller.set('servicesMasters', []);

      expect(controller.updateIsSubmitDisabled()).to.be.false;
      expect(controller.get('submitDisabled')).to.be.false;
    });
    it('Reassign component do not match existed components, reassigned equal 2', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [
        Em.Object.create({
          componentName: 'COMP1',
          hostName: 'host1'
        }),
        Em.Object.create({
          componentName: 'COMP1',
          hostName: 'host2'
        })
      ];
      controller.set('servicesMasters', []);

      expect(controller.updateIsSubmitDisabled()).to.be.true;
      expect(controller.get('submitDisabled')).to.be.true;
    });

    it('submitDisabled is already true', function () {
      isSubmitDisabled = true;

      expect(controller.updateIsSubmitDisabled()).to.be.true;
      expect(controller.get('submitDisabled')).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/service/reassign/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/reassign/step4_controller');

describe('App.ReassignMasterWizardStep4Controller', function () {

  var controller = App.ReassignMasterWizardStep4Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create(),
      reassignHosts: Em.Object.create()
    })
  });

  beforeEach(function () {
    sinon.stub(App.ajax, 'send', Em.K);
  });
  afterEach(function () {
    App.ajax.send.restore();
  });

  describe('#setAdditionalConfigs()', function () {
    var isHadoop2Stack = false;

    beforeEach(function () {
      sinon.stub(App, 'get', function () {
        return isHadoop2Stack;
      });
    });
    afterEach(function () {
      App.get.restore();
    });


    it('Component is absent', function () {
      controller.set('additionalConfigsMap', []);
      var configs = {};

      expect(controller.setAdditionalConfigs(configs, 'COMP1', '')).to.be.false;
      expect(configs).to.eql({});
    });
    it('Component is present', function () {
      controller.set('additionalConfigsMap', [
        {
          componentName: 'COMP1',
          configs: {
            'test-site': {
              'property1': '<replace-value>:1111'
            }
          }
        }
      ]);
      var configs = {
        'test-site': {}
      };

      expect(controller.setAdditionalConfigs(configs, 'COMP1', 'host1')).to.be.true;
      expect(configs).to.eql({
        'test-site': {
          'property1': 'host1:1111'
        }
      });
    });
    it('configs_Hadoop2 is present but isHadoop2Stack = false', function () {
      isHadoop2Stack = false;
      controller.set('additionalConfigsMap', [
        {
          componentName: 'COMP1',
          configs: {
            'test-site': {
              'property1': '<replace-value>:1111'
            }
          },
          configs_Hadoop2: {
            'test-site': {
              'property2': '<replace-value>:2222'
            }
          }
        }
      ]);
      var configs = {
        'test-site': {}
      };

      expect(controller.setAdditionalConfigs(configs, 'COMP1', 'host1')).to.be.true;
      expect(configs).to.eql({
        'test-site': {
          'property1': 'host1:1111'
        }
      });
    });
    it('configs_Hadoop2 is present but isHadoop2Stack = true', function () {
      isHadoop2Stack = true;
      controller.set('additionalConfigsMap', [
        {
          componentName: 'COMP1',
          configs: {
            'test-site': {
              'property1': '<replace-value>:1111'
            }
          },
          configs_Hadoop2: {
            'test-site': {
              'property2': '<replace-value>:2222'
            }
          }
        }
      ]);
      var configs = {
        'test-site': {}
      };

      expect(controller.setAdditionalConfigs(configs, 'COMP1', 'host1')).to.be.true;
      expect(configs).to.eql({
        'test-site': {
          'property2': 'host1:2222'
        }
      });
    });
  });

  /*  describe('#loadStep()', function () {
   var isHaEnabled = true;

   beforeEach(function () {
   controller.set('content.reassign.service_id', 'service1');
   sinon.stub(controller, 'onTaskStatusChange', Em.K);
   sinon.stub(App, 'get', function () {
   return isHaEnabled;
   });
   });
   afterEach(function () {
   App.get.restore();
   controller.onTaskStatusChange.restore();
   });

   it('reassign component is NameNode and HA enabled', function () {
   isHaEnabled = true;
   controller.set('content.reassign.component_name', 'NAMENODE');

   controller.loadStep();
   expect(controller.get('hostComponents')).to.eql(['NAMENODE', 'ZKFC']);
   expect(controller.get('restartYarnMRComponents')).to.be.false;
   expect(controller.get('serviceName')).to.eql(['service1']);
   });
   it('reassign component is NameNode and HA disabled', function () {
   isHaEnabled = false;
   controller.set('content.reassign.component_name', 'NAMENODE');

   controller.loadStep();
   expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
   expect(controller.get('restartYarnMRComponents')).to.be.false;
   expect(controller.get('serviceName')).to.eql(['service1']);
   });
   it('reassign component is JOBTRACKER and HA enabled', function () {
   isHaEnabled = true;
   controller.set('content.reassign.component_name', 'JOBTRACKER');

   controller.loadStep();
   expect(controller.get('hostComponents')).to.eql(['JOBTRACKER']);
   expect(controller.get('restartYarnMRComponents')).to.be.true;
   expect(controller.get('serviceName')).to.eql(['service1']);
   });
   it('reassign component is RESOURCEMANAGER and HA enabled', function () {
   isHaEnabled = true;
   controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

   controller.loadStep();
   expect(controller.get('hostComponents')).to.eql(['RESOURCEMANAGER']);
   expect(controller.get('restartYarnMRComponents')).to.be.true;
   expect(controller.get('serviceName')).to.eql(['service1']);
   });
   });*/

  describe('#getHostComponentsNames()', function () {
    it('No host-components', function () {
      controller.set('hostComponents', []);
      expect(controller.getHostComponentsNames()).to.be.empty;
    });
    it('one host-components', function () {
      controller.set('hostComponents', ['COMP1']);
      expect(controller.getHostComponentsNames()).to.equal('Comp1');
    });
    it('ZKFC host-components', function () {
      controller.set('hostComponents', ['COMP1', 'ZKFC']);
      expect(controller.getHostComponentsNames()).to.equal('Comp1+ZKFC');
    });
  });

  describe('#removeUnneededTasks()', function () {
    var isHaEnabled = false;

    beforeEach(function () {
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });
      controller.set('tasks', [
        {id: 1},
        {id: 2},
        {id: 3},
        {id: 4},
        {id: 5},
        {id: 6},
        {id: 7},
        {id: 8},
        {id: 9}
      ]);
    });
    afterEach(function () {
      App.get.restore();
    });

    it('hasManualSteps is false', function () {
      controller.set('content.hasManualSteps', false);

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5, 8, 9]);
    });
    it('reassign component is not NameNode and HA disabled', function () {
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'COMP1');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5]);
    });
    it('reassign component is not NameNode and HA enabled', function () {
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'COMP1');
      isHaEnabled = true;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5]);
    });
    it('reassign component is NameNode and HA disabled', function () {
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'NAMENODE');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5]);
    });
    it('reassign component is NameNode and HA enabled', function () {
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'NAMENODE');
      isHaEnabled = true;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5, 6, 7]);
    });
  });

  describe('#initializeTasks()', function () {
    beforeEach(function () {
      controller.set('tasks', []);
      sinon.stub(controller, 'getHostComponentsNames', Em.K);
      sinon.stub(controller, 'removeUnneededTasks', Em.K);
    });
    afterEach(function () {
      controller.removeUnneededTasks.restore();
      controller.getHostComponentsNames.restore();
    });
    it('No commands', function () {
      controller.set('commands', []);
      controller.initializeTasks();

      expect(controller.get('tasks')).to.be.empty;
    });
    it('One command', function () {
      controller.set('commands', ['COMMAND1']);
      controller.initializeTasks();

      expect(controller.get('tasks')[0].get('id')).to.equal(0);
      expect(controller.get('tasks')[0].get('command')).to.equal('COMMAND1');
    });
  });

  describe('#hideRollbackButton()', function () {

    it('No showRollback command', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: false
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
    it('showRollback command is present', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: true
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
  });

  describe('#onComponentsTasksSuccess()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('No host-components', function () {
      controller.set('multiTaskCounter', 0);
      controller.set('hostComponents', []);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
    it('One host-component', function () {
      controller.set('multiTaskCounter', 0);
      controller.set('hostComponents', [
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
    it('two host-components', function () {
      controller.set('multiTaskCounter', 0);
      controller.set('hostComponents', [
        {},
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.called).to.be.false;
    });
  });

  describe('#getStopServicesData()', function () {
    it('restarting YARN component', function () {
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');
      sinon.stub(App.Service, 'find', function () {
        return [
          {
            serviceName: 'HDFS'
          },
          {
            serviceName: 'SERVICE1'
          }
        ];
      });

      expect(controller.getStopServicesData()).to.eql({
        "ServiceInfo": {
          "state": "INSTALLED"
        },
        "context": "Stop required services",
        "urlParams": "ServiceInfo/service_name.in(SERVICE1)"
      });
      App.Service.find.restore();
    });
    it('restarting non-YARN component', function () {
      controller.set('content.reassign.component_name', 'NAMENODE');
      expect(controller.getStopServicesData()).to.eql({
        "ServiceInfo": {
          "state": "INSTALLED"
        },
        "context": "Stop all services"
      });
    });
  });

  describe('#stopServices()', function () {
    it('', function () {
      sinon.stub(controller, 'getStopServicesData', Em.K);

      controller.stopServices();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.getStopServicesData.calledOnce).to.be.true;

      controller.getStopServicesData.restore();
    });
  });

  describe('#createHostComponents()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'createComponent', Em.K);
    });
    afterEach(function () {
      controller.createComponent.restore();
    });

    it('No host-components', function () {
      controller.set('hostComponents', []);

      controller.createHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.createComponent.called).to.be.false;
    });
    it('One host-component', function () {
      controller.set('hostComponents', ['COMP1']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.set('content.reassign.service_id', 'SERVICE1');

      controller.createHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.createComponent.calledWith('COMP1', 'host1', 'SERVICE1')).to.be.true;
    });
  });

  describe('#onCreateComponent()', function () {
    it('', function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.onCreateComponent();
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
      controller.onComponentsTasksSuccess.restore();
    });
  });

  describe('#putHostComponentsInMaintenanceMode()', function () {
    beforeEach(function(){
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.set('content.reassignHosts.source', 'source');
    });
    afterEach(function(){
      controller.onComponentsTasksSuccess.restore();
    });
    it('No host-components', function () {
      controller.set('hostComponents', []);
      controller.putHostComponentsInMaintenanceMode();
      expect(App.ajax.send.called).to.be.false;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it('One host-components', function () {
      controller.set('hostComponents', [{}]);
      controller.putHostComponentsInMaintenanceMode();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
  });

  describe('#installHostComponents()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
    });
    afterEach(function () {
      controller.updateComponent.restore();
    });

    it('No host-components', function () {
      controller.set('hostComponents', []);

      controller.installHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.updateComponent.called).to.be.false;
    });
    it('One host-component', function () {
      controller.set('hostComponents', ['COMP1']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.set('content.reassign.service_id', 'SERVICE1');

      controller.installHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.updateComponent.calledWith('COMP1', 'host1', 'SERVICE1', 'Install', 1)).to.be.true;
    });
  });

  describe('#reconfigure()', function () {
    it('', function () {
      sinon.stub(controller, 'loadConfigsTags', Em.K);
      controller.reconfigure();
      expect(controller.loadConfigsTags.calledOnce).to.be.true;
      controller.loadConfigsTags.restore();
    });
  });

  describe('#loadConfigsTags()', function () {
    it('', function () {
      controller.loadConfigsTags();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getConfigUrlParams()', function () {
    var testCases  = [
      {
        componentName: 'NAMENODE',
        result: [
          "(type=hdfs-site&tag=1)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'SECONDARY_NAMENODE',
        result: [
          "(type=hdfs-site&tag=1)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'JOBTRACKER',
        result: [
          "(type=mapred-site&tag=4)"
        ]
      },
      {
        componentName: 'RESOURCEMANAGER',
        result: [
          "(type=yarn-site&tag=5)"
        ]
      }
    ];

    var data = {
      Clusters: {
        desired_configs: {
          'hdfs-site': {tag: 1},
          'core-site': {tag: 2},
          'hbase-site': {tag: 3},
          'mapred-site': {tag: 4},
          'yarn-site': {tag: 5}
        }
      }
    };

    var services = [];

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return services;
      })
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    testCases.forEach(function (test) {
      it('get config of ' + test.componentName, function () {
        expect(controller.getConfigUrlParams(test.componentName, data)).to.eql(test.result);
      })
    });
    it('get config of NAMENODE when HBASE installed', function () {
      services = [
        {
          serviceName: 'HBASE'
        }
      ];
      expect(controller.getConfigUrlParams('NAMENODE', data)).to.eql([
        "(type=hdfs-site&tag=1)",
        "(type=core-site&tag=2)",
        "(type=hbase-site&tag=3)"
      ]);
    })
  });

  describe('#onLoadConfigsTags()', function () {
    it('', function () {
      sinon.stub(controller, 'getConfigUrlParams', function () {
        return [];
      });
      controller.set('content.reassign.component_name', 'COMP1');

      controller.onLoadConfigsTags({});
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.getConfigUrlParams.calledWith('COMP1', {})).to.be.true;

      controller.getConfigUrlParams.restore();
    });
  });

  describe('#onLoadConfigs()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'setAdditionalConfigs', Em.K);
      sinon.stub(controller, 'setSecureConfigs', Em.K);
      sinon.stub(controller, 'setSpecificNamenodeConfigs', Em.K);
      sinon.stub(controller, 'getComponentDir', Em.K);
      sinon.stub(controller, 'saveClusterStatus', Em.K);
      sinon.stub(controller, 'saveConfigsToServer', Em.K);
      controller.set('content.reassignHosts.target', 'host1');
    });
    afterEach(function () {
      controller.setAdditionalConfigs.restore();
      controller.setSecureConfigs.restore();
      controller.setSpecificNamenodeConfigs.restore();
      controller.getComponentDir.restore();
      controller.saveClusterStatus.restore();
      controller.saveConfigsToServer.restore();
    });

    it('component is not NAMENODE', function () {
      controller.set('content.reassign.component_name', 'COMP1');

      controller.onLoadConfigs({items: []});
      expect(controller.setAdditionalConfigs.calledWith({}, 'COMP1', 'host1')).to.be.true;
      expect(controller.setSecureConfigs.calledWith([], {}, 'COMP1')).to.be.true;
      expect(controller.setSpecificNamenodeConfigs.called).to.be.false;
      expect(controller.getComponentDir.calledWith({}, 'COMP1')).to.be.true;
      expect(controller.saveClusterStatus.calledWith([])).to.be.true;
      expect(controller.saveConfigsToServer.calledWith({})).to.be.true;
    });
    it('component is NAMENODE, has configs', function () {
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.onLoadConfigs({items: [
        {
          type: 'hdfs-site',
          properties: {}
        }
      ]});
      expect(controller.setAdditionalConfigs.calledWith({'hdfs-site': {}}, 'NAMENODE', 'host1')).to.be.true;
      expect(controller.setSecureConfigs.calledWith([], {'hdfs-site': {}}, 'NAMENODE')).to.be.true;
      expect(controller.setSpecificNamenodeConfigs.calledWith({'hdfs-site': {}}, 'host1')).to.be.true;
      expect(controller.getComponentDir.calledWith({'hdfs-site': {}}, 'NAMENODE')).to.be.true;
      expect(controller.saveClusterStatus.calledWith([])).to.be.true;
      expect(controller.saveConfigsToServer.calledWith({'hdfs-site': {}})).to.be.true;
    });
  });


 /* describe('#setSpecificNamenodeConfigs()', function () {
   it('configs is empty', function () {
   controller.setSpecificNamenodeConfigs();
   });
   });*/
});

});

;require.register("test/controllers/main/service/reassign_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/main/service/reassign_controller');

describe('App.ReassignMasterController', function () {

  var reassignMasterController = App.ReassignMasterController.create({});

  describe('#totalSteps', function () {
    it('check', function () {
      expect(reassignMasterController.get('totalSteps')).to.equal(6);
    });
  });

  reassignMasterController.set('content.reassign', {service_id:null});

});

});

;require.register("test/controllers/main/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service');

var mainServiceController;

describe('App.MainServiceController', function () {

  var tests = Em.A([
    {
      isStartStopAllClicked: true,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: true,
      eStop: true,
      mStart: 'mainServiceController StartAll is Disabled 2',
      mStop: 'mainServiceController StopAll is Disabled 2'
    },
    {
      isStartStopAllClicked: false,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'green',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: false,
      eStop: false,
      mStart: 'mainServiceController StartAll is Enabled 3',
      mStop: 'mainServiceController StopAll is Enabled 3'
    }

  ]);

  beforeEach(function() {
    mainServiceController = App.MainServiceController.create();
  });

  describe('#isStartAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStart, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStartAllDisabled')).to.equals(test.eStart);
      });
    });
  });

  describe('#isStopAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStop, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStopAllDisabled')).to.equals(test.eStop);
      });
    });
  });

  describe('#isStartStopAllClicked', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({
          allOperationsCount: 1
        });
      });
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it('should be based on BG ops count', function () {
      expect(mainServiceController.get('isStartStopAllClicked')).to.be.true;
    });

  });

  describe('#isAllServicesInstalled', function() {

    beforeEach(function() {
      sinon.stub(App.StackService, 'find', function() {
        return [
          {serviceName: 's1'},
          {serviceName: 's2'},
          {serviceName: 'HUE'}
        ];
      });
      mainServiceController.set('content', {});
    });

    afterEach(function() {
      App.StackService.find.restore();
    });

    it('should be false if content is not loaded', function() {
      expect(mainServiceController.get('isAllServicesInstalled')).to.be.false;
    });

    var tests = Em.A([
      {
        hue: false,
        content: ['', ''],
        m: 'no hue',
        e: true
      },
      {
        hue: false,
        content: [''],
        m: 'no hue (2)',
        e: false
      },
      {
        hue: true,
        content: ['', '', ''],
        m: 'hue',
        e: true
      },
      {
        hue: false,
        content: ['', ''],
        m: 'hue (2)',
        e: true
      }
    ]).forEach(function(test) {
        it(test.m, function() {
          mainServiceController.reopen({content: {content: test.content}});
          sinon.stub(App, 'get', function(k) {
            if ('supports.hue' == k) return test.hue;
            return Em.get(App, k);
          });
          var r = mainServiceController.get('isAllServicesInstalled');
          App.get.restore();
          expect(r).to.equal(test.e);
        });
      });

  });

  describe('#cluster', function() {

    var tests = Em.A([
      {
        isLoaded: true,
        cluster: [],
        m: 'cluster is loaded',
        e: {name: 'c1'}
      },
      {
        isLoaded: false,
        cluster: [],
        m: 'cluster is not loaded',
        e: null
      }
    ]).forEach(function(test) {
        it(test.m, function() {
          sinon.stub(App.router, 'get', function(k) {
            if ('clusterController.isLoaded' === k) return test.isLoaded;
            return Em.get(App.router, k);
          });
          sinon.stub(App.Cluster, 'find', function() {
            return [test.e];
          });
          var c = mainServiceController.get('cluster');
          App.router.get.restore();
          App.Cluster.find.restore();
          expect(c).to.eql(test.e);
        });
      });

  });

  describe('#startAllService', function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
    });

    it('target is disabled', function() {
      var event = {target: {className: 'disabled', nodeType: 1}};
      var r = mainServiceController.startAllService(event);
      expect(r).to.be.null;
    });

    it('parent is disabled', function() {
      var event = {target: {parentElement: {className: 'disabled', nodeType: 1}}};
      var r = mainServiceController.startAllService(event);
      expect(r).to.be.null;
    });

    it('nothing disabled', function() {
      var event = {target: {}}, query = 'query';
      mainServiceController.startAllService(event).onPrimary(query);
      expect(mainServiceController.allServicesCall.calledWith('STARTED', query));
    });

  });

  describe('#stopAllService', function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
    });

    it('target is disabled', function() {
      var event = {target: {className: 'disabled', nodeType: 1}};
      var r = mainServiceController.stopAllService(event);
      expect(r).to.be.null;
    });

    it('parent is disabled', function() {
      var event = {target: {parentElement: {className: 'disabled', nodeType: 1}}};
      var r = mainServiceController.stopAllService(event);
      expect(r).to.be.null;
    });

    it('nothing disabled', function() {
      var event = {target: {}}, query = 'query';
      mainServiceController.stopAllService(event).onPrimary(query);
      expect(mainServiceController.allServicesCall.calledWith('STARTED', query));
    });

  });

  describe('#allServicesCall', function() {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        if ('clusterName' === k) return 'tdk';
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    it('should do ajax-request', function() {
      var state = 'STARTED',
        query = 'some query';
      mainServiceController.allServicesCall(state, query);
      var params = $.ajax.args[0][0];
      expect(params.type).to.equal('PUT');
      expect(params.url.contains('/clusters/tdk/services?')).to.be.true;
      var data = JSON.parse(params.data);
      expect(data.Body.ServiceInfo.state).to.equal(state);
      expect(data.RequestInfo.context).to.equal(App.BackgroundOperationsController.CommandContexts.START_ALL_SERVICES);
    });

  });

  describe('#allServicesCallSuccessCallback', function() {

    it('should set status to FAIL', function() {
      var params = {query: Em.Object.create({status: ''})};
      mainServiceController.allServicesCallSuccessCallback({Requests: {id: 1}}, {}, params);
      expect(params.query.get('status')).to.equal('SUCCESS');
    });

  });

  describe('#allServicesCallErrorCallback', function() {

    it('should set status to FAIL', function() {
      var params = {query: Em.Object.create({status: ''})};
      mainServiceController.allServicesCallErrorCallback({}, {}, '', {}, params);
      expect(params.query.get('status')).to.equal('FAIL');
    });

  });

  describe('#gotoAddService', function() {

    beforeEach(function() {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    afterEach(function() {
      App.router.transitionTo.restore();
    });

    it('should not go to wizard', function() {
      mainServiceController.reopen({isAllServicesInstalled: true});
      mainServiceController.gotoAddService();
      expect(App.router.transitionTo.called).to.be.false;
    });

    it('should go to wizard', function() {
      mainServiceController.reopen({isAllServicesInstalled: false});
      mainServiceController.gotoAddService();
      expect(App.router.transitionTo.calledWith('main.serviceAdd')).to.be.true;
    });

  });

});

});

;require.register("test/controllers/main/views_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/views_controller');

describe('MainViewsController', function () {

  var mainViewsController = App.MainViewsController.create();

  describe('#loadAmbariViews()', function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.router.get.restore();
      App.ajax.send.restore();
    });

    it('should load views if the user is logged in', function () {
      sinon.stub(App.router, 'get').withArgs('loggedIn').returns(true);
      mainViewsController.loadAmbariViews();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

    it('should not load views if the user is not logged in', function () {
      sinon.stub(App.router, 'get').withArgs('loggedIn').returns(false);
      mainViewsController.loadAmbariViews();
      expect(App.ajax.send.notCalled).to.be.true;
    })
  });

});

});

;require.register("test/controllers/main_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

describe('App.InstallerController', function () {

  describe('#getServerVersionSuccessCallback', function () {

    var controller = App.MainController.create(),
      cases = [
        {
          osType: 'redhat5',
          expected: false
        },
        {
          osType: 'redhat6',
          expected: true
        },
        {
          osType: 'sles11',
          expected: false
        }
      ],
      title = 'App.isManagedMySQLForHiveEnabled should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osType), function () {
        controller.getServerVersionSuccessCallback({
          'RootServiceComponents': {
            'component_version': '',
            'properties': {
              'server.os_type': item.osType
            }
          }
        });
        expect(App.get('isManagedMySQLForHiveEnabled')).to.equal(item.expected);
      });
    });

  });

});

});

;require.register("test/controllers/wizard/stack_upgrade/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var Ember = require('ember');

require('models/host');
require('controllers/wizard/stack_upgrade/step3_controller');

describe('App.StackUpgradeStep3Controller', function() {

  var stackUpgradeStep3Controller = App.StackUpgradeStep3Controller.create();

  beforeEach(function() {
    sinon.stub(App.router, 'get', function(k) {
      if ('stackUpgradeController' === k) return Em.Object.create({
        save: Em.K
      })
      if ('stackUpgradeController.save' === k) return Em.K;
      return Em.get(App.router, k);
    });
  });

  afterEach(function() {
    App.router.get.restore();
  });

  describe('#runUpgradeErrorCallback', function() {
    var processes = [
      Ember.Object.create({
        status: '',
        isRetry: false,
        name: 'UPGRADE_SERVICES'
      })
    ];

    stackUpgradeStep3Controller.set('processes', processes);
    stackUpgradeStep3Controller.set('content', {cluster: {}, controllerName:'stackUpgradeController'});

    it('check process condition', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      stackUpgradeStep3Controller.runUpgradeErrorCallback();
      expect(stackUpgradeStep3Controller.get('processes').findProperty('name', 'UPGRADE_SERVICES').get('status')).to.equal('FAILED');
      expect(stackUpgradeStep3Controller.get('processes').findProperty('name', 'UPGRADE_SERVICES').get('isRetry')).to.equal(true);
      expect(stackUpgradeStep3Controller.get('submitButton')).to.equal(false);
      App.get.restore();
    });
  });

});

});

;require.register("test/controllers/wizard/step0_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster_states');
require('controllers/wizard/step0_controller');
var wizardStep0Controller;

describe('App.WizardStep0Controller', function () {

  beforeEach(function() {
    wizardStep0Controller = App.WizardStep0Controller.create({content: {cluster: {}}});
    sinon.stub(App.clusterStatus, 'set', Em.K);
    sinon.stub(App.router, 'send', Em.K);
  });

  afterEach(function() {
    App.clusterStatus.set.restore();
    App.router.send.restore();
  });

  describe('#invalidClusterName', function () {
    it('should return true if no cluster name is present', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':''}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains white spaces', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'the cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains special chars', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'$cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    })
  });

  describe('#loadStep', function() {
    it('should clear step data', function() {
      wizardStep0Controller.loadStep();
      expect(wizardStep0Controller.get('hasSubmitted')).to.equal(false);
      expect(wizardStep0Controller.get('clusterNameError')).to.equal('');
    });
  });

  describe('#submit', function() {
    it('if cluster name is valid should proceed', function() {
      wizardStep0Controller.set('content.cluster.name', 'tdk');
      wizardStep0Controller.submit();
      expect(wizardStep0Controller.get('content.cluster.status')).to.equal('PENDING');
      expect(wizardStep0Controller.get('content.cluster.isCompleted')).to.equal(false);
      expect(App.router.send.calledWith('next')).to.equal(true);
      expect(App.clusterStatus.set.calledWith('clusterName', 'tdk')).to.equal(true);
    });

    it('if cluster name isn\'t valid shouldn\'t proceed', function() {
      wizardStep0Controller.set('content.cluster.name', '@@@@');
      wizardStep0Controller.submit();
      expect(App.router.send.called).to.equal(false);
      expect(App.clusterStatus.set.called).to.equal(false);
    });
  });

});
});

;require.register("test/controllers/wizard/step10_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var App = require('app');
require('controllers/wizard/step10_controller');

var controller;

describe('App.WizardStep10Controller', function () {

  beforeEach(function() {
    controller = App.WizardStep10Controller.create();
    controller.set('content', {cluster: {status: 'INSTALL COMPLETE'}});
  });

  afterEach(function() {
    controller.clearStep();
  });

  describe('#clearStep', function() {
    it('should clear clusterInfo', function() {
      controller.get('clusterInfo').pushObject({});
      controller.clearStep();
      expect(controller.get('clusterInfo.length')).to.equal(0);
    });
  });

  describe('#loadStep', function() {
    beforeEach(function() {
      sinon.spy(controller, 'clearStep');
      sinon.stub(controller, 'loadRegisteredHosts', Em.K);
      sinon.stub(controller, 'loadInstalledHosts', Em.K);
      sinon.stub(controller, 'loadInstallTime', Em.K);
    });
    afterEach(function() {
      controller.clearStep.restore();
      controller.loadRegisteredHosts.restore();
      controller.loadInstalledHosts.restore();
      controller.loadInstallTime.restore();
    });
    it('should call clearStep', function() {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadInstalledHosts', function() {
      controller.loadStep();
      expect(controller.loadInstalledHosts.calledOnce).to.equal(true);
    });
    it('should loadInstallTime if not installerController', function() {
      controller.set('content.controllerName', 'addServiceController');
      controller.loadStep();
      expect(controller.loadInstallTime.calledOnce).to.equal(true);
    });
    var testsForLoadInstallTime = Em.A([
      {
        loadMasterComponents: true,
        loadStartedServices: true,
        e: true
      },
      {
        loadMasterComponents: true,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      }
    ]);
    testsForLoadInstallTime.forEach(function(test) {
      it('loadMasterComponents: ' + test.loadMasterComponents.toString() + ' loadStartedServices: ' + test.loadStartedServices.toString(), function() {
        controller.set('content.controllerName', 'installerController');
        sinon.stub(controller, 'loadMasterComponents', function() {return test.loadMasterComponents;});
        sinon.stub(controller, 'loadStartedServices', function() {return test.loadStartedServices;});
        controller.loadStep();
        expect(controller.loadInstallTime.called).to.equal(test.e);
        controller.loadMasterComponents.restore();
        controller.loadStartedServices.restore();
      });
    });
  });

  describe('#loadInstalledHosts', function() {
    var tests = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({status: 'success', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'success', tasks: []})
        },
        m: 'all success',
        e: Em.A([
          {id: 1, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'warning', tasks: []}),
          'h2': Em.Object.create({status: 'failed', tasks: []}),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'some failed, some warning',
        e: Em.A([
          {id: 2, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'failed', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'sone failed, some success, some warning',
        e: Em.A([
          {id: 1, l: 1},
          {id: 2, l: 2}
        ])
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        controller.set('content.hosts', test.hosts);
        controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
        controller.loadInstalledHosts();
        test.e.forEach(function(ex) {
          expect(controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', ex.id).get('displayStatement').contains(ex.l)).to.equal(true);
        });
      })
    });
    var testsForFailedTasks = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'only failed tasks',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'only failed tasks, warning hosts',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks, warning hosts',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks, warning hosts',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      }
    ]);
    testsForFailedTasks.forEach(function(test) {
      it(test.m, function() {
        controller.set('content.hosts', test.hosts);
        controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
        controller.loadInstalledHosts();
        test.e.forEach(function(ex) {
          expect(controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').mapProperty('status', ex.st).length).to.equal(ex.l);
        });
      })
    });
  });

  describe('#loadMasterComponent', function() {
    var tests = Em.A([
      {
        component: Em.Object.create({hostName: 'h1'}),
        e: 1
      },
      {
        component: Em.Object.create({}),
        e: 0
      }
    ]);

    tests.forEach(function(test) {
      it(test.component.get('hostName') ? 'Has hosNBame' : 'Doesn\'t have hostName', function() {
        controller.clearStep();
        controller.get('clusterInfo').pushObject(Em.Object.create({id: 2, status: []}));
        controller.loadMasterComponent(test.component);
        expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(test.e);
      })
    });
  });

  describe('#loadStartedServices', function() {
    var tests = Em.A([
      {
        status: 'STARTED',
        e: {
          ids: [3, 4],
          r: true
        }
      },
      {
        status: 'FAILED',
        e: {
          ids: [3],
          r: false
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.status, function() {
        controller.set('content', {cluster: {status: test.status}});
        var r = controller.loadStartedServices();
        expect(r).to.equal(test.e.r);
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e.ids);
      });
    });
  });

  describe('#loadInstallTime', function() {
    var tests = Em.A([
      {
        installTime: 123,
        e: [5]
      },
      {
        installTime: null,
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it('Install time' + test.installTime ? ' available' : ' not available', function() {
        controller.set('content', {cluster: {installTime: test.installTime}});
        var r = controller.loadInstallTime();
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e);
      });
    });
  });

  describe('#calculateInstallTime', function () {
    it('from "9.21" to 9 minutes 12 seconds', function () {
      expect(controller.calculateInstallTime('9.21')).to.eql({minutes: 9, seconds: 12});
    });
    it('from "0" to 0 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('0')).to.eql({minutes: 0, seconds: 0});
    });
    it('from "10" to 10 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('10')).to.eql({minutes: 10, seconds: 0});
    });
    it('from "0.5" to 0 minutes 30 seconds', function () {
      expect(controller.calculateInstallTime('0.5')).to.eql({minutes: 0, seconds: 30});
    });
  });

  describe('#loadMasterComponents', function() {

    var components = Em.A(['NAMENODE','SECONDARY_NAMENODE','JOBTRACKER','HISTORYSERVER','RESOURCEMANAGER','HBASE_MASTER','HIVE_SERVER','OOZIE_SERVER','GANGLIA_SERVER','NAGIOS_SERVER']);

    d3.range(1, components.length).forEach(function(i) {
      d3.range(1, i).forEach(function(j) {
        var c = components.slice(0, j);
        it(c.join(', '), function() {
          var m = c.map(function(component){return {component: component, displayName: component, hostName: 'h1'};});
          controller.set('content.masterComponentHosts', m);
          controller.loadMasterComponents();
          expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(m.length);
        });
      });
    });

  });

  describe('#isNagiosRestartRequired', function() {
    Em.A([
      {
        controllerName: 'addServiceController',
        isLoaded: true,
        e: true
      },
      {
        controllerName: 'installerController',
        isLoaded: true,
        e: false
      },
      {
        controllerName: 'addServiceController',
        isLoaded: false,
        e: false
      },
      {
        controllerName: 'installerController',
        isLoaded: false,
        e: false
      }
    ]).forEach(function (test) {
        it(test.controllerName + ' Nagios loaded' + test.isLoaded.toString(), function () {
          controller.set('content.controllerName', test.controllerName);
          sinon.stub(App.Service, 'find', function() {
            return Em.Object.create({
              isLoaded: test.isLoaded
            })
          });
          expect(controller.get('isNagiosRestartRequired')).to.equal(test.e);
          App.Service.find.restore();
        });
      });
  });

  describe('#loadRegisteredHosts', function() {
    it('should add object to clusterInfo', function() {
      var masterComponentHosts = [{hostName: 'h1'}, {hostName: 'h2'}, {hostName: 'h3'}],
        slaveComponentHosts = [{hosts: [{hostName: 'h1'}, {hostName: 'h4'}]}, {hosts: [{hostName: 'h2'}, {hostName: 'h5'}]}],
        hosts = [{hostName: 'h6'}, {hostName: 'h3'}, {hostName: 'h7'}];
      controller.set('content.masterComponentHosts', masterComponentHosts);
      controller.set('content.slaveComponentHosts', slaveComponentHosts);
      controller.set('clusterInfo', []);
      sinon.stub(App.Host, 'find', function() {
        return hosts;
      });
      var obj = controller.loadRegisteredHosts();
      App.Host.find.restore();
      expect(obj.id).to.equal(1);
      expect(obj.color).to.equal('text-info');
      expect(obj.displayStatement).to.equal(Em.I18n.t('installer.step10.hostsSummary').format(7));
      expect(obj.status).to.eql([]);
      expect(controller.get('clusterInfo.firstObject')).to.eql(obj);
    });
  });

});
});

;require.register("test/controllers/wizard/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var Ember = require('ember');
require('controllers/wizard/step2_controller');
require('models/host');
require('models/host_component');
require('messages');
var c;
describe('App.WizardStep2Controller', function () {

  beforeEach(function() {
    c = App.WizardStep2Controller.create();
  });

  describe('#isInstaller', function() {
    it('true if controllerName is installerController', function() {
      var controller = App.WizardStep2Controller.create({content: {controllerName: 'installerController'}});
      expect(controller.get('isInstaller')).to.equal(true);
    });
    it('false if controllerName isn\'t installerController', function() {
      var controller = App.WizardStep2Controller.create({content: {controllerName: 'addServiceController'}});
      expect(controller.get('isInstaller')).to.equal(false);
    });
  });

  describe('#manualInstall', function() {
    it('should be equal to content.installOptions.manualInstall', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: true}}});
      expect(controller.get('manualInstall')).to.equal(true);
      controller.toggleProperty('content.installOptions.manualInstall');
      expect(controller.get('manualInstall')).to.equal(false);
    });
  });

  describe('#hostNames', function() {
    it('should be equal to content.installOptions.hostNames', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {hostNames: 'A,b,C'}}});
      expect(controller.get('hostNames')).to.equal('a,b,c');
      controller.set('content.installOptions.hostNames', 'a,B');
      expect(controller.get('hostNames')).to.equal('a,b');
    });
  });

  describe('#sshKey', function() {
    it('should be equal to content.installOptions.sshKey', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {sshKey: '123'}}});
      expect(controller.get('sshKey')).to.equal('123');
      controller.set('content.installOptions.sshKey', '321');
      expect(controller.get('sshKey')).to.equal('321');
    });
  });

  describe('#sshUser', function() {
    it('should be equal to content.installOptions.sshUser', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {sshUser: '123'}}});
      expect(controller.get('sshUser')).to.equal('123');
      controller.set('content.installOptions.sshUser', '321');
      expect(controller.get('sshUser')).to.equal('321');
    });
  });

  describe('#installType', function() {
    it('should be manualDriven if manualInstall is selected', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: true}}});
      expect(controller.get('installType')).to.equal('manualDriven');
    });
    it('should be ambariDriven if manualInstall isn\'t selected', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: false}}});
      expect(controller.get('installType')).to.equal('ambariDriven');
    });
  });

  describe('#updateHostNameArr()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: 'apache.ambari'
    });
    controller.updateHostNameArr();

    it('should push to hostNameArr only new host names', function(){
      expect(controller.get('hostNameArr').length).to.equal(1);
    });

    it('should push to inputtedAgainHostNames already installed host names', function(){
      expect(controller.get('inputtedAgainHostNames').length).to.equal(0);
    })
  });

  describe('#isAllHostNamesValid()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: ''
    });

    it('should return true if all host names are valid', function(){
      controller.set('hostNames', 'amache.org ambari.com');
      expect(controller.isAllHostNamesValid()).to.equal(true);
    });

    var tests = Em.A([
      'hostname',
      '-hostname.com',
      'hostname-.com',
      'host_name.com',
      '123.123.123.123',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostname'
    ]);
    tests.forEach(function (test) {
      it('should return false for invalid host names ' + test + ' ', function () {
        controller.set('hostNames', test);
        expect(controller.isAllHostNamesValid()).to.equal(false);
      });
    });
  });

  describe('#checkHostError()', function () {

    var controller = App.WizardStep2Controller.create();

    it('should set hostsError if hostNames is ""', function () {
      controller.set('content', {'installOptions': {'hostNames': ''}});
      controller.checkHostError();
      expect(controller.get('hostsError').length).to.be.above(2);
    });

    it('should set hostsError to null if hostNames is valid', function () {
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
      controller.checkHostError();
      expect(controller.get('hostsError')).to.equal(null);
    })
  });

  describe('#checkHostAfterSubmitHandler()', function () {

    it('should be called after changing hasSubmitted', function (done) {
      var controller = App.WizardStep2Controller.create({
        checkHostError: function () {
          done();
        }
      });
      controller.set('hasSubmitted', true);
    });

    it('should be called after changing hostNames', function (done) {
      var controller = App.WizardStep2Controller.create({
        hasSubmitted: true,
        checkHostError: function () {
          done();
        }
      });
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
    })
  });

  describe('#sshKeyError', function () {

    var tests = Em.A([
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it(test.sshKey + ' ' + test.manualInstall.toString() + ' ' + test.hasSubmitted.toString(), function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshKey: test.sshKey}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshKeyError')).to.equal(null);
        }
        else {
          expect(controller.get('sshKeyError').length).to.be.above(2);
        }
      });
    });
  });

  describe('#sshUserError', function () {

    var tests = Em.A([
      {
        manualInstall: false,
        sshUser: '',
        e: ''
      },
      {
        manualInstall: true,
        sshUser: '',
        e: null
      },
      {
        manualInstall: true,
        sshUser: 'nobody',
        e: null
      },
      {
        manualInstall: false,
        sshUser: 'nobody',
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it('', function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshUser: test.sshUser}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshUserError')).to.equal(null);
        }
        else {
          expect(controller.get('sshUserError').length).to.be.above(2);
        }
      });
    });

  });

  describe('#getHostInfo()', function () {

    it('should return object with bootStatus, installType and name for every element in hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['apache', 'ambari'],
        installType: 'manualDriven'
      });

      var test = controller.getHostInfo();
      expect(test).to.eql({
        'apache':{'name':'apache', 'installType': 'manualDriven', 'bootStatus': 'PENDING', isInstalled: false},
        'ambari':{'name':'ambari', 'installType': 'manualDriven', 'bootStatus': 'PENDING', isInstalled: false}
      });
    })
  });

  describe('#setSshKey()', function () {

    it('should set content.installOptions.sshKey', function () {
      var controller = App.WizardStep2Controller.create({
        content: {'installOptions': {'sshKey': '111'}}
      });
      controller.setSshKey('222');
      expect(controller.get('content.installOptions.sshKey')).to.equal('222');
    })
  });

  describe('#evaluateStep()', function () {

    it('should return false if isSubmitDisabled is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({isSubmitDisabled: true});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostsError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.set('hostsError', 'error');
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshKeyError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({sshKeyError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostNameArr is empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: '',
        parseHostNamesAsPatternExpression: Em.K
      });
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if isPattern is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        isPattern: true,
        parseHostNamesAsPatternExpression: Em.K
      });
      expect(controller.evaluateStep()).to.equal(false);
    })
  });

  describe('#parseHostNamesAsPatternExpression()', function () {

    it('should parse hosts from pattern expression to hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['host[001-011]']
      });
      controller.parseHostNamesAsPatternExpression();
      var result = true;
      var hosts = controller.get('hostNameArr');
      for (var i = 1; i<12; i++) {
        var extra = (i.toString().length == 1) ? 0 : '';
        if (hosts[i-1] !== 'host0' + extra + i) {
          result = false;
        }
      }
      expect(result).to.equal(true);
    })
  });

  describe('#proceedNext()', function () {

    it('should call warningPopup if not isAllHostNamesValid and no warningConfirmed', function() {
      c.reopen({
        isAllHostNamesValid: function() {
          return false;
        },
        warningPopup: Em.K
      });
      sinon.spy(c, 'warningPopup');
      var r = c.proceedNext(false);
      expect(r).to.equal(false);
      expect(c.warningPopup.calledOnce).to.equal(true);
    });

    it('should call manualInstallPopup if manualInstall is true', function () {
      c.reopen({
        hostNames: '',
        manualInstall: true,
        manualInstallPopup: Em.K
      });
      sinon.spy(c, 'manualInstallPopup');
      var r = c.proceedNext(true);
      expect(r).to.equal(false);
      expect(c.manualInstallPopup.calledOnce).to.equal(true);
    });

    it ('should save hosts and proceed next if skipBootstrap is true', function() {
      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) {
          return true;
        }
        return Em.get(App, k);
      });
      sinon.stub(App.router, 'send', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        isAllHostNamesValid: function() {return true;},
        content: {
          installOptions: {},
          hosts: null
        }
      });
      var r = c.proceedNext();
      expect(r).to.equal(true);
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.get.restore();
      App.router.send.restore();
    });

    it('should call setupBootStrap', function() {
      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) {
          return false;
        }
        return Em.get(App, k);
      });
      c.reopen({
        hostNameArr: ['h1'],
        isAllHostNamesValid: function() {return true;},
        content: {
          installOptions: {},
          hosts: null
        }
      });
      sinon.stub(c, 'setupBootStrap', Em.K);
      var r = c.proceedNext();
      expect(r).to.equal(true);
      expect(c.setupBootStrap.calledOnce).to.eql(true);
      App.get.restore();
      c.setupBootStrap.restore();
    });

  });

  describe('#isSubmitDisabled', function () {

    var controller = App.WizardStep2Controller.create({
      hostsError: '',
      sshKeyError: ''
    });

    it('should return value if hostsError is not empty', function () {
      controller.set('hostsError', 'error');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    });

    it('should return value if sshKeyError is not empty', function () {
      controller.set('sshKeyError', 'error');
      controller.set('hostsError', '');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    })
  });

  describe('#installedHostsPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.installedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.installedHostsPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#warningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();

    });
    it('should call App.ModalPopup.show', function() {
      c.warningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.warningPopup().onPrimary();
      expect(c.proceedNext.calledWith(true)).to.equal(true);
    });
  });

  describe('#hostNamePatternPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.hostNamePatternPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.hostNamePatternPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#manualInstallPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'saveHosts', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      App.router.send.restore();
      c.saveHosts.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.manualInstallPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should save hosts and go next on primary', function() {
      c.manualInstallPopup().onPrimary();
      expect(c.saveHosts.calledOnce).to.equal(true);
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
  });

  describe('#manualInstallWarningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
    });
    it('should call App.ModalPopup.show if content.installOptions.useSsh is false', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: false}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('shouldn\'t call App.ModalPopup.show if content.installOptions.useSsh is true', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: true}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.called).to.equal(false);
    });
  });

  describe('#setAmbariJavaHome', function() {
    beforeEach(function() {
      sinon.spy($, 'ajax');
    });
    afterEach(function() {
      $.ajax.restore();
    });
    it('should do ajax-request', function() {
      var controller = App.WizardStep2Controller.create({onGetAmbariJavaHomeSuccess: Em.K, onGetAmbariJavaHomeError: Em.K});
      controller.setAmbariJavaHome();
      expect($.ajax.calledOnce).to.equal(true);
    });
  });

  describe('#onGetAmbariJavaHomeSuccess', function() {
    it('should set java.home value receiced from server', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      var test = {RootServiceComponents: {properties: {'java.home': '/root'}}};
      controller.onGetAmbariJavaHomeSuccess(test);
      expect(controller.content.installOptions.javaHome).to.equal('/root');
    });
  });

  describe('#onGetAmbariJavaHomeError', function() {
    it('should set default java.home value', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      controller.onGetAmbariJavaHomeError();
      expect(controller.content.installOptions.javaHome).to.equal(App.get('defaultJavaHome'));
    });
  });

  describe('#saveHosts', function() {
    beforeEach(function() {
      sinon.stub(c, 'setAmbariJavaHome', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        content: {
          hosts: null
        }
      });
    });
    afterEach(function() {
      c.setAmbariJavaHome.restore();
    });
    it('should call setAmbariJavaHome', function() {
      c.saveHosts();
      expect(c.setAmbariJavaHome.calledOnce).to.equal(true);
    });
    it('should set content.hosts', function() {
      c.saveHosts();
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
    });
  });

});

});

;require.register("test/controllers/wizard/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Ember = require('ember');
var App = require('app');
var c;
require('utils/ajax/ajax');
require('utils/http_client');
require('models/host');
require('controllers/wizard/step3_controller');

describe('App.WizardStep3Controller', function () {

  beforeEach(function() {
    c = App.WizardStep3Controller.create({
      content: Em.Object.create({installedHosts: Em.A([]), installOptions: {}}),
      wizardController: App.InstallerController.create(),
      disablePreviousSteps: Em.K
    });
    sinon.stub(App.router, 'send', Em.K);
  });

  afterEach(function() {
    App.router.send.restore();
  });

  describe('#getAllRegisteredHostsCallback', function () {
    it('One host is already in the cluster, one host is registered', function() {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name:'wst3_host1'},
          {name:'wst3_host2'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host2'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(test_data);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(true);
      expect(c.get('registeredHosts').length).to.equal(1);
    });

    it('All hosts are new', function() {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name:'wst3_host3'},
          {name:'wst3_host4'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host4'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(test_data);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(c.get('registeredHosts')).to.equal('');
    });

    it('No new hosts', function() {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name:'wst3_host1'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(test_data);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(c.get('registeredHosts')).to.equal('');
    });

  });

  describe('#registrationTimeoutSecs', function() {
    it('Manual install', function() {
      c.set('content.installOptions.manualInstall', true);
      expect(c.get('registrationTimeoutSecs')).to.equal(15);
    });
    it('Not manual install', function() {
      c.set('content.installOptions.manualInstall', false);
      expect(c.get('registrationTimeoutSecs')).to.equal(120);
    });
  });

  describe('#isHostHaveWarnings', function() {
    var tests = [
      {
        warnings: [{},{}],
        m: 'Warnings exist',
        e: true
      },
      {
        warnings: [],
        m: 'Warnings don\'t exist',
        e: false
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        c.set('warnings', test.warnings);
        expect(c.get('isHostHaveWarnings')).to.equal(test.e);
      });
    });
  });

  describe('#isWarningsBoxVisible', function() {

    afterEach(function() {
      App.get.restore();
    });

    it('for testMode should be always true', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
    });
    it('for "real" mode should be based on isRegistrationInProgress', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.set('isRegistrationInProgress', false);
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
      c.set('isRegistrationInProgress', true);
      expect(c.get('isWarningsBoxVisible')).to.equal(false);
    });
  });

  describe('#clearStep', function() {
    it('should clear hosts', function() {
      c.set('hosts', [{}, {}]);
      c.clearStep();
      expect(c.get('hosts')).to.eql([]);
    });
    it('should clear bootHosts', function() {
      c.set('bootHosts', [{}, {}]);
      c.clearStep();
      expect(c.get('bootHosts').length).to.equal(0);
    });
    it('should set stopBootstrap to false', function() {
      c.set('stopBootstrap', true);
      c.clearStep();
      expect(c.get('stopBootstrap')).to.equal(false);
    });
    it('should set wizardController DBProperty bootStatus to false', function() {
      c.get('wizardController').setDBProperty('bootStatus', true);
      c.clearStep();
      expect(c.get('wizardController').getDBProperty('bootStatus')).to.equal(false);
    });
    it('should set isSubmitDisabled to true', function() {
      c.set('isSubmitDisabled', false);
      c.clearStep();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
    it('should set isSubmitDisabled to true', function() {
      c.set('isRetryDisabled', false);
      c.clearStep();
      expect(c.get('isRetryDisabled')).to.equal(true);
    });
  });

  describe('#loadStep', function() {

    beforeEach(function() {
      sinon.stub(App.router, 'get', function(k) {
        if ('clusterController' === k) {
          return Em.Object.create({
            loadAmbariProperties: Em.K
          });
        }
        return Em.get(App.router, k);
      });
    });

    afterEach(function() {
      App.router.get.restore();
    });

    it('should set registrationStartedAt to null', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('registrationStartedAt', {});
      c.loadStep();
      expect(c.get('registrationStartedAt')).to.be.null;
    });
    it('should call clearStep', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('loadHosts', Em.K);
      sinon.spy(c, 'clearStep');
      c.loadStep();
      expect(c.get('clearStep').calledOnce).to.equal(true);
      c.clearStep.restore();
    });
    it('should call loadHosts', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('loadHosts', Em.K);
      sinon.spy(c, 'loadHosts');
      c.loadStep();
      expect(c.get('loadHosts').calledOnce).to.equal(true);
      c.loadHosts.restore();
    });
    it('should call disablePreviousSteps', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('loadHosts', Em.K);
      sinon.spy(c, 'disablePreviousSteps');
      c.loadStep();
      expect(c.get('disablePreviousSteps').calledOnce).to.equal(true);
      c.disablePreviousSteps.restore();
    });
  });

  describe('#loadHosts', function() {

    afterEach(function() {
      App.get.restore();
    });

    it('should set isLoaded to true', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      c.set('navigateStep', Em.K);
      c.set('content', {hosts: {}});
      c.loadHosts();
      expect(c.get('isLoaded')).to.equal(true);
    });
    it('should set bootStatus REGISTERED on testMode', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      c.set('navigateStep', Em.K);
      c.set('content', {hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'REGISTERED')).to.equal(true);
    });
    it('should set bootStatus DONE on "real" mode and when installOptions.manualInstall is selected', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.set('navigateStep', Em.K);
      c.set('content.installOptions', {manualInstall: true});
      c.set('content.hosts', {c: {name: 'name'}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'DONE')).to.equal(true);
    });
    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.set('navigateStep', Em.K);
      c.set('content', {installOptions:{manualInstall: false}, hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'PENDING')).to.equal(true);
    });
    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      c.set('navigateStep', Em.K);
      c.set('content', {hosts: {c: {name: 'name'}, d: {name: 'name1'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('isChecked', false)).to.equal(true);
    });
  });

  describe('#parseHostInfo', function() {

    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'RUNNING', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, one is RUNNING',
        e: {
          c: true,
          r: true
        }
      },
      {
        bootHosts: Em.A([]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts is empty',
        e: {
          c: false,
          r: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'REGISTERED', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'REGISTERED', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, no one is RUNNING',
        e: {
          c: true,
          r: false
        }
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        c.set('bootHosts', test.bootHosts);
        var r = c.parseHostInfo(test.hostsStatusFromServer);
        expect(r).to.equal(test.e.r);
        if (test.e.c) {
          test.hostsStatusFromServer.forEach(function(h) {
            var r = c.get('bootHosts').findProperty('name', h.hostName);
            if (!['REGISTERED', 'REGISTERING'].contains(r.get('bootStatus'))) {
              expect(r.get('bootStatus')).to.equal(h.status);
              expect(r.get('bootLog')).to.equal(h.log);
            }
          });
        }
      });
    });
  });

  describe('#removeHosts', function() {

    it('should call App.showConfirmationPopup', function() {
      sinon.spy(App, 'showConfirmationPopup');
      c.removeHosts(Em.A([]));
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
      App.showConfirmationPopup.restore();
    });
    it('primary should disable Submit if no more hosts', function() {
      var hosts = [{}];
      c.set('hosts', hosts);
      var popup = c.removeHosts(hosts);
      popup.onPrimary();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
  });

  describe('#removeHost', function() {
    it('should call removeHosts with array as arg', function() {
      var host = {a:''};
      sinon.spy(c, 'removeHosts');
      c.removeHost(host);
      expect(c.removeHosts.calledWith([host]));
      c.removeHosts.restore();
    });
  });

  describe('#removeSelectedHosts', function() {
    it('should remove selected hosts', function() {
      c = App.WizardStep3Controller.create({
        wizardController: App.InstallerController.create(),
        hosts: [
          {isChecked: true, name: 'c1'},
          {isChecked: false, name: 'c2'}
        ]
      });
      c.removeSelectedHosts().onPrimary();
      expect(c.get('hosts').mapProperty('name')).to.eql(['c2']);
    });
  });

  describe('#selectedHostsPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.selectedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#retryHosts', function () {
    var s;
    var installer = {launchBootstrap: Em.K};

    beforeEach(function () {
      sinon.spy(installer, "launchBootstrap");
      s = sinon.stub(App.router, 'get', function () {
        return installer;
      });
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.doBootstrap.restore();
      s.restore();
      installer.launchBootstrap.restore();
    });

    it('should set numPolls to 0', function () {
      c.set('content', {installOptions: {}});
      c.set('numPolls', 123);
      c.retryHosts(Em.A([]));
      expect(c.get('numPolls')).to.equal(0);
    });
    it('should set registrationStartedAt to null', function () {
      c.set('content', {installOptions: {}});
      c.retryHosts(Em.A([]));
      expect(c.get('registrationStartedAt')).to.be.null;
    });
    it('should startRegistration if installOptions.manualInstall is true', function () {
      sinon.spy(c, 'startRegistration');
      c.set('content', {installOptions: {manualInstall: true}});
      c.retryHosts(Em.A([]));
      expect(c.startRegistration.calledOnce).to.equal(true);
      c.startRegistration.restore();
    });
    it('should launchBootstrap if installOptions.manualInstall is false', function () {
      c.set('content', {installOptions: {manualInstall: false}});
      c.retryHosts(Em.A([]));
      expect(installer.launchBootstrap.calledOnce).to.be.true;
    });
  });

  describe('#retryHost', function() {
    it('should callretryHosts with array as arg', function() {
      var host = {n: 'c'}, s = sinon.stub(App.router, 'get', function() {
        return {launchBootstrap: Em.K}
      });
      sinon.spy(c, 'retryHosts');
      c.set('content', {installOptions: {}});
      c.set('doBootstrap', Em.K);
      c.retryHost(host);
      expect(c.retryHosts.calledWith([host])).to.equal(true);
      c.retryHosts.restore();
      s.restore();
    });
  });

  describe('#retrySelectedHosts', function() {
    it('shouldn\'t do nothing if isRetryDisabled is true', function() {
      c.set('isRetryDisabled', true);
      sinon.spy(c, 'retryHosts');
      c.retrySelectedHosts();
      expect(c.retryHosts.called).to.equal(false);
      c.retryHosts.restore();
    });
    it('should retry hosts with FAILED bootStatus and set isRetryDisabled to true', function() {
      var s = sinon.stub(App.router, 'get', function() {
        return {launchBootstrap: Em.K}
      });
      c = App.WizardStep3Controller.create({
        wizardController: App.InstallerController.create(),
        isRetryDisabled: false,
        bootHosts: Em.A([Em.Object.create({name: 'c1', bootStatus: 'FAILED'}), Em.Object.create({name: 'c2', bootStatus: 'REGISTERED'})]),
        content: {installOptions: {}},
        doBootstrap: Em.K
      });
      sinon.spy(c, 'retryHosts');
      c.retrySelectedHosts();
      expect(c.retryHosts.calledWith([{name: 'c1', bootStatus: 'RUNNING'}]));
      expect(c.get('isRetryDisabled')).to.equal(true);
      c.retryHosts.restore();
      s.restore();
    });
  });

  describe('#startBootstrap', function() {
    it('should drop numPolls and registrationStartedAt', function() {
      c.set('numPolls', 123);
      c.set('registrationStartedAt', 1234);
      c.set('doBootstrap', Em.K);
      c.startBootstrap();
      expect(c.get('numPolls')).to.equal(0);
      expect(c.get('registrationStartedAt')).to.be.null;
    });
    it('should drop numPolls and registrationStartedAt', function() {
      var hosts = Em.A([{name: 'c1'}, {name: 'c2'}]);
      c = App.WizardStep3Controller.create({
        wizardController: App.InstallerController.create(),
        doBootstrap: Em.K,
        setRegistrationInProgressOnce: Em.K,
        hosts: hosts
      });
      c.startBootstrap();
      expect(c.get('bootHosts').mapProperty('name')).to.eql(['c1','c2']);
    });
  });

  describe('#setRegistrationInProgressOnce', function() {
    it('should call Ember.run.once with "setRegistrationInProgress"', function() {
      sinon.spy(Em.run, 'once');
      c.setRegistrationInProgressOnce();
      expect(Em.run.once.firstCall.args[1]).to.equal('setRegistrationInProgress');
      Em.run.once.restore();
    });
  });

  describe('#setRegistrationInProgress', function() {
    var tests = Em.A([
      {
        bootHosts: [],
        isLoaded: false,
        e: true,
        m: 'no bootHosts and isLoaded is false'
      },
      {
        bootHosts: [],
        isLoaded: true,
        e: false,
        m: 'no bootHosts and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: false,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one REGISTERED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: false,
        m: 'bootHosts with one REGISTERED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: false,
        m: 'bootHosts with one FAILED and isLoaded is true'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.stub(c, 'disablePreviousSteps', Em.K);
        c.set('bootHosts', test.bootHosts);
        c.set('isLoaded', test.isLoaded);
        c.setRegistrationInProgress();
        expect(c.get('isRegistrationInProgress')).to.equal(test.e);
        c.disablePreviousSteps.restore();
      });
    });
  });

  describe('#doBootstrap', function() {
    beforeEach(function() {
      sinon.spy(App.ajax, 'send');
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('shouldn\'t do nothing if stopBootstrap is true', function() {
      c.set('stopBootstrap', true);
      c.doBootstrap();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should increment numPolls if stopBootstrap is false', function() {
      c.set('stopBootstrap', false);
      c.set('numPolls', 0);
      c.doBootstrap();
      expect(c.get('numPolls')).to.equal(1);
    });
    it('should do ajax call if stopBootstrap is false', function() {
      c.set('stopBootstrap', false);
      c.doBootstrap();
      expect(App.ajax.send.called).to.equal(true);
    });
  });

  describe('#startRegistration', function() {
    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function() {
      c.set('registrationStartedAt', 1234);
      sinon.spy(c, 'isHostsRegistered');
      c.startRegistration();
      expect(c.isHostsRegistered.called).to.equal(false);
      expect(c.get('registrationStartedAt')).to.equal(1234);
      c.isHostsRegistered.restore();
    });
    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function() {
      c.set('registrationStartedAt', null);
      sinon.spy(c, 'isHostsRegistered');
      c.startRegistration();
      expect(c.isHostsRegistered.calledOnce).to.equal(true);
      c.isHostsRegistered.restore();
    });
  });

  describe('#isHostsRegistered', function() {
    beforeEach(function() {
      sinon.stub(App.ajax, 'send', function() {return {retry: function() {return {then: Em.K}}}});
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('shouldn\'t do nothing if stopBootstrap is true', function() {
      c.set('stopBootstrap', true);
      c.isHostsRegistered();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should do ajax call if stopBootstrap is false', function() {
      c.set('stopBootstrap', false);
      c.isHostsRegistered();
      expect(App.ajax.send.called).to.equal(true);

    });
  });

  describe('#isHostsRegisteredSuccessCallback', function() {
    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'DONE'})
        ]),
        data: {items:[]},
        m: 'one host DONE',
        e: {
          bs: 'REGISTERING',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items:[{Hosts: {host_name: 'c1'}}]},
        m: ' one host REGISTERING',
        e: {
          bs: 'REGISTERED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items:[{Hosts: {host_name: 'c2'}}]},
        m: 'one host REGISTERING but data without info about it',
        e: {
          bs: 'FAILED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'RUNNING', name: 'c1'})
        ]),
        data: {items:[{Hosts: {host_name: 'c1'}}]},
        m: ' one host RUNNING',
        e: {
          bs: 'RUNNING',
          getHostInfoCalled: false
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.spy(c, 'getHostInfo');
        c.set('content.installedHosts', []);
        c.set('bootHosts', test.bootHosts);
        c.isHostsRegisteredSuccessCallback(test.data);
        expect(c.get('bootHosts')[0].get('bootStatus')).to.equal(test.e.bs);
        expect(c.getHostInfo.called).to.equal(test.e.getHostInfoCalled);
        c.getHostInfo.restore();
      });
    });
  });

  describe('#getAllRegisteredHosts', function() {
    it('should call App.ajax.send', function() {
      sinon.spy(App.ajax, 'send');
      c.getAllRegisteredHosts();
      expect(App.ajax.send.calledOnce).to.equal(true);
      App.ajax.send.restore();
    });
  });

  describe('#getAllRegisteredHostsCallback', function() {
    var tests = Em.A([
      {
        hostsInCluster: ['c3'],
        bootHosts: [{name:'c1'},{name:'c2'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: 'No registered hosts',
        e: {
          hasMoreRegisteredHosts: false,
          registeredHosts: ''
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [{name:'c3'},{name:'c5'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: '2 registered hosts',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c1','c2']
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [{name:'c1'},{name:'c5'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: '1 registered host',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      },
      {
        hostsInCluster: ['c1'],
        bootHosts: [{name:'c3'},{name:'c5'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: '1 registered host (2)',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        c.reopen({setRegistrationInProgress: Em.K, hostsInCluster: test.hostsInCluster});
        c.set('bootHosts', test.bootHosts);
        c.getAllRegisteredHostsCallback({items:test.hosts});
        expect(c.get('hasMoreRegisteredHosts')).to.equal(test.e.hasMoreRegisteredHosts);
        expect(c.get('registeredHosts')).to.eql(test.e.registeredHosts);
      });
    });
  });

  describe('#registerErrPopup', function() {
    it('should call App.ModalPopup.show', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.registerErrPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#getHostInfo', function() {
    it('should do ajax request', function() {
      sinon.spy(App.ajax, 'send');
      c.getHostInfo();
      expect(App.ajax.send.calledOnce).to.equal(true);
      App.ajax.send.restore();
    });
  });

  describe('#getHostInfoErrorCallback', function() {
    it('should call registerErrPopup', function() {
      sinon.spy(c, 'registerErrPopup');
      c.getHostInfoErrorCallback();
      expect(c.registerErrPopup.calledOnce).to.equal(true);
      c.registerErrPopup.restore();
    });
  });

  describe('#stopRegistration', function() {
    var tests = Em.A([
      {
        bootHosts: [{bootStatus: 'REGISTERED'}, {bootStatus: 'RUNNING'}],
        e: {isSubmitDisabled: false, isRetryDisabled: true}
      },
      {
        bootHosts: [{bootStatus: 'FAILED'}, {bootStatus: 'RUNNING'}],
        e: {isSubmitDisabled: true, isRetryDisabled: false}
      },
      {
        bootHosts: [{bootStatus: 'FAILED'}, {bootStatus: 'REGISTERED'}],
        e: {isSubmitDisabled: false, isRetryDisabled: false}
      },
      {
        bootHosts: [{bootStatus: 'RUNNING'}, {bootStatus: 'RUNNING'}],
        e: {isSubmitDisabled: true, isRetryDisabled: true}
      }
    ]);
    tests.forEach(function(test) {
      it(test.bootHosts.mapProperty('bootStatus').join(', '), function() {
        c.reopen({bootHosts: test.bootHosts});
        c.stopRegistration();
        expect(c.get('isSubmitDisabled')).to.equal(test.e.isSubmitDisabled);
        expect(c.get('isRetryDisabled')).to.equal(test.e.isRetryDisabled);
      });
    });
  });

  describe('#submit', function() {
    it('if isHostHaveWarnings should show confirmation popup', function() {
      c.reopen({isHostHaveWarnings: true});
      sinon.spy(App.ModalPopup, 'show');
      c.submit();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
    it('if isHostHaveWarnings should show confirmation popup. on Primary should set bootHosts to content.hosts', function() {
      var bootHosts = [{name: 'c1'}];
      c.reopen({isHostHaveWarnings: true, bootHosts: bootHosts, hosts: []});
      c.submit().onPrimary();
      expect(c.get('confirmedHosts')).to.eql(bootHosts);
    });
    it('if isHostHaveWarnings is false should set bootHosts to content.hosts', function() {
      var bootHosts = [{name: 'c1'}];
      c.reopen({isHostHaveWarnings: false, bootHosts: bootHosts, hosts: []});
      c.submit();
      expect(c.get('confirmedHosts')).to.eql(bootHosts);
    });
  });

  describe('#hostLogPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.hostLogPopup({context:Em.Object.create({})});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#rerunChecksSuccessCallback', function() {
    beforeEach(function() {
      sinon.stub(c, 'parseWarnings', Em.K);
    });
    afterEach(function() {
      c.parseWarnings.restore();
    });
    it('should set checksUpdateProgress to 100', function() {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksSuccessCallback({items: []});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });
    it('should set checksUpdateStatus to SUCCESS', function() {
      c.set('checksUpdateStatus', '');
      c.rerunChecksSuccessCallback({items: []});
      expect(c.get('checksUpdateStatus')).to.equal('SUCCESS');
    });
    it('should call parseWarnings', function() {
      c.rerunChecksSuccessCallback({items: []});
      expect(c.parseWarnings.calledOnce).to.equal(true);
    });
  });

  describe('#rerunChecksErrorCallback', function() {
    it('should set checksUpdateProgress to 100', function() {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });
    it('should set checksUpdateStatus to FAILED', function() {
      c.set('checksUpdateStatus', '');
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateStatus')).to.equal('FAILED');
    });
  });

  describe('#filterBootHosts', function() {
    var tests = Em.A([
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}}
          ]
        },
        m: 'one host',
        e: ['c1']
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c3'}}
          ]
        },
        m: 'no hosts',
        e: []
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}},
            {Hosts: {host_name: 'c2'}}
          ]
        },
        m: 'many hosts',
        e: ['c1', 'c2']
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        c.reopen({bootHosts: test.bootHosts});
        var filteredData = c.filterBootHosts(test.data);
        expect(filteredData.items.mapProperty('Hosts.host_name')).to.eql(test.e);
      });
    });
  });

  describe('#hostWarningsPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      c.hostWarningsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
    it('should clear checksUpdateStatus on primary', function() {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onPrimary();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });
    it('should clear checksUpdateStatus on close', function() {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onClose();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });
    it('should rerunChecks onSecondary', function() {
      sinon.stub(c, 'rerunChecks', Em.K);
      c.hostWarningsPopup().onSecondary();
      expect(c.rerunChecks.calledOnce).to.equal(true);
    });
  });

  describe('#registeredHostsPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.registeredHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#parseWarnings', function() {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      sinon.stub(c, 'filterBootHosts', function(k) {return k;});
    });

    afterEach(function() {
      App.get.restore();
      c.filterBootHosts.restore();
    });

    it('no warnings if last_agent_env isn\'t specified', function() {
      c.set('warnings', [{}]);
      c.set('warningsByHost', [{},{}]);
      c.parseWarnings({items:[{Hosts:{host_name:'c1'}}]});
      expect(c.get('warnings')).to.eql([]);
      expect(c.get('warningsByHost.length')).to.equal(1); // default group
    });

    Em.A([
        {
          m: 'parse stackFoldersAndFiles',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {stackFoldersAndFiles: []}}}],
              m: 'empty stackFoldersAndFiles',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [{name: 'n1'}]}}}],
              m: 'not empty stackFoldersAndFiles',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'fileFolders'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [{name: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {stackFoldersAndFiles: [{name: 'n1'}]}}}
              ],
              m: 'not empty stackFoldersAndFiles on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'fileFolders'
                }],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse installedPackages',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {installedPackages: []}}}],
              m: 'empty installedPackages',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {installedPackages: [{name: 'n1'}]}}}],
              m: 'not empty installedPackages',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'packages'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {installedPackages: [{name: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {installedPackages: [{name: 'n1'}]}}}
              ],
              m: 'not empty installedPackages on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'packages'
                }],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.liveServices',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth: []}}}],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{liveServices: []}}}}],
              m: 'empty liveServices',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}}],
              m: 'not empty hostHealth.liveServices',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'services'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}},
                {Hosts:{host_name: 'c2', last_agent_env: {hostHealth:{liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}}
              ],
              m: 'not empty hostHealth.liveServices on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'services'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse existingUsers',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {existingUsers: []}}}],
              m: 'empty existingUsers',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {existingUsers: [{userName: 'n1'}]}}}],
              m: 'not empty existingUsers',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'users'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {existingUsers: [{userName: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {existingUsers: [{userName: 'n1'}]}}}
              ],
              m: 'not empty existingUsers on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'users'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse alternatives',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {alternatives: []}}}],
              m: 'empty alternatives',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {alternatives: [{name: 'n1'}]}}}],
              m: 'not empty alternatives',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'alternatives'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {alternatives: [{name: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {alternatives: [{name: 'n1'}]}}}
              ],
              m: 'not empty alternatives on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'alternatives'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.activeJavaProcs',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth: [], javaProcs: []}}}],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{activeJavaProcs: []}}}}],
              m: 'empty activeJavaProcs',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{activeJavaProcs: [{pid: 'n1', command: ''}]}}}}],
              m: 'not empty hostHealth.activeJavaProcs',
              e: {
                warnings: [{
                  pid: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'processes'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{activeJavaProcs: [{pid: 'n1', command: ''}]}}}},
                {Hosts:{host_name: 'c2', last_agent_env: {hostHealth:{activeJavaProcs: [{pid: 'n1', command: ''}]}}}}
              ],
              m: 'not empty hostHealth.activeJavaProcs on two hosts',
              e: {
                warnings: [{
                  pid: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'processes'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        }
      ]).forEach(function(category) {
        describe(category.m, function() {
          category.tests.forEach(function(test) {
            it(test.m, function() {
              c.parseWarnings({items: test.items});
              c.get('warnings').forEach(function(w, i) {
                Em.keys(test.e.warnings[i]).forEach(function(k) {
                  expect(w[k]).to.eql(test.e.warnings[i][k]);
                });
              });
              for(var i in test.e.warningsByHost) {
                if(test.e.warningsByHost.hasOwnProperty(i)) {
                  expect(c.get('warningsByHost')[i].warnings.length).to.equal(test.e.warningsByHost[i]);
                }
              }
            });
          });
        });
      });

    it('should parse umask warnings', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {umask: 18}}},
        {Hosts:{host_name: 'c2', last_agent_env: {umask: 1}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c2']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse umask warnings (2)', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {umask: 8}}},
        {Hosts:{host_name: 'c2', last_agent_env: {umask: 1}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(2);
      expect(warnings.mapProperty('hosts')).to.eql([['c1'], ['c2']]);

    });


    it('should parse firewall warnings', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {iptablesIsRunning: true}}},
        {Hosts:{host_name: 'c2', last_agent_env: {iptablesIsRunning: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse firewall warnings (2)', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {iptablesIsRunning: true}}},
        {Hosts:{host_name: 'c2', last_agent_env: {iptablesIsRunning: true}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1','c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

    it('should parse reverseLookup warnings', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {reverseLookup: true}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(0);

    });

    it('should parse reverseLookup warnings (2)', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {reverseLookup: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse reverseLookup warnings (3)', function() {

      var items = [
        {Hosts:{host_name: 'c1', last_agent_env: {reverseLookup: false}}},
        {Hosts:{host_name: 'c2', last_agent_env: {reverseLookup: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1','c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

  });

  describe('#navigateStep', function() {
    Em.A([
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: false,
          m: 'should call startBootstrap',
          e: true
        },
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: true,
          m: 'shouldn\'t call startBootstrap (1)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: false,
          bootStatus: false,
          m: 'shouldn\'t call startBootstrap (2)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: true,
          bootStatus: false,
          m: 'shouldn\'t call startBootstrap (3)',
          e: false
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          c.reopen({
            isLoaded: test.isLoaded,
            content: {
              installedHosts: [],
              installOptions: {
                manualInstall: test.manualInstall
              }
            },
            wizardController: Em.Object.create({
              getDBProperty: function() {
                return test.bootStatus
              }
            })
          });
          sinon.stub(c, 'startBootstrap', Em.K);
          c.navigateStep();
          if(test.e) {
            expect(c.startBootstrap.calledOnce).to.equal(true);
          }
          else {
            expect(c.startBootstrap.called).to.equal(false);
          }
          c.startBootstrap.restore();
        });
      });

    it('should set test data if testMode is true', function() {
      c.reopen({
        isLoaded: true,
        hosts: [{}, {}, {}],
        content: {
          installedHosts: [],
          installOptions: {
            manualInstall: true
          }
        },
        setRegistrationInProgress: Em.K
      });
      sinon.stub(App, 'get', function(k) {
        if('testMode' === k) return true;
        return Em.get(App, k);
      });
      c.navigateStep();
      App.get.restore();
      expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      expect(c.get('bootHosts').everyProperty('cpu', '2')).to.equal(true);
      expect(c.get('bootHosts').everyProperty('memory', '2000000')).to.equal(true);
      expect(c.get('isSubmitDisabled')).to.equal(false);
    });

    it('should start registration', function() {
      c.reopen({
        isLoaded: true,
        hosts: [{}, {}, {}],
        content: {
          installedHosts: [],
          installOptions: {
            manualInstall: true
          }
        },
        setRegistrationInProgress: Em.K,
        startRegistration: Em.K
      });
      sinon.spy(c, 'startRegistration');
      sinon.stub(App, 'get', function(k) {
        if('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.navigateStep();
      App.get.restore();
      expect(c.startRegistration.calledOnce).to.equal(true);
      expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      expect(c.get('registrationStartedAt')).to.be.null;
      c.startRegistration.restore();
    });

  });

  describe('#checkHostDiskSpace', function() {
    Em.A([
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 - 1024,
              mountpoint: '/'
            }
          ],
          m: 'available less than App.minDiskSpace',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (1)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (2)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 + 1024,
              mountpoint: '/'
            }
          ],
          m: 'available greater than App.minDiskSpace',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (1)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (2)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/home/tdk'
            }
          ],
          m: 'mount point without free space checks',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var r = c.checkHostDiskSpace('', test.diskInfo);
          expect(Em.isEmpty(r)).to.equal(test.e);
        });
      });
  });

  describe('#checkHostOSType', function() {
    it('should return empty string if no stacks provided', function() {
      c.reopen({content: {stacks: null}});
      expect(c.checkHostOSType()).to.equal('');
    });
    it('os type is valid', function() {
      var osType = 'redhat6';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [Em.Object.create({isSelected: true, osType: osType})]})
          ]
        }
      });
      expect(c.checkHostOSType(osType, '')).to.equal('');
    });
    it('os type is invalid', function() {
      var osType = 'os2';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [Em.Object.create({isSelected: true, osType: 'os1'})]})
          ]
        }
      });
      expect(Em.isEmpty(c.checkHostOSType(osType, ''))).to.equal(false);
    });
  });

  describe('#getHostInfoSuccessCallback', function() {

    beforeEach(function() {
      sinon.stub(c, 'parseWarnings', Em.K);
      sinon.stub(c, 'stopRegistration', Em.K);
    });

    afterEach(function() {
      c.parseWarnings.restore();
      c.stopRegistration.restore();
    });

    it('should call _setHostDataWithSkipBootstrap if skipBootstrap is true', function() {
      sinon.spy(c, '_setHostDataWithSkipBootstrap');
      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) return true;
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });
      var jsonData = {items: [{Hosts: {host_name: 'h1'}}]};
      c.getHostInfoSuccessCallback(jsonData);
      expect(c._setHostDataWithSkipBootstrap.calledOnce).to.equal(true);
      App.get.restore();
      c._setHostDataWithSkipBootstrap.restore();
    });

    it('should add repo warnings', function() {

      var jsonData = {items: [{Hosts: {host_name: 'h1'}}]};

      sinon.stub(c, 'checkHostOSType', function() {return 'not_null_value';});
      sinon.stub(c, 'checkHostDiskSpace', Em.K);
      sinon.stub(c, '_setHostDataFromLoadedHostInfo', Em.K);

      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) return false;
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });

      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });

      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('repoCategoryWarnings.length')).to.equal(1);
      expect(c.get('repoCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);

      c.checkHostOSType.restore();
      c.checkHostDiskSpace.restore();
      c._setHostDataFromLoadedHostInfo.restore();
      App.get.restore();
    });

    it('should add disk warnings', function() {

      var jsonData = {items: [{Hosts: {host_name: 'h1'}}]};

      sinon.stub(c, 'checkHostDiskSpace', function() {return 'not_null_value';});
      sinon.stub(c, 'checkHostOSType', Em.K);
      sinon.stub(c, '_setHostDataFromLoadedHostInfo', Em.K);

      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) return false;
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });

      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });

      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('diskCategoryWarnings.length')).to.equal(1);
      expect(c.get('diskCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);

      c.checkHostOSType.restore();
      c.checkHostDiskSpace.restore();
      c._setHostDataFromLoadedHostInfo.restore();
      App.get.restore();
    });

  });

  describe('#_setHostDataWithSkipBootstrap', function() {
    it('should set mock-data', function() {
      var host = Em.Object.create({});
      c._setHostDataWithSkipBootstrap(host);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('memory')).to.equal('2000000.00');
      expect(host.get('disk_info.length')).to.equal(4);
    });
  });

  describe('#_setHostDataFromLoadedHostInfo', function() {
    it('should set data from hostInfo', function() {
      var host = Em.Object.create(),
        hostInfo = {
          Hosts: {
            cpu_count: 2,
            total_mem: 12345,
            os_type: 't1',
            os_arch: 'os1',
            ip: '0.0.0.0',
            disk_info: [
              {mountpoint: '/boot'},
              {mountpoint: '/usr'},
              {mountpoint: '/no-boot'},
              {mountpoint: '/boot'}
            ]
          }
        };
      c._setHostDataFromLoadedHostInfo(host, hostInfo);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('os_type')).to.equal('t1');
      expect(host.get('os_arch')).to.equal('os1');
      expect(host.get('ip')).to.equal('0.0.0.0');
      expect(host.get('memory')).to.equal('12345.00');
      expect(host.get('disk_info.length')).to.equal(2);
    });
  });

  describe('#getJDKName', function() {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    it('should do proper request to ambari-server', function() {
      c.getJDKName();
      expect($.ajax.args[0][0].type).to.contain('GET');
      expect($.ajax.args[0][0].url).to.contain('/services/AMBARI/components/AMBARI_SERVER?fields=RootServiceComponents/properties/jdk.name,RootServiceComponents/properties/java.home,RootServiceComponents/properties/jdk_location');
    });

  });

  describe('#getJDKNameSuccessCallback', function() {

    it('should set proper data to controller properties', function() {

      var expected = {
          name: 'name',
          home: 'home',
          location: 'location'
        },
        data = {
        RootServiceComponents: {
          properties: {
            'jdk.name': expected.name,
            'java.home': expected.home,
            'jdk_location': expected.location
          }
        }
      };

      c.getJDKNameSuccessCallback(data);
      expect(c.get('needJDKCheckOnHosts')).to.equal(false);
      expect(c.get('jdkLocation')).to.equal(expected.location);
      expect(c.get('javaHome')).to.equal(expected.home);
    });

  });

  describe('#doCheckJDK', function() {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(c, 'setRegistrationInProgressOnce', Em.K);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      c.setRegistrationInProgressOnce.restore();
      App.get.restore();
    });

    it('should do proper request to the ambari-server', function() {

      var bootHosts = [{name: 'n1'}, {name: 'n2'}],
        javaHome = '/java',
        jdkLocation = '/jdk';
      c.reopen({
        bootHosts: bootHosts,
        javaHome: javaHome,
        jdkLocation: jdkLocation
      });
      c.doCheckJDK();
      var request = $.ajax.args[0][0], data = JSON.parse(request.data);
      expect(request.type).to.equal('POST');
      expect(request.url).to.contain('/requests');
      expect(data.RequestInfo.parameters.java_home).to.equal(javaHome);
      expect(data.RequestInfo.parameters.jdk_location).to.equal(jdkLocation);
      expect(data['Requests/resource_filters'][0].hosts).to.equal('n1,n2');
    });

  });

  describe('#doCheckJDKsuccessCallback', function() {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    it('should set jdkRequestIndex if data provided', function() {

      var data = {
          href: '/a/b/c'
        },
        expected = 'c';
      c.set('jdkRequestIndex', null);
      c.doCheckJDKsuccessCallback(data);
      expect(c.get('jdkRequestIndex')).to.equal(expected);
    });

    it('should set isJDKWarningsLoaded to true if jdkCategoryWarnings is not null', function() {

      var data = null,
        expected = true;
      c.set('isJDKWarningsLoaded', false);
      c.set('jdkCategoryWarnings', {});
      c.doCheckJDKsuccessCallback(data);
      expect(c.get('isJDKWarningsLoaded')).to.equal(expected);
    });

    it('should do propert request to ambari-server', function() {

      var data = null,
        jdkRequestIndex = 'jdkRequestIndex',
        url = '/requests/' + jdkRequestIndex + '?fields=*,tasks/Tasks/host_name,tasks/Tasks/status,tasks/Tasks/structured_out';
      c.set('jdkRequestIndex', jdkRequestIndex);
      c.set('jdkCategoryWarnings', null);
      c.doCheckJDKsuccessCallback(data);
      expect($.ajax.args[0][0].type).to.equal('GET');
      expect($.ajax.args[0][0].url).to.contain(url);
    });

  });

  describe('#doCheckJDKerrorCallback', function() {

    it('should set isJDKWarningsLoaded to true', function() {

      c.set('isJDKWarningsLoaded', false);
      c.doCheckJDKerrorCallback();
      c.set('isJDKWarningsLoaded', true);

    });

  });

  describe('#parseJDKCheckResults', function() {

    beforeEach(function() {
      sinon.stub(c, 'doCheckJDKsuccessCallback', Em.K);
    });

    afterEach(function() {
      c.doCheckJDKsuccessCallback.restore();
    });

    it('should set jdkCategoryWarnings to null if no data', function() {

      var data = {Requests: {}};
      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      expect(c.get('jdkCategoryWarnings')).to.be.null;

    });

    it('should parse warnings (1)', function() {

      var data = {
        Requests: {
          end_time: 1
        },
        tasks: []
      };

      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      expect(c.get('jdkCategoryWarnings')).to.eql([]);

    });

    it('should parse warnings (2)', function() {

      var data = {
        Requests: {
          end_time: 1
        },
        tasks: [
          {
            Tasks: {
              host_name: 'h1',
              structured_out: {
                java_home_check: {
                  exit_code: 1
                }
              }
            }
          },
          {
            Tasks: {
              host_name: 'h2',
              structured_out: {
                java_home_check: {
                  exit_code: 0
                }
              }
            }
          }
        ]
      };

      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      var result = c.get('jdkCategoryWarnings');
      expect(result.length).to.equal(1);
      expect(result[0].hostsNames).to.eql(['h1']);

    });

  });

});

});

;require.register("test/controllers/wizard/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
var modelSetup = require('test/init_model_test');

require('controllers/wizard/step4_controller');
describe('App.WizardStep4Controller', function () {

  var services = [
    'HDFS', 'MAPREDUCE', 'NAGIOS', 'GANGLIA', 'OOZIE', 'HIVE', 'HBASE', 'PIG', 'SCOOP', 'ZOOKEEPER',
    'YARN', 'MAPREDUCE2', 'FALCON', 'TEZ', 'STORM'
  ];

  var controller = App.WizardStep4Controller.create();

  var generateSelectedServicesContent = function(selectedServiceNames) {
    var allServices = services.slice(0);
    modelSetup.setupStackServiceComponent();
    if (selectedServiceNames.contains('GLUSTERFS')) allServices.push('GLUSTERFS');
    allServices = allServices.map(function(serviceName) {
      return [Ember.Object.create({
        'serviceName': serviceName,
        'isSelected': false,
        'canBeSelected': true,
        'isInstalled': false,
        isPrimaryDFS: serviceName == 'HDFS',
        isDFS: ['HDFS','GLUSTERFS'].contains(serviceName),
        isMonitoringService: ['NAGIOS','GANGLIA'].contains(serviceName),
        requiredServices: App.StackService.find(serviceName).get('requiredServices'),
        displayNameOnSelectServicePage: App.format.role(serviceName),
        coSelectedServices: function() {
          return App.StackService.coSelected[this.get('serviceName')] || [];
        }.property('serviceName')
      })];
    }).reduce(function(current, prev) { return current.concat(prev); });

    selectedServiceNames.forEach(function(serviceName) {
      allServices.findProperty('serviceName', serviceName).set('isSelected', true);
    });

    return allServices;
  };

  services.forEach(function(serviceName, index){
    controller.pushObject(Ember.Object.create({
      'serviceName':serviceName, 'isSelected': true, 'isHiddenOnSelectServicePage': false, 'isInstalled': false, 'isDisabled': 'HDFS' === serviceName, isDFS: 'HDFS' === serviceName
    }));
  });

  describe('#isSubmitDisabled', function () {
    it('should return false if at least one selected service is not installed', function () {
      expect(controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should return true if all selected services are already installed', function () {
      controller.setEach('isInstalled', true);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isSubmitDisabled')).to.equal(true);
    });
  });

  describe('#isAll', function () {
    it('should return true if all services are selected', function () {
      controller.setEach('isInstalled', false);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      expect(controller.get('isAll')).to.equal(true);
    });

    it('should return false if at least one service is not selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isAll')).to.equal(false);
    });
  });

  describe('#isMinimum', function () {
    it('should return true if there are no services selected, except disabled', function () {
      controller.setEach('isSelected', false);
      expect(controller.get('isMinimum')).to.equal(true);
    });

    it('should return false if at least one service is selected, except disabled', function () {
      controller.findProperty('serviceName', 'MAPREDUCE').set('isSelected', true);
      expect(controller.get('isMinimum')).to.equal(false);
    });
  });

  describe('#selectAll()', function () {
    it('should select all services', function () {
      controller.setEach('isSelected', false);
      controller.selectAll();
      expect(controller.filterProperty('canBeSelected', true).everyProperty('isSelected', true)).to.equal(true);
    });
  });

  describe('#selectMinimum()', function () {
    it('should set isSelected false for all services', function () {
      controller.setEach('isSelected', true);
      controller.selectMinimum();
      expect(controller.findProperty('serviceName', 'HDFS').get('isSelected')).to.equal(false);
      expect(controller.filterProperty('isDisabled', false).everyProperty('isSelected', false)).to.equal(true);
    });
  });

  describe('#multipleDFSs()', function () {
    it('should return true if HDFS is selected and GLUSTERFS is selected', function () {
      controller.set('content', generateSelectedServicesContent(['HDFS', 'GLUSTERFS']));
      expect(controller.multipleDFSs()).to.equal(true);
    });
    it('should return false if HDFS is not selected and GLUSTERFS is selected', function () {
      controller.set('content', generateSelectedServicesContent(['GLUSTERFS']));
      expect(controller.multipleDFSs()).to.equal(false);
    });
    it('should return false if HDFS is selected and GLUSTERFS is not selected', function () {
      controller.set('content', generateSelectedServicesContent(['HDFS']));
      expect(controller.multipleDFSs()).to.equal(false);
    });
  });

  describe('#setGroupedServices()', function () {
    var testCases = [
      {
        title: 'should set MapReduce2 isSelected to true when YARN is selected',
        condition: {
          'YARN': true,
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true
        }
      },
      {
        title: 'should set MapReduce2 isSelected to false when YARN is not selected',
        condition: {
          'YARN': false,
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to true when YARN is selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'YARN': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to false when YARN is not selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'YARN': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false
        }
      }
    ];

    testCases.forEach(function(testCase){
      it(testCase.title, function () {
        controller.clear();
        for(var id in testCase.condition) {
          controller.pushObject(Ember.Object.create({
            'serviceName':id, 'isSelected': testCase.condition[id], 'canBeSelected': true, 'isInstalled': false,
            coSelectedServices: function() {
              return App.StackService.coSelected[this.get('serviceName')] || [];
            }.property('serviceName')
          }));
        }
        controller.setGroupedServices();
        for(var service in testCase.result) {
          expect(controller.findProperty('serviceName', service).get('isSelected')).to.equal(testCase.result[service]);
        }
      });
    }, this);
  });

  describe('#addValidationError()', function() {
    var tests = [
      {
        errorObjects: [
          {
            id: 'serviceCheck_ZOOKEEPER',
            shouldBeAdded: true
          },
          {
            id: 'serviceCheck_YARN',
            shouldBeAdded: true
          }
        ],
        expectedIds: ['serviceCheck_ZOOKEEPER', 'serviceCheck_YARN']
      },
      {
        errorObjects: [
          {
            id: 'fsCheck',
            shouldBeAdded: true
          },
          {
            id: 'fsCheck',
            shouldBeAdded: false
          }
        ],
        expectedIds: ['fsCheck']
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    tests.forEach(function(test) {
      var message = 'Erorrs {0} thrown. errorStack property should contains ids: {1}'
        .format(test.errorObjects.mapProperty('id').join(', '), test.expectedIds.join(', '));
      it(message, function() {
        test.errorObjects.forEach(function(errorObject) {
          expect(controller.addValidationError(errorObject)).to.equal(errorObject.shouldBeAdded);
        });
        expect(controller.get('errorStack').mapProperty('id')).to.eql(test.expectedIds);
      });
    })
  });

  describe('#validate()', function() {
    var tests = [
      {
        services: ['HDFS','ZOOKEEPER'],
        errorsExpected: ['monitoringCheck']
      },
      {
        services: ['ZOOKEEPER'],
        errorsExpected: ['monitoringCheck']
      },
      {
        services: ['HDFS'],
        errorsExpected: ['serviceCheck_ZOOKEEPER', 'monitoringCheck']
      },
      {
        services: ['HDFS', 'TEZ', 'ZOOKEEPER'],
        errorsExpected: ['serviceCheck_YARN', 'monitoringCheck']
      },
      {
        services: ['HDFS', 'ZOOKEEPER', 'FALCON', 'NAGIOS'],
        errorsExpected: ['serviceCheck_OOZIE', 'monitoringCheck']
      },
      {
        services: ['HDFS', 'ZOOKEEPER', 'GANGLIA', 'NAGIOS', 'HIVE'],
        errorsExpected: ['serviceCheck_YARN']
      },
      {
        services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE'],
        errorsExpected: ['serviceCheck_YARN', 'multipleDFS', 'monitoringCheck']
      },
      {
        services: ['HDFS','ZOOKEEPER', 'NAGIOS', 'GANGLIA'],
        errorsExpected: []
      }
    ];

    tests.forEach(function(test) {
      var message = '{0} selected validation should be {1}, errors with ids: {2} present'
        .format(test.services.join(','), !!test.validationPassed ? 'passed' : 'failed', test.errorsExpected.join(','));
      it(message, function() {
        controller.clear();
        controller.set('content', generateSelectedServicesContent(test.services));
        controller.validate();
        expect(controller.get('errorStack').mapProperty('id')).to.be.eql(test.errorsExpected);
      });
    })
  });

  describe('#onPrimaryPopupCallback()', function() {
    var c;
    var tests = [
      {
        services: ['HDFS','ZOOKEEPER'],
        confirmPopupCount: 1,
        errorsExpected: ['monitoringCheck']
      },
      {
        services: ['ZOOKEEPER'],
        confirmPopupCount: 1,
        errorsExpected: ['monitoringCheck']
      },
      {
        services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE'],
        confirmPopupCount: 3,
        errorsExpected: ['serviceCheck_YARN', 'serviceCheck_TEZ', 'multipleDFS', 'monitoringCheck']
      },
      {
        services: ['HDFS','ZOOKEEPER', 'NAGIOS', 'GANGLIA'],
        confirmPopupCount: 0,
        errorsExpected: []
      }
    ];

    beforeEach(function() {
      c = App.WizardStep4Controller.create({});
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'submit', Em.K);
      sinon.spy(c, 'onPrimaryPopupCallback');
    });

    afterEach(function() {
      App.router.send.restore();
      c.submit.restore();
      c.onPrimaryPopupCallback.restore();
    });


    tests.forEach(function(test) {
      var message = 'Selected services: {0}. {1} errors should be confirmed'
        .format(test.services.join(', '), test.confirmPopupCount);

      it(message, function() {
        var runValidations = function() {
          c.serviceDependencyValidation();
          c.fileSystemServiceValidation();
          c.serviceMonitoringValidation();
        }

        c.set('content', generateSelectedServicesContent(test.services));
        runValidations();
        // errors count validation
        expect(c.get('errorStack.length')).to.equal(test.confirmPopupCount);
        // if errors detected than it should be shown
        if (test.errorsExpected) {
          test.errorsExpected.forEach(function(error, index, errors) {
            // validate current error
            var currentErrorObject = c.get('errorStack').findProperty('isShown', false);
            if (currentErrorObject) {
              expect(error).to.be.equal(currentErrorObject.id);
              // show current error
              var popup = c.showError(currentErrorObject);
              // submit popup
              popup.onPrimary();
              // onPrimaryPopupCallback should be called
              expect(c.onPrimaryPopupCallback.called).to.equal(true);
              // submit called
              expect(c.submit.called).to.equal(true);
              if (c.get('errorStack').length) {
                // current error isShown flag changed to true
                expect(currentErrorObject.isShown).to.equal(true);
              }
              runValidations();
            }
          });
        }
      });
    });

  });

  describe('#needToAddServicePopup', function() {
    Em.A([
        {
          m: 'one service',
          services: {selected: true, serviceName: 's1'},
          content: [Em.Object.create({serviceName: 's1', isSelected: false})],
          e: [true]
        },
        {
          m: 'many services',
          services: [{selected: true, serviceName: 's1'}, {selected: false, serviceName: 's2'}],
          content: [Em.Object.create({serviceName: 's1', isSelected: false}),
            Em.Object.create({serviceName: 's2', isSelected: true})],
          e: [true, false]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(controller, 'submit', Em.K);
          controller.set('content', test.content);
          controller.needToAddServicePopup(test.services, '').onPrimary();
          expect(controller.submit.calledOnce).to.equal(true);
          expect(controller.mapProperty('isSelected')).to.eql(test.e);
          controller.submit.restore();
        });
      });
  });

  describe('#submit', function() {
    var c;
    var tests = [
      {
        isSubmitDisabled: true,
        validate: false,
        userCanProceed: false
      },
      {
        isSubmitDisabled: false,
        validate: false,
        userCanProceed: false
      },
      {
        isSubmitDisabled: false,
        validate: true,
        userCanProceed: true
      }
    ];

    beforeEach(function() {
      c = App.WizardStep4Controller.create();
      sinon.stub(App.router, 'send', Em.K);
    });

    afterEach(function() {
      App.router.send.restore();
    });

    tests.forEach(function(test) {
      var messageFormat = [
        test.isSubmitDisabled ? 'disabled' : 'enabled',
        test.validate ? 'success' : 'failed',
        test.userCanProceed ? '' : 'not'
      ];
      var message = String.prototype.format.apply('Submit btn: {0}. Validation: {1}. Can{2} move to the next step.', messageFormat);

      it(message, function() {
        c.reopen({
          isSubmitDisabled: test.isSubmitDisabled,
          validate: function() { return test.validate; }
        });
        c.clear();
        c.submit();

        expect(App.router.send.calledOnce).to.equal(test.userCanProceed);
      });

    })
  });

  describe('#dependencies', function() {
    var tests = [
      {
        services: ['HDFS'],
        dependencies: ['ZOOKEEPER'] 
      },
      {
        services: ['STORM'],
        dependencies: ['ZOOKEEPER'] 
      }
    ];
    tests.forEach(function(test) {
      var message = '{0} dependency should be {1}'.format(test.services.join(','), test.dependencies.join(','));
      it(message, function() {
        
        controller.clear();
        controller.set('content', generateSelectedServicesContent(test.services));
        
        var dependentServicesTest = [];
        
        test.services.forEach(function(serviceName) {
          var service = controller.filterProperty('serviceName', serviceName);
          service.forEach(function(item) {
            var dependencies = item.get('requiredServices');
            if(!!dependencies) {
              dependentServicesTest = dependentServicesTest.concat(dependencies);
            }
          });
        });

        expect(dependentServicesTest).to.be.eql(test.dependencies);
      });
    })
  });

});

});

;require.register("test/controllers/wizard/step5_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('controllers/wizard/step5_controller');
var modelSetup = require('test/init_model_test');
require('utils/ajax/ajax');
var c;
describe('App.WizardStep5Controller', function () {

  beforeEach(function () {
    c = App.WizardStep5Controller.create();
  });

  var controller = App.WizardStep5Controller.create();
  controller.set('content', {});
  var cpu = 2, memory = 4;

  controller.set('content', {});

  describe('#isReassignWizard', function () {
    it('true if content.controllerName is reassignMasterController', function () {
      controller.set('content.controllerName', 'reassignMasterController');
      expect(controller.get('isReassignWizard')).to.equal(true);
    });
    it('false if content.controllerName is not reassignMasterController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isReassignWizard')).to.equal(false);
    });
  });

  describe('#isAddServiceWizard', function () {
    it('true if content.controllerName is addServiceController', function () {
      controller.set('content.controllerName', 'addServiceController');
      expect(controller.get('isAddServiceWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addServiceController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddServiceWizard')).to.equal(false);
    });
  });

  describe('#sortHosts', function () {

    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({memory: 4, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 3, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'memory',
        e: [1, 2, 3, 4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 4, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 3, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'cpu',
        e: [1, 2, 3, 4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 1}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host1', id: 4})
        ],
        m: 'host_name',
        e: [4, 2, 3, 1]
      },
      {
        hosts: [
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 4})
        ],
        m: 'mix',
        e: [1, 2, 4, 3]
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        var hosts = Em.copy(test.hosts);
        controller.sortHosts(hosts);
        expect(Em.A(hosts).mapProperty('id')).to.eql(test.e);
      });
    });

  });

  describe('#renderHostInfo', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'INIT'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'INIT'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'INIT'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'INIT'}
        },
        m: 'no one host is REGISTERED',
        e: []
      },
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, memory',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 4, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 3, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, cpu',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, host_name',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 2, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'INIT'},
          h3: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'INIT'}
        },
        m: 'mix',
        e: ['host1', 'host4']
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content', {hosts: test.hosts});
        controller.renderHostInfo();
        var r = controller.get('hosts');
        expect(Em.A(r).mapProperty('host_name')).to.eql(test.e);
      });
    });

  });

  describe('#last', function () {

    var tests = Em.A([
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components exists',
        c: 'c1',
        e: 2
      },
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components don\'t exists',
        c: 'c3',
        e: null
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('selectedServicesMasters', test.selectedServicesMasters);
        if (!Em.isNone(test.e)) {
          expect(controller.last(test.c).indx).to.equal(test.e);
        }
        else {
          expect(Em.isNone(controller.last(test.c))).to.equal(true);
        }
      })
    });

  });

  describe('#remainingHosts', function () {
    it('should show count of hosts without masters', function () {
      c.reopen({masterHostMapping: [
        {}
      ]});
      c.set('hosts', [
        {},
        {},
        {}
      ]);
      expect(c.get('remainingHosts')).to.equal(2);
    });
  });

  describe('#clearStep', function () {
    var tests = Em.A([
      {p: 'hosts'},
      {p: 'selectedServicesMasters'},
      {p: 'servicesMasters'}
    ]);
    tests.forEach(function (test) {
      it('should cleanup ' + test.p, function () {
        c.set(test.p, [Em.Object.create({}), Em.Object.create({})]);
        c.clearStep();
        expect(c.get(test.p).length).to.equal(0);
      });
    });
  });

  describe('#updateComponent', function () {
    var tests = Em.A([
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: true, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'}),
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service is installed',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service not installed, but all host already have provided component',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({}),
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service not installed, not all host already have provided component',
        e: {
          showAddControl: true,
          showRemoveControl: true
        }
      },
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({}),
          Em.Object.create({})
        ]),
        controllerName: 'reassignMasterController',
        m: 'service not installed, not all host already have provided component, but is reassignMasterController',
        e: {
          showAddControl: false,
          showRemoveControl: false
        }
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        sinon.stub(App.StackService, 'find', function () {
          return test.services;
        });
        c.reopen({
          content: Em.Object.create({
            controllerName: test.controllerName
          }),
          selectedServicesMasters: test.selectedServicesMasters,
          hosts: test.hosts
        });
        c.updateComponent(test.componentName);
        App.StackService.find.restore();
        Em.keys(test.e).forEach(function (k) {
          expect(c.last(test.componentName).get(k)).to.equal(test.e[k]);
        });

      });
    });
  });

  describe('#renderComponents', function () {
    var tests = Em.A([
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: false, isSelected: true})
        ]),
        controllerName: 'reassignMasterController',
        m: 'One component',
        isHaEnabled: false,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          isInstalled: [false],
          serviceComponentId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: false, isSelected: true})
        ]),
        controllerName: 'addServiceController',
        m: 'One component, service is not installed',
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          serviceComponentId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: true})
        ]),
        controllerName: 'addServiceController',
        m: 'Two components, but service is installed',
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          showRemoveControl: [false, false],
          serviceComponentId: [1, 2]
        }
      }
    ]);
    tests.forEach(function (test) {
      beforeEach(function () {
        App.reopen({isHaEnabled: test.isHaEnabled});
      });
      it(test.m, function () {
        modelSetup.setupStackServiceComponent();
        sinon.stub(App.StackService, 'find', function () {
          return test.services;
        });
        App.set('isHaEnabled', test.isHaEnabled);
        c.reopen({
          content: Em.Object.create({
            services: test.services,
            controllerName: test.controllerName,
            reassign: {component_name: test.component_name}
          })
        });
        c.renderComponents(test.masterComponents);
        App.StackService.find.restore();
        modelSetup.cleanStackServiceComponent();
        expect(c.get('selectedServicesMasters').mapProperty('component_name')).to.eql(test.e.selectedServicesMasters);
        expect(c.get('servicesMasters').mapProperty('component_name')).to.eql(test.e.servicesMasters);
        expect(c.get('selectedServicesMasters').mapProperty('showRemoveControl')).to.eql(test.e.showRemoveControl);
        expect(c.get('selectedServicesMasters').mapProperty('serviceComponentId')).to.eql(test.e.serviceComponentId);
        if (c.get('isReasignController')) {
          expect(c.get('servicesMasters').mapProperty('isInstalled')).to.eql(test.e.isInstalled);
        }
      });
    });
  });

  describe('#assignHostToMaster', function () {
    var tests = Em.A([
        {
          componentName: 'c1',
          selectedHost: 'h2',
          serviceComponentId: '1',
          e: {
            indx: 0
          }
        },
        {
          componentName: 'c2',
          selectedHost: 'h3',
          serviceComponentId: '2',
          e: {
            indx: 3
          }
        },
        {
          componentName: 'c3',
          selectedHost: 'h1',
          e: {
            indx: 2
          }
        },
        {
          componentName: 'c2',
          selectedHost: 'h4',
          e: {
            indx: 1
          }
        }
      ]),
      selectedServicesMasters = Em.A([
        Em.Object.create({component_name: 'c1', serviceComponentId: '1', selectedHost: 'h1'}),
        Em.Object.create({component_name: 'c2', serviceComponentId: '1', selectedHost: 'h1'}),
        Em.Object.create({component_name: 'c3', serviceComponentId: '1', selectedHost: 'h3'}),
        Em.Object.create({component_name: 'c2', serviceComponentId: '2', selectedHost: 'h2'})
      ]);

    tests.forEach(function (test) {
      it(test.componentName + ' ' + test.selectedHost + ' ' + test.serviceComponentId, function () {
        c.set('selectedServicesMasters', selectedServicesMasters);
        c.assignHostToMaster(test.componentName, test.selectedHost, test.serviceComponentId);
        expect(c.get('selectedServicesMasters').objectAt(test.e.indx).get('selectedHost')).to.equal(test.selectedHost);
      })
    });
  });

  describe('#removeComponent', function () {
    var tests = Em.A([
      {
        componentName: 'c1',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER'})
        ]),
        hosts: [],
        m: 'component is only 1',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [
          {},
          {}
        ],
        m: 'two components, add allowed, remove not allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [
          {}
        ],
        m: 'two components, add not allowed, remove not allowed',
        e: true,
        showAddControl: false,
        showRemoveControl: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 3, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: true})
        ]),
        hosts: [
          {},
          {}
        ],
        m: 'three components, add not allowed, remove allowed',
        e: true,
        showAddControl: false,
        showRemoveControl: true
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 3, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: true})
        ]),
        hosts: [
          {},
          {},
          {}
        ],
        m: 'three components, add allowed, remove allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: true
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.removeComponent(test.componentName, test.serviceComponentId)).to.equal(test.e);
        if (test.e) {
          expect(c.get('selectedServicesMasters.lastObject.showRemoveControl')).to.equal(test.showRemoveControl);
          expect(c.get('selectedServicesMasters.lastObject.showAddControl')).to.equal(test.showAddControl);
        }
      })
    });
  });

  describe('#addComponent', function () {
    var tests = Em.A([
      {
        componentName: 'c1',
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER'})
        ]),
        hosts: [],
        m: 'one component, 0 hosts',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [Em.Object.create({}), Em.Object.create({})],
        m: 'two components, two hosts',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [Em.Object.create({}), Em.Object.create({}), Em.Object.create({})],
        m: 'two components, 3 hosts',
        e: true
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.addComponent(test.componentName)).to.equal(test.e);
      });
    });
  });

  describe('#title', function () {
    it('should be custom title for reassignMasterController', function () {
      c.set('content', {controllerName: 'reassignMasterController'});
      expect(c.get('title')).to.equal(Em.I18n.t('installer.step5.reassign.header'));
    });
    it('should be default for other', function () {
      c.set('content', {controllerName: 'notReassignMasterController'});
      expect(c.get('title')).to.equal(Em.I18n.t('installer.step5.header'));
    });
  });

  describe('#masterHostMapping', function () {
    Em.A([
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h2'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}}),
            Em.Object.create({host_name: 'h2', host_info: {}})
          ],
          m: 'Two hosts',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [
              {},
              {}
            ]},
            {host_name: 'h2', hostInfo: {}, masterServices: [
              {}
            ]}
          ]
        },
        {
          selectedServicesMasters: [],
          hosts: [],
          m: 'No hosts',
          e: []
        },
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}})
          ],
          m: 'One host',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [
              {},
              {}
            ]}
          ]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.reopen({
            selectedServicesMasters: test.selectedServicesMasters,
            hosts: test.hosts
          });
          var result = c.get('masterHostMapping');
          expect(result.length).to.equal(test.e.length);
          result.forEach(function (r, i) {
            expect(r.get('host_name')).to.equal(test.e[i].host_name);
            expect(r.get('masterServices.length')).to.equal(test.e[i].masterServices.length);
            expect(r.get('hostInfo')).to.be.an.object;
          });
        });
      });
  });

  describe('#anyError', function () {

    Em.A([
        {
          servicesMasters: [
            Em.Object.create({errorMessage: 'some message'}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: [],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: ''}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: [],
          e: false
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: 'some message'}),
            Em.Object.create({errorMessage: 'some message 2'})
          ],
          generalErrorMessages: ['some message'],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: ''}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: ['some message'],
          e: true
        }
      ]).forEach(function (test, i) {
        it('test #' + i.toString(), function () {
          c.setProperties({
            servicesMasters: test.servicesMasters,
            generalErrorMessages: test.generalErrorMessages
          });
          expect(c.get('anyError')).to.equal(test.e);
        });
      });

  });

  describe('#anyWarning', function () {

    Em.A([
        {
          servicesMasters: [
            Em.Object.create({warnMessage: 'some message'}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: [],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: ''}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: [],
          e: false
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: 'some message'}),
            Em.Object.create({warnMessage: 'some message 2'})
          ],
          generalWarningMessages: ['some message'],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: ''}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: ['some message'],
          e: true
        }
      ]).forEach(function (test, i) {
        it('test #' + i.toString(), function () {
          c.setProperties({
            servicesMasters: test.servicesMasters,
            generalWarningMessages: test.generalWarningMessages
          });
          expect(c.get('anyWarning')).to.equal(test.e);
        });
      });

  });

  describe('#clearRecommendations', function () {

    it('should clear content.recommendations', function () {

      c.set('content', {recommendations: {'s': {}}});
      c.clearRecommendations();
      expect(c.get('content.recommendations')).to.be.null;

    });

  });

  describe('#updateIsSubmitDisabled', function () {

    beforeEach(function () {
      c.set('selectedServicesMasters', [
        {isInstalled: false}
      ]);
    });

    it('shouldn\'t change submitDisabled if thereIsNoMasters returns false', function () {

      c.set('selectedServicesMasters', [
        {isInstalled: true}
      ]);
      c.set('submitDisabled', false);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(false);

    });

    it('should check servicesMasters.@each.isHostNameValid if useServerValidation is false', function () {

      c.set('useServerValidation', false);
      c.set('servicesMasters', [
        {isHostNameValid: false},
        {isHostNameValid: true}
      ]);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(true);

      c.set('servicesMasters', [
        {isHostNameValid: true},
        {isHostNameValid: true}
      ]);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(false);

    });


  });

  describe('#isHostNameValid', function () {

    beforeEach(function () {
      c.setProperties({
        hosts: [
          {host_name: 'h1'},
          {host_name: 'h2'},
          {host_name: 'h3'}
        ],
        selectedServicesMasters: [
          {component_name: 'c1', selectedHost: 'h1'},
          {component_name: 'c2', selectedHost: 'h2'},
          {component_name: 'c3', selectedHost: 'h3'},
          {component_name: 'c3', selectedHost: 'h1'}
        ]
      });
    });

    Em.A([
        {
          componentName: 'c1',
          selectedHost: '   ',
          m: 'empty hostName is invalid',
          e: false
        },
        {
          componentName: 'c1',
          selectedHost: 'h4',
          m: 'hostName not exists',
          e: false
        },
        {
          componentName: 'c4',
          selectedHost: 'h3',
          m: 'component not exists on host',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          expect(c.isHostNameValid(test.componentName, test.selectedHost)).to.equal(test.e);
        });
      });

  });

  describe('#createComponentInstallationObject', function () {

    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });

    Em.A([
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          controllerName: 'reassignMasterController',
          savedComponent: {
            hostName: 'h2',
            isInstalled: true
          },
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: true})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h2',
            isInstalled: true,
            isServiceCoHost: false
          }
        },
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          controllerName: 'installerController',
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: false})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h1',
            isInstalled: false,
            isServiceCoHost: false
          }
        },
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          controllerName: 'installerController',
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: true})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h1',
            isInstalled: false,
            isServiceCoHost: true
          }
        }
      ]).forEach(function (test, i) {
        it('test #' + i, function () {
          sinon.stub(App.StackServiceComponent, 'find', function () {
            return test.stackServiceComponents;
          });
          c.set('content', {controllerName: test.controllerName});
          expect(c.createComponentInstallationObject(test.fullComponent, test.hostName, test.savedComponent)).to.eql(test.e);
        });
      });

  });

  describe('#createComponentInstallationObjects', function () {

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return [
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c1', serviceName: 's1'}),
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c2', serviceName: 's2'}),
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c4', serviceName: 's2'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c1', serviceName: 's1'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c2', serviceName: 's2'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c4', serviceName: 's2'})
        ];
      });

      c.set('content', {
        masterComponentHosts: [],
        services: [
          {serviceName: 's1', isSelected: true, isInstalled: false},
          {serviceName: 's2', isSelected: true, isInstalled: false}
        ],
        recommendations: {
          "blueprint": {
            "host_groups": [
              {
                "name": "host-group-1",
                "components": [ {"name": "c1"}, {"name": "c2"} ]
              },
              {
                "name": "host-group-2",
                "components": [ {"name": "c1"}, {"name": "c2"} ]
              },
              {
                "name": "host-group-3",
                "components": [ {"name": "c1"} ]
              }
            ]
          },
          "blueprint_cluster_binding": {
            "host_groups": [
              {
                "name": "host-group-1",
                "hosts": [ {"fqdn": "h1"} ]
              },
              {
                "name": "host-group-2",
                "hosts": [ {"fqdn": "h2"} ]
              },
              {
                "name": "host-group-3",
                "hosts": [ {"fqdn": "h3"} ]
              }
            ]
          }
        }
      });

    });

    afterEach(function() {
      App.StackServiceComponent.find.restore();
    });

    it('simple map without nothing stored/saved etc', function() {
      var r = c.createComponentInstallationObjects();
      expect(r.mapProperty('component_name')).to.eql(['c1', 'c2', 'c1', 'c2', 'c1']);
      expect(r.mapProperty('serviceId')).to.eql(['s1', 's2', 's1', 's2', 's1']);
      expect(r.mapProperty('selectedHost')).to.eql(['h1', 'h1', 'h2', 'h2', 'h3']);
    });

    it('some saved components exist', function() {
      c.set('content.controllerName', 'addServiceController');
      c.get('multipleComponents').push('c4');
      c.set('content.masterComponentHosts', [
        {hostName: 'h3', component: 'c4'}
      ]);
      c.get('content.recommendations.blueprint.host_groups')[2].components.push({name: 'c4'});
      var r = c.createComponentInstallationObjects();
      expect(r.mapProperty('component_name')).to.eql(['c1', 'c2', 'c1', 'c2', 'c1', 'c4']);
      expect(r.mapProperty('serviceId')).to.eql(['s1', 's2', 's1', 's2', 's1', 's2']);
      expect(r.mapProperty('selectedHost')).to.eql(['h1', 'h1', 'h2', 'h2', 'h3', 'h3']);
    });

  });

  describe('#getCurrentBlueprint', function () {

    beforeEach(function() {
      sinon.stub(c, 'getCurrentSlaveBlueprint', function() {
        return {
          blueprint_cluster_binding: {
            host_groups: []
          },
          blueprint: {
            host_groups: []
          }
        };
      });
    });

    afterEach(function() {
      c.getCurrentSlaveBlueprint.restore();
    });

    it('should map masterHostMapping', function () {

      c.reopen({masterHostMapping: [
        {host_name: 'h1', hostInfo:{}, masterServices: [
          {serviceId: 's1', component_name: 'c1'},
          {serviceId: 's2', component_name: 'c2'}
        ]},
        {host_name: 'h2', hostInfo:{}, masterServices: [
          {serviceId: 's1', component_name: 'c1'},
          {serviceId: 's3', component_name: 'c3'}
        ]}
      ]});

      var r = c.getCurrentBlueprint();
      expect(r).to.eql({"blueprint": {"host_groups": [
          {"name": "host-group-1", "components": [
            {"name": "c1"},
            {"name": "c2"}
          ]},
          {"name": "host-group-2", "components": [
            {"name": "c1"},
            {"name": "c3"}
          ]}
        ]}, "blueprint_cluster_binding": {"host_groups": [
          {"name": "host-group-1", "hosts": [
            {"fqdn": "h1"}
          ]},
          {"name": "host-group-2", "hosts": [
            {"fqdn": "h2"}
          ]}
        ]}}
      );
    });

  });

  describe('#updateValidationsSuccessCallback', function() {

    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find', function() {
        return [];
      });
    });

    afterEach(function() {
      App.HostComponent.find.restore();
    });

    it('should map messages to generalErrorMessages, generalWarningMessages', function() {

      var data = [
          {
            type: 'host-component',
            'component-name': 'c1',
            host: 'h1',
            level: 'ERROR',
            message: 'm1'
          },
          {
            type: 'host-component',
            'component-name': 'c2',
            host: 'h2',
            level: 'WARN',
            message: 'm2'
          },
          {
            type: 'host-component',
            'component-name': 'c3',
            host: 'h3',
            level: 'ERROR',
            message: 'm3'
          },
          {
            type: 'host-component',
            'component-name': 'c4',
            host: 'h4',
            level: 'WARN',
            message: 'm4'
          }
        ],
        servicesMasters = [
          Em.Object.create({selectedHost: 'h1', component_name: 'c1'}),
          Em.Object.create({selectedHost: 'h2', component_name: 'c2'})
        ];

      c.set('servicesMasters', servicesMasters);
      c.updateValidationsSuccessCallback({resources: [{items: data}]});

      expect(c.get('submitDisabled')).to.equal(false);
      expect(c.get('servicesMasters').findProperty('component_name', 'c1').get('errorMessage')).to.equal('m1');
      expect(c.get('servicesMasters').findProperty('component_name', 'c2').get('warnMessage')).to.equal('m2');
      expect(c.get('generalErrorMessages')).to.be.empty;
      expect(c.get('generalWarningMessages')).to.be.empty;
    });

  });

});
});

;require.register("test/controllers/wizard/step6_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('utils/helper');
require('controllers/wizard/step6_controller');
var controller,
  services = [
    Em.Object.create({
      serviceName: 'MAPREDUCE',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'YARN',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HBASE',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HDFS',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'STORM',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'FLUME',
      isSelected: true
    })
  ];
describe('App.WizardStep6Controller', function () {

  beforeEach(function () {
    controller = App.WizardStep6Controller.create();
    controller.set('content', {
      hosts: {},
      masterComponentHosts: {},
      services: services
    });

    var h = {}, m = [];
    Em.A(['host0', 'host1', 'host2', 'host3']).forEach(function (hostName) {
      var obj = Em.Object.create({
        name: hostName,
        hostName: hostName,
        bootStatus: 'REGISTERED'
      });
      h[hostName] = obj;
      m.push(obj);
    });

    controller.set('content.hosts', h);
    controller.set('content.masterComponentHosts', m);
    controller.set('isMasters', false);

  });

  describe('#isAddHostWizard', function () {
    it('true if content.controllerName is addHostController', function () {
      controller.set('content.controllerName', 'addHostController');
      expect(controller.get('isAddHostWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addHostController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddHostWizard')).to.equal(false);
    });
  });

  describe('#isInstallerWizard', function () {
    it('true if content.controllerName is addHostController', function () {
      controller.set('content.controllerName', 'installerController');
      expect(controller.get('isInstallerWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addHostController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isInstallerWizard')).to.equal(false);
    });
  });

  describe('#isAddServiceWizard', function () {
    it('true if content.controllerName is addServiceController', function () {
      controller.set('content.controllerName', 'addServiceController');
      expect(controller.get('isAddServiceWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addServiceController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddServiceWizard')).to.equal(false);
    });
  });

  describe('#clearStep', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.clearStep();
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    it('should clear hosts', function () {
      controller.set('hosts', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('hosts')).to.eql([]);
    });
    it('should clear headers', function () {
      controller.set('headers', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('headers')).to.eql([]);
    });
    it('should set isLoaded to false', function () {
      controller.set('isLoaded', true);
      controller.clearStep();
      expect(controller.get('isLoaded')).to.equal(false);
    });
  });

  describe('#checkCallback', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.checkCallback('');
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    Em.A([
        {
          m: 'all checked, isInstalled false',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: false
          }
        },
        {
          m: 'all checked, isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'no one checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        },
        {
          m: 'some checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: false
          }
        },
        {
          m: 'some checked, some isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'some checked, some isInstalled true (2)',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          controller.clearStep();
          controller.set('headers', test.headers);
          controller.set('hosts', test.hosts);
          controller.checkCallback(test.component);
          var header = controller.get('headers').findProperty('name', test.component);
          expect(header.get('allChecked')).to.equal(test.e.allChecked);
          expect(header.get('noChecked')).to.equal(test.e.noChecked);
        });
      });
  });

  describe('#getHostNames', function () {
    var tests = Em.A([
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'REGISTERED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'All REGISTERED',
        e: ['h1', 'h2', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'Some REGISTERED',
        e: ['h1', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'FAILED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'FAILED', name: 'h3'}
        },
        m: 'No one REGISTERED',
        e: []
      },
      {
        hosts: {},
        m: 'Empty hosts',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.hosts', test.hosts);
        var r = controller.getHostNames();
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#validate', function () {
    var tests = Em.A([
      {
        controllerName: 'addHostController',
        method: 'validateEachHost',
        r: true,
        e: true
      },
      {
        controllerName: 'addHostController',
        method: 'validateEachHost',
        r: false,
        e: false
      },
      {
        controllerName: 'addServiceController',
        method: 'validateEachComponent',
        r: true,
        e: true
      },
      {
        controllerName: 'addServiceController',
        method: 'validateEachComponent',
        r: false,
        e: false
      },
      {
        controllerName: 'installerController',
        method: 'validateEachComponent',
        r: true,
        e: true
      },
      {
        controllerName: 'installerController',
        method: 'validateEachComponent',
        r: false,
        e: false
      }
    ]);
    tests.forEach(function (test) {
      it(test.controllerName + ' ' + test.method + ' returns ' + test.r.toString(), function () {
        sinon.stub(controller, test.method, function () {
          return test.r
        });
        controller.set('content.controllerName', test.controllerName);
        expect(controller.callClientSideValidation()).to.equal(test.e);
        controller[test.method].restore();
      });
    });
  });

  describe('#getMasterComponentsForHost', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h1',
        m: 'host exists',
        e: ['c1']
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h2',
        m: 'host donesn\'t exists',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.getMasterComponentsForHost(test.hostName);
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#selectMasterComponents', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c1'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: true,
        m: 'host and component exist'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host exists'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h2',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host and component don\'t exist'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.selectMasterComponents(test.hostsObj);
        expect(r.findProperty('hostName', 'h1').get('checkboxes').findProperty('component', 'c1').get('checked')).to.equal(test.e);
      });
    });
  });

  describe('#getCurrentMastersBlueprint', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hosts: {'h1': {}},
        m: 'one host and one component',
        e:{
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  { fqdn: 'h1' }
                ]
              }
            ]
          }
        }
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'},
          {hostName: 'h2', component: 'c2'},
          {hostName: 'h2', component: 'c3'}
        ]),
        hosts: {'h1': {}, 'h2': {}, 'h3': {}},
        m: 'multiple hosts and multiple components',
        e: {
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' }
                ]
              },
              {
                name: 'host-group-2',
                components: [
                  { name: 'c2' },
                  { name: 'c3' }
                ]
              },
              {
                name: 'host-group-3',
                components: []
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  { fqdn: 'h1' }
                ]
              },
              {
                name: 'host-group-2',
                hosts: [
                  { fqdn: 'h2' }
                ]
              },
              {
                name: 'host-group-3',
                hosts: [
                  { fqdn: 'h3' }
                ]
              }
            ]
          }
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        controller.set('content.hosts', test.hosts);
        var r = controller.getCurrentMastersBlueprint();
        expect(r).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/controllers/wizard/step7_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var numberUtils = require('utils/number_utils');
require('mixins/common/localStorage');
require('models/config_group');
require('controllers/wizard/step7_controller');

var installerStep7Controller;

describe('App.InstallerStep7Controller', function () {

  beforeEach(function () {
    sinon.stub(App.config, 'setPreDefinedServiceConfigs', Em.K);
    installerStep7Controller = App.WizardStep7Controller.create({
      content: {
        advancedServiceConfig: [],
        serviceConfigProperties: []
      }
    });
  });

  afterEach(function() {
    App.config.setPreDefinedServiceConfigs.restore();
  });

  describe('#installedServiceNames', function () {

    var tests = Em.A([
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'SQOOP'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['SQOOP', 'HDFS'],
        m: 'installerController with SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'installerController without SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'addServiceController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'addServiceController without SQOOP'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep7Controller.set('content', test.content);
        expect(installerStep7Controller.get('installedServiceNames')).to.include.members(test.e);
        expect(test.e).to.include.members(installerStep7Controller.get('installedServiceNames'));
      });
    });

  });

  describe('#isSubmitDisabled', function () {
    it('should be true if miscModalVisible', function () {
      installerStep7Controller.reopen({miscModalVisible: true});
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be true if some of stepConfigs has errors', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 1
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be false if all of stepConfigs don\'t have errors and miscModalVisible is false', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 0
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(false);
    });
  });

  describe('#selectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          {isSelected: true, isInstalled: false, serviceName: 's1'},
          {isSelected: false, isInstalled: false, serviceName: 's2'},
          {isSelected: true, isInstalled: true, serviceName: 's3'},
          {isSelected: false, isInstalled: false, serviceName: 's4'},
          {isSelected: true, isInstalled: false, serviceName: 's5'},
          {isSelected: false, isInstalled: false, serviceName: 's6'},
          {isSelected: true, isInstalled: true, serviceName: 's7'},
          {isSelected: false, isInstalled: false, serviceName: 's8'}
        ]
      });
      var expected = ['s1', 's5'];
      expect(installerStep7Controller.get('selectedServiceNames')).to.eql(expected);
    });
  });

  describe('#allSelectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's1'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's2'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's3'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's4'}),
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's5'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's6'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's7'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's8'})
        ]
      });
      var expected = ['s1', 's3', 's5', 's7'];
      expect(installerStep7Controller.get('allSelectedServiceNames')).to.eql(expected);
    });
  });

  describe('#masterComponentHosts', function () {
    it('should be equal to content.masterComponentHosts', function () {
      var masterComponentHosts = [
        {},
        {},
        {}
      ];
      installerStep7Controller.reopen({content: {masterComponentHosts: masterComponentHosts}});
      expect(installerStep7Controller.get('masterComponentHosts')).to.eql(masterComponentHosts);
    });
  });

  describe('#slaveComponentHosts', function () {
    it('should be equal to content.slaveGroupProperties', function () {
      var slaveGroupProperties = [
        {},
        {},
        {}
      ];
      installerStep7Controller.reopen({content: {slaveGroupProperties: slaveGroupProperties}});
      expect(installerStep7Controller.get('slaveComponentHosts')).to.eql(slaveGroupProperties);
    });
  });

  describe('#clearStep', function () {
    it('should clear stepConfigs', function () {
      installerStep7Controller.set('stepConfigs', [
        {},
        {}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('stepConfigs.length')).to.equal(0);
    });
    it('should clear filter', function () {
      installerStep7Controller.set('filter', 'filter');
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filter')).to.equal('');
    });
    it('should set for each filterColumns "selected" false', function () {
      installerStep7Controller.set('filterColumns', [
        {selected: true},
        {selected: false},
        {selected: true}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filterColumns').everyProperty('selected', false)).to.equal(true);
    });
  });

  describe('#loadInstalledServicesConfigGroups', function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it('should do ajax request for each received service name', function () {
      var serviceNames = ['s1', 's2', 's3'];
      installerStep7Controller.loadInstalledServicesConfigGroups(serviceNames);
      expect(App.ajax.send.callCount).to.equal(serviceNames.length);
    });
  });

  describe('#getConfigTags', function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it('should do ajax-request', function () {
      installerStep7Controller.getConfigTags();
      expect(App.ajax.send.calledOnce).to.equal(true);
    });
  });

  describe('#setGroupsToDelete', function () {
    beforeEach(function () {
      installerStep7Controller.set('wizardController', Em.Object.create(App.LocalStorage, {name: 'tdk'}));
    });
    it('should add new groups to groupsToDelete', function () {
      var groupsToDelete = [
          {id: '1'},
          {id: '2'}
        ],
        groups = [
          Em.Object.create({id: '3'}),
          Em.Object.create(),
          Em.Object.create({id: '5'})
        ],
        expected = [
          {id: "1"},
          {id: "2"},
          {id: "3"},
          {id: "5"}
        ];
      installerStep7Controller.set('groupsToDelete', groupsToDelete);
      installerStep7Controller.setGroupsToDelete(groups);
      expect(installerStep7Controller.get('groupsToDelete')).to.eql(expected);
      expect(installerStep7Controller.get('wizardController').getDBProperty('groupsToDelete')).to.eql(expected);
    });
  });

  describe('#selectConfigGroup', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('should set selectedConfigGroup', function () {
      var group = {':': []};
      installerStep7Controller.selectConfigGroup({context: group});
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(group);
    });
  });

  describe('#addOverrideProperty', function () {
    it('should add override property', function () {
      var groupName = 'groupName',
        selectedService = {configGroups: [Em.Object.create({name: groupName, properties: []})]},
        selectedConfigGroup = {name: groupName},
        serviceConfigProperty = Em.Object.create({overrides: []}),
        expected = Em.Object.create({
          value: '',
          isOriginalSCP: false,
          isEditable: true
        });
      installerStep7Controller.reopen({selectedService: selectedService, selectedConfigGroup: selectedConfigGroup});
      var newSCP = installerStep7Controller.addOverrideProperty(serviceConfigProperty);
      Em.keys(expected).forEach(function (k) {
        expect(newSCP.get(k)).to.equal(expected.get(k));
      });
      var group = installerStep7Controller.get('selectedService.configGroups').findProperty('name', groupName);
      expect(newSCP.get('group')).to.eql(group);
      expect(newSCP.get('parentSCP')).to.eql(serviceConfigProperty);
      expect(group.get('properties.length')).to.equal(1);
    });
  });

  describe('#resolveYarnConfigs', function () {
    it('should set property to true', function () {
      var allSelectedServiceNames = ['SLIDER', 'YARN'],
        configs = [
          {name: 'hadoop.registry.rm.enabled', value: false, defaultValue: false}
        ],
        expected = [
          {name: 'hadoop.registry.rm.enabled', value: true, defaultValue: true, forceUpdate: true}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveYarnConfigs(configs);
      expect(configs[0]).to.eql(expected[0]);
    });

    it('should set property to false', function () {
      var allSelectedServiceNames = ['YARN'],
        configs = [
          {name: 'hadoop.registry.rm.enabled', value: true, defaultValue: true}
        ],
        expected = [
          {name: 'hadoop.registry.rm.enabled', value: false, defaultValue: false, forceUpdate: true}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveYarnConfigs(configs);
      expect(configs[0]).to.eql(expected[0]);
    });

    it('should skip setting property', function () {
      var allSelectedServiceNames = ['YARN', 'SLIDER'],
        configs = [
          {name: 'hadoop.registry.rm.enabled', value: true, defaultValue: true}
        ],
        expected = [
          {name: 'hadoop.registry.rm.enabled', value: true, defaultValue: true}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveYarnConfigs(configs);
      expect(configs[0]).to.eql(expected[0]);
    });
  });

  describe('#resolveStormConfigs', function () {

    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({

          hosts: {'h1': {name: 'host1', id: 'h1'}},
          masterComponentHosts: [{component: 'GANGLIA_SERVER', host_id: 'h1'}],

          getDBProperty: function (k) {
            return this.get(k);
          }
        })
      });
    });

    it('shouldn\'t do nothing if Ganglia and Storm are installed', function () {
      var installedServiceNames = ['GANGLIA', 'STORM'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', defaultValue: ''}
        ];
      installerStep7Controller.reopen({installedServiceNames: installedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      expect(configs).to.eql(expected);
    });

    it('shouldn\'t do nothing if Ganglia is in allSelectedServiceNames', function () {
      var allSelectedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=host1', defaultValue: '.jar=host=host1', forceUpdate: true},
          {name: 'supervisor.childopts', value: '.jar=host=host1', defaultValue: '.jar=host=host1', forceUpdate: true},
          {name: 'worker.childopts', value: '.jar=host=host1', defaultValue: '.jar=host=host1', forceUpdate: true}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });

    it('shouldn\'t do nothing if Ganglia is in installedServiceNames (2)', function () {
      var installedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=host1', defaultValue: '.jar=host=host1', forceUpdate: true},
          {name: 'supervisor.childopts', value: '.jar=host=host1', defaultValue: '.jar=host=host1', forceUpdate: true},
          {name: 'worker.childopts', value: '.jar=host=host1', defaultValue: '.jar=host=host1', forceUpdate: true}
        ];
      installerStep7Controller.reopen({installedServiceNames: installedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });

    it('should replace host name for *.childopts properties if Ganglia is in installedServiceNames for Add Service Wizard', function () {
      var installedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=realhost1', defaultValue: '.jar=host=realhost1', forceUpdate: true},
          {name: 'supervisor.childopts', value: '.jar=host=realhost1', defaultValue: '.jar=host=realhost1', forceUpdate: true},
          {name: 'worker.childopts', value: '.jar=host=realhost1', defaultValue: '.jar=host=realhost1', forceUpdate: true}
        ];
      installerStep7Controller.reopen({
        installedServiceNames: installedServiceNames,
        wizardController: Em.Object.create({
          name: 'addServiceController',
          masterComponentHosts: [{component: 'GANGLIA_SERVER', hostName: 'realhost1'}],
          getDBProperty: function (k) {
            return this.get(k);
          }
        })
      });
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });

  });

  describe('#resolveServiceDependencyConfigs', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'resolveStormConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'resolveYarnConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.resolveStormConfigs.restore();
      installerStep7Controller.resolveYarnConfigs.restore();
    });
    var serviceNames = [
      {serviceName: 'STORM', method: "resolveStormConfigs"},
      {serviceName: 'YARN', method: "resolveYarnConfigs"}].forEach(function(t) {
      it("should call " + t.method + " if serviceName is " + t.serviceName, function () {
        var configs = [
          {},
          {}
        ];
        installerStep7Controller.resolveServiceDependencyConfigs(t.serviceName, configs);
        expect(installerStep7Controller[t.method].calledWith(configs)).to.equal(true);
      });
    });
  });

  describe('#selectedServiceObserver', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('shouldn\'t do nothing if App.supports.hostOverridesInstaller is false', function () {
      App.set('supports.hostOverridesInstaller', false);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService is null', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: null, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService.serviceName is MISC', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 'MISC'}, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('should update configGroups and selectedConfigGroup', function () {
      App.set('supports.hostOverridesInstaller', true);
      var defaultGroup = {isDefault: true, n: 'n2'},
        configGroups = [
          {isDefault: false, n: 'n1'},
          defaultGroup,
          {n: 'n3'}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 's1', configGroups: configGroups}});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups').mapProperty('n')).to.eql(['n2', 'n1', 'n3']);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(defaultGroup);
    });
  });

  describe('#loadConfigGroups', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        wizardController: Em.Object.create({
          allHosts: [
            {hostName: 'h1'},
            {hostName: 'h2'},
            {hostName: 'h3'}
          ]
        })
      });
    });
    it('shouldn\'t do nothing if only MISC available', function () {
      var configGroups = [
        {}
      ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: 'MISC', configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups([]);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups')).to.eql(configGroups);
    });
    it('should set configGroups for service if they don\'t exist', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 's1'}}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, displayName: serviceName, configGroups: configGroups})]
      });
      var manageCGController = App.router.get('manageConfigGroupsController');
      sinon.stub(manageCGController, 'hostsToPublic', function(data){return ['c6401','c6402','c6403']});
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups.length')).to.equal(1);
      var group = installerStep7Controller.get('stepConfigs.firstObject.configGroups.firstObject');
      expect(group.get('name')).to.equal(serviceName + ' Default');
      expect(group.get('description').contains(serviceName)).to.equal(true);
      expect(group.get('isDefault')).to.equal(true);
      expect(group.get('hosts')).to.eql(['h1', 'h2', 'h3']);
      expect(group.get('service.id')).to.equal(serviceName);
      expect(group.get('serviceName')).to.equal(serviceName);
      manageCGController.hostsToPublic.restore();
    });
    it('should update configGroups for service (only default group)', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 'HDFS'}, isDefault: true, n: 'n1'}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, displayName: serviceName, configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault').get('n')).to.equal('n1');
    });
    it('should update configGroups for service', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        properties = [
          { name: "p1", filename: "file.xml" },
          { name: "p2", filename: "file.xml" }
        ],
        serviceConfigGroups = [
          {service: {id: 'HDFS'}, properties: properties.slice(), isDefault: true, n: 'n1'},
          {service: {id: 'HDFS'}, properties: properties.slice(), isDefault: false, n: 'n2'}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, configGroups: configGroups, configs: properties})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups.length')).to.equal(2);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault').get('n')).to.equal('n1');
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault', false).get('properties').everyProperty('group.n', 'n2')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault', false).get('parentConfigGroup.n')).to.equal('n1');
    });
  });

  describe('#_getDisplayedConfigGroups', function () {
    it('should return [] if no selected group', function () {
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: null
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([]);
    });
    it('should return default config group if another selected', function () {
      var defaultGroup = Em.Object.create({isDefault: false});
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([defaultGroup]);
    });
    it('should return other groups if default selected', function () {
      var defaultGroup = Em.Object.create({isDefault: true}),
        cfgG = Em.Object.create({isDefault: true}),
        configGroups = Em.A([
          Em.Object.create({isDefault: false}),
          Em.Object.create({isDefault: false}),
          cfgG,
          Em.Object.create({isDefault: false})
        ]);
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup,
        selectedService: {configGroups: configGroups}
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql(configGroups.without(cfgG));
    });
  });

  describe('#_setEditableValue', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.be.null;
    });
    it('should set isEditable equal to selectedGroup.isDefault if service not installed', function () {
      var isDefault = true;
      installerStep7Controller.reopen({
        installedServiceNames: [],
        selectedService: {serviceName: 'abc'},
        selectedConfigGroup: Em.Object.create({isDefault: isDefault})
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(isDefault);
      installerStep7Controller.toggleProperty('selectedConfigGroup.isDefault');
      updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(!isDefault);
    });
    Em.A([
        {
          isEditable: false,
          isReconfigurable: false,
          isDefault: true,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: true,
          isDefault: true,
          e: true
        },
        {
          isEditable: false,
          isReconfigurable: true,
          isDefault: false,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: false,
          isDefault: false,
          e: false
        }
      ]).forEach(function (test) {
        it('service installed, isEditable = ' + test.isEditable.toString() + ', isReconfigurable = ' + test.isReconfigurable.toString(), function () {
          var config = Em.Object.create({
            isReconfigurable: test.isReconfigurable,
            isEditable: test.isEditable
          });
          installerStep7Controller.reopen({
            installedServiceNames: Em.A(['a']),
            selectedService: Em.Object.create({serviceName: 'a'}),
            selectedConfigGroup: Em.Object.create({isDefault: test.isDefault})
          });
          var updateConfig = installerStep7Controller._setEditableValue(config);
          expect(updateConfig.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_setOverrides', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({overrides: null});
      var updatedConfig = installerStep7Controller._setOverrides(config, []);
      expect(updatedConfig.get('overrides')).to.be.null;
    });
    it('no overrideToAdd', function () {
      var isDefault = true,
        name = 'n1',
        config = Em.Object.create({overrides: null, name: name, flag: 'flag'}),
        overrides = Em.A([
          Em.Object.create({name: name, value: 'v1'}),
          Em.Object.create({name: name, value: 'v2'}),
          Em.Object.create({name: 'n2', value: 'v3'})
        ]);
      installerStep7Controller.reopen({
        overrideToAdd: null,
        selectedConfigGroup: Em.Object.create({
          isDefault: isDefault
        })
      });
      var updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      expect(updatedConfig.get('overrides.length')).to.equal(2);
      expect(updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      expect(updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
    });
    it('overrideToAdd exists', function () {
      var isDefault = true,
        name = 'n1',
        config = Em.Object.create({overrides: null, name: name, flag: 'flag'}),
        overrides = Em.A([
          Em.Object.create({name: name, value: 'v1'}),
          Em.Object.create({name: name, value: 'v2'}),
          Em.Object.create({name: 'n2', value: 'v3'})
        ]);
      installerStep7Controller.reopen({
        overrideToAdd: Em.Object.create({name: name}),
        selectedService: {configGroups: [Em.Object.create({name: 'n', properties: []})]},
        selectedConfigGroup: Em.Object.create({
          isDefault: isDefault,
          name: 'n'
        })
      });
      var updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      expect(updatedConfig.get('overrides.length')).to.equal(3);
      expect(updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      expect(updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
    });
  });

  describe('#switchConfigGroupConfigs', function () {
    it('if selectedConfigGroup is null, serviceConfigs shouldn\'t be changed', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null,
        content: {services: []},
        serviceConfigs: {configs: [
          {overrides: []},
          {overrides: []}
        ]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      expect(installerStep7Controller.get('serviceConfigs.configs').everyProperty('overrides.length', 0)).to.equal(true);
    });
    it('should set configs for serviceConfigs', function () {
      var configGroups = [
        Em.Object.create({
          properties: [
            {name: 'g1', value: 'v1'},
            {name: 'g2', value: 'v2'}
          ]
        })
      ];
      sinon.stub(installerStep7Controller, '_getDisplayedConfigGroups', function () {
        return configGroups;
      });
      sinon.stub(installerStep7Controller, '_setEditableValue', function (config) {
        config.set('isEditable', true);
        return config;
      });
      installerStep7Controller.reopen({
        selectedConfigGroup: Em.Object.create({isDefault: true, name: 'g1'}),
        content: {services: []},
        selectedService: {configs: Em.A([Em.Object.create({name: 'g1', overrides: [], properties: []}), Em.Object.create({name: 'g2', overrides: []})])},
        serviceConfigs: {configs: [Em.Object.create({name: 'g1'})]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      var configs = installerStep7Controller.get('selectedService.configs');
      expect(configs.findProperty('name', 'g1').get('overrides').length).to.equal(1);
      expect(configs.findProperty('name', 'g2').get('overrides').length).to.equal(1);
      expect(configs.everyProperty('isEditable', true)).to.equal(true);
      installerStep7Controller._getDisplayedConfigGroups.restore();
      installerStep7Controller._setEditableValue.restore();
    });
  });

  describe('#selectProperService', function () {
    Em.A([
        {
          name: 'addServiceController',
          stepConfigs: [
            {selected: false, name: 'n1'},
            {selected: true, name: 'n2'},
            {selected: true, name: 'n3'}
          ],
          e: 'n2'
        },
        {
          name: 'installerController',
          stepConfigs: [
            {showConfig: false, name: 'n1'},
            {showConfig: false, name: 'n2'},
            {showConfig: true, name: 'n3'}
          ],
          e: 'n3'
        }
      ]).forEach(function (test) {
        it(test.name, function () {
          sinon.stub(installerStep7Controller, 'selectedServiceObserver', Em.K);
          installerStep7Controller.reopen({
            wizardController: Em.Object.create({
              name: test.name
            }),
            stepConfigs: test.stepConfigs
          });
          installerStep7Controller.selectProperService();
          expect(installerStep7Controller.get('selectedService.name')).to.equal(test.e);
          installerStep7Controller.selectedServiceObserver.restore();
        });
      });
  });

  describe('#setStepConfigs', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (key) {
            return this.get(key);
          }
        })
      });
    });
    afterEach(function () {
      App.config.renderConfigs.restore();
    });
    it('if wizard isn\'t addService, should set output of App.config.renderConfigs', function () {
      var serviceConfigs = Em.A([
        {},
        {}
      ]);
      sinon.stub(App.config, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.set('wizardController.name', 'installerController');
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs')).to.eql(serviceConfigs);
    });
    it('addServiceWizard used', function () {
      var serviceConfigs = Em.A([Em.Object.create({serviceName: 's1'}), Em.Object.create({serviceName: 's2'})]);
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['s2']});
      sinon.stub(App.config, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 's2').get('selected')).to.equal(true);
    });
    it('addServiceWizard used, HA enabled', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'isHaEnabled') {
          return true;
        }
        return Em.get(App, k);
      });
      var serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            {category: 'SECONDARY_NAMENODE'},
            {category: 'SECONDARY_NAMENODE'},
            {category: 'NameNode'},
            {category: 'NameNode'},
            {category: 'SECONDARY_NAMENODE'}
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      sinon.stub(App.config, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('selected')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(2);
      App.get.restore();
    });
  });

  describe('#checkHostOverrideInstaller', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'loadConfigGroups', Em.K);
      sinon.stub(installerStep7Controller, 'loadInstalledServicesConfigGroups', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.loadConfigGroups.restore();
      installerStep7Controller.loadInstalledServicesConfigGroups.restore();
      App.get.restore();
    });
    Em.A([
        {
          hostOverridesInstaller: false,
          installedServiceNames: [],
          m: 'hostOverridesInstaller is false, installedServiceNames is empty',
          e: {
            loadConfigGroups: false,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          hostOverridesInstaller: false,
          installedServiceNames: ['s1', 's2'],
          m: 'hostOverridesInstaller is false, installedServiceNames is n\'t empty',
          e: {
            loadConfigGroups: false,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          hostOverridesInstaller: true,
          installedServiceNames: [],
          m: 'hostOverridesInstaller is true, installedServiceNames is empty',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          hostOverridesInstaller: true,
          installedServiceNames: ['s1', 's2', 's3'],
          m: 'hostOverridesInstaller is true, installedServiceNames isn\'t empty',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(App, 'get', function (k) {
            if (k === 'supports.hostOverridesInstaller') return test.hostOverridesInstaller;
            return Em.get(App, k);
          });
          installerStep7Controller.reopen({installedServiceNames: test.installedServiceNames});
          installerStep7Controller.checkHostOverrideInstaller();
          if (test.e.loadConfigGroups) {
            expect(installerStep7Controller.loadConfigGroups.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.loadConfigGroups.called).to.equal(false);
          }
          if (test.e.loadInstalledServicesConfigGroups) {
            expect(installerStep7Controller.loadInstalledServicesConfigGroups.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.loadInstalledServicesConfigGroups.called).to.equal(false);
          }
        });
      });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (k) {
            return this.get(k);
          }
        })
      });
      sinon.stub(App.config, 'mergePreDefinedWithStored', Em.K);
      sinon.stub(App.config, 'addAdvancedConfigs', Em.K);
      sinon.stub(App.config, 'addCustomConfigs', Em.K);
      sinon.stub(App.config, 'fileConfigsIntoTextarea', Em.K);
      sinon.stub(installerStep7Controller, 'clearStep', Em.K);
      sinon.stub(installerStep7Controller, 'getConfigTags', Em.K);
      sinon.stub(installerStep7Controller, 'setInstalledServiceConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'resolveServiceDependencyConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'setStepConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'activateSpecialConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(installerStep7Controller, 'applyServicesConfigs', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.config.mergePreDefinedWithStored.restore();
      App.config.addAdvancedConfigs.restore();
      App.config.addCustomConfigs.restore();
      App.config.fileConfigsIntoTextarea.restore();
      installerStep7Controller.clearStep.restore();
      installerStep7Controller.getConfigTags.restore();
      installerStep7Controller.setInstalledServiceConfigs.restore();
      installerStep7Controller.resolveServiceDependencyConfigs.restore();
      installerStep7Controller.setStepConfigs.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.activateSpecialConfigs.restore();
      installerStep7Controller.selectProperService.restore();
      installerStep7Controller.applyServicesConfigs.restore();
      App.router.send.restore();
    });
    it('should call clearStep', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.calledOnce).to.equal(true);
    });
    it('shouldn\'t do nothing if isAdvancedConfigLoaded is false', function () {
      installerStep7Controller.set('isAdvancedConfigLoaded', false);
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.called).to.equal(false);
    });
    it('should use App.config to map configs', function () {
      installerStep7Controller.loadStep();
      expect(App.config.mergePreDefinedWithStored.calledOnce).to.equal(true);
      expect(App.config.addAdvancedConfigs.calledOnce).to.equal(true);
      expect(App.config.addCustomConfigs.calledOnce).to.equal(true);
    });
    it('should call setInstalledServiceConfigs for addServiceController', function () {
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.setInstalledServiceConfigs.calledOnce).to.equal(true);
    });
  });

  describe('#applyServicesConfigs', function() {
    beforeEach(function() {
      installerStep7Controller.reopen({
        allSelectedServiceNames: []
      });
      sinon.stub(App.config, 'fileConfigsIntoTextarea', function(configs) {
        return configs;
      });
      sinon.stub(installerStep7Controller, 'resolveServiceDependencyConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'loadServerSideConfigsRecommendations', function() {
        return $.Deferred().resolve();
      });
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'activateSpecialConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(installerStep7Controller, 'setStepConfigs', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.config.fileConfigsIntoTextarea.restore();
      installerStep7Controller.resolveServiceDependencyConfigs.restore();
      installerStep7Controller.loadServerSideConfigsRecommendations.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.activateSpecialConfigs.restore();
      installerStep7Controller.selectProperService.restore();
      installerStep7Controller.setStepConfigs.restore();
      App.router.send.restore();
    });

    it('should run some methods' , function () {
     installerStep7Controller.applyServicesConfigs({name: 'configs'}, {name: 'storedConfigs'});
     expect(installerStep7Controller.loadServerSideConfigsRecommendations.calledOnce).to.equal(true);
     expect(installerStep7Controller.get('isRecommendedLoaded')).to.equal(true);
     expect(installerStep7Controller.setStepConfigs.calledWith({name: 'configs'}, {name: 'storedConfigs'})).to.equal(true);
     expect(installerStep7Controller.checkHostOverrideInstaller.calledOnce).to.equal(true);
     expect(installerStep7Controller.activateSpecialConfigs.calledOnce).to.equal(true);
     expect(installerStep7Controller.selectProperService.calledOnce).to.equal(true);
    });

    Em.A([
      {
        allSelectedServiceNames: ['YARN'],
        fileConfigsIntoTextarea: true,
        m: 'should run fileConfigsIntoTextarea and resolveServiceDependencyConfigs',
        resolveServiceDependencyConfigs: true,
        capacitySchedulerUi: false
      },
      {
        allSelectedServiceNames: ['YARN'],
        m: 'shouldn\'t run fileConfigsIntoTextarea but  run resolveServiceDependencyConfigs',
        resolveServiceDependencyConfigs: true,
        capacitySchedulerUi: true
      },
      {
        allSelectedServiceNames: ['STORM'],
        resolveServiceDependencyConfigs: true,
        m: 'should run resolveServiceDependencyConfigs'
      }
    ]).forEach(function(t) {
      it(t.m, function () {
        sinon.stub(App, 'get', function (k) {
          if (k === 'supports.capacitySchedulerUi') return t.capacitySchedulerUi;
          return Em.get(App, k);
        });
        installerStep7Controller.reopen({
          allSelectedServiceNames: t.allSelectedServiceNames
        });
        installerStep7Controller.applyServicesConfigs({name: 'configs'}, {name: 'storedConfigs'});
        if (t.fileConfigsIntoTextarea) {
          expect(App.config.fileConfigsIntoTextarea.calledWith({name: 'configs'}, 'capacity-scheduler.xml')).to.equal(true);
        } else {
          expect(App.config.fileConfigsIntoTextarea.calledOnce).to.equal(false);
        }
        if (t.resolveServiceDependencyConfigs) {
          expect(installerStep7Controller.resolveServiceDependencyConfigs.calledWith(t.allSelectedServiceNames[0], {name: 'configs'})).to.equal(true);
        } else {
          expect(installerStep7Controller.resolveServiceDependencyConfigs.calledOnce).to.equal(false);
        }
        App.get.restore();
      });
    });
  });
  describe('#_updateValueForCheckBoxConfig', function () {
    Em.A([
        {
          v: 'true',
          e: true
        },
        {
          v: 'false',
          e: false
        }
      ]).forEach(function (test) {
        it(test.v, function () {
          var serviceConfigProperty = Em.Object.create({value: test.v});
          installerStep7Controller._updateValueForCheckBoxConfig(serviceConfigProperty);
          expect(serviceConfigProperty.get('value')).to.equal(test.e);
          expect(serviceConfigProperty.get('defaultValue')).to.equal(test.e);
        });
      });
  });

  describe('#_updateIsEditableFlagForConfig', function () {
    Em.A([
        {
          isAdmin: false,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false for non-admin users',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: true,
          m: 'false if defaultGroupSelected is true and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: false,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is false',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: true,
          isHostsConfigsPage: false,
          defaultGroupSelected: true,
          m: 'equal to isReconfigurable if defaultGroupSelected is true and isHostsConfigsPage is false',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(App, 'get', function (k) {
            if (k === 'isAdmin') return test.isAdmin;
            return Em.get(App, k);
          });
          installerStep7Controller.reopen({isHostsConfigsPage: test.isHostsConfigsPage});
          var serviceConfigProperty = Em.Object.create({
            isReconfigurable: test.isReconfigurable
          });
          installerStep7Controller._updateIsEditableFlagForConfig(serviceConfigProperty, test.defaultGroupSelected);
          App.get.restore();
          expect(serviceConfigProperty.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_updateOverridesForConfig', function () {

    it('should set empty array', function () {
      var serviceConfigProperty = Em.Object.create({
        overrides: null
      }), component = Em.Object.create();
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      expect(serviceConfigProperty.get('overrides')).to.eql(Em.A([]));
    });

    it('host overrides not supported', function () {
      var serviceConfigProperty = Em.Object.create({
        overrides: [
          {value: 'new value'}
        ]
      }), component = Em.Object.create({selectedConfigGroup: {isDefault: false}});
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      expect(serviceConfigProperty.get('overrides').length).to.equal(1);
      expect(serviceConfigProperty.get('overrides.firstObject.value')).to.equal('new value');
      expect(serviceConfigProperty.get('overrides.firstObject.isOriginalSCP')).to.equal(false);
      expect(serviceConfigProperty.get('overrides.firstObject.parentSCP')).to.eql(serviceConfigProperty);
    });

    it('host overrides supported', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'supports.hostOverrides') return true;
        return Em.get(App, k);
      });
      var serviceConfigProperty = Em.Object.create({
          overrides: [
            {value: 'new value', group: Em.Object.create({name: 'n1'})}
          ]
        }),
        component = Em.Object.create({
          selectedConfigGroup: {isDefault: true},
          configGroups: Em.A([
            Em.Object.create({name: 'n1', properties: []})
          ])
        });
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      App.get.restore();
      expect(serviceConfigProperty.get('overrides').length).to.equal(1);
      expect(serviceConfigProperty.get('overrides.firstObject.value')).to.equal('new value');
      expect(serviceConfigProperty.get('overrides.firstObject.isOriginalSCP')).to.equal(false);
      expect(serviceConfigProperty.get('overrides.firstObject.parentSCP')).to.eql(serviceConfigProperty);
      expect(component.get('configGroups.firstObject.properties').length).to.equal(1);
      expect(component.get('configGroups.firstObject.properties.firstObject.isEditable')).to.equal(false);
      expect(component.get('configGroups.firstObject.properties.firstObject.group')).to.be.object;
    });

  });

  describe('#setSecureConfigs', function() {
    var serviceConfigObj = Em.Object.create({
      serviceName: 'HDFS',
      configs: [
        Em.Object.create({ name: 'hadoop.http.authentication.signature.secret.file' }),
        Em.Object.create({ name: 'hadoop.security.authentication' })
      ]
    });
    var tests = [
      { name: 'hadoop.http.authentication.signature.secret.file', e: false },
      { name: 'hadoop.security.authentication', e: true }
    ];

    sinon.stub(App, 'get', function(key) {
      if (['isHadoop22Stack', 'isHadoop2Stack'].contains(key)) return true;
      else App.get(key);
    });
    var controller = App.WizardStep7Controller.create({});
    controller.get('secureConfigs').pushObjects([
      {
        name: 'hadoop.http.authentication.signature.secret.file',
        serviceName: 'HDFS',
        value: ''
      }
    ]);
    controller.setSecureConfigs(serviceConfigObj, 'HDFS');
    App.get.restore();
    tests.forEach(function(test) {
      it('{0} is {1}required'.format(test.name, !!test.e ? '' : 'non ' ), function() {
        expect(serviceConfigObj.get('configs').findProperty('name', test.name).get('isRequired')).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/controllers/wizard/step8_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var modelSetup = require('test/init_model_test');
require('utils/ajax/ajax_queue');
require('controllers/main/admin/security');
require('controllers/main/service/info/configs');
require('controllers/wizard/step8_controller');
var installerStep8Controller, configurationController;

describe('App.WizardStep8Controller', function () {

  var configs = Em.A([
    Em.Object.create({filename: 'hdfs-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hdfs-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hue-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hue-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'mapred-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'mapred-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'yarn-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'yarn-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hbase-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hbase-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'oozie-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'oozie-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hive-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hive-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'pig-properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'webhcat-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'webhcat-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'tez-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'tez-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p2', value: 'v2'})
  ]);

  beforeEach(function () {
    installerStep8Controller = App.WizardStep8Controller.create({
      configs: configs
    });
    configurationController = App.MainServiceInfoConfigsController.create({});
  });

  var siteObjTests = Em.A([
    {name: 'createHdfsSiteObj', e: {type: 'hdfs-site', tag: 'version1', l: 2}},
    {name: 'createHueSiteObj', e: {type: 'hue-site', tag: 'version1', l: 2}},
    {name: 'createMrSiteObj', e: {type: 'mapred-site', tag: 'version1', l: 2}},
    {name: 'createYarnSiteObj', e: {type: 'yarn-site', tag: 'version1', l: 2}},
    {name: 'createCapacityScheduler', e: {type: 'capacity-scheduler', tag: 'version1', l: 2}},
    {name: 'createMapredQueueAcls', e: {type: 'mapred-queue-acls', tag: 'version1', l: 2}},
    {name: 'createHbaseSiteObj', e: {type: 'hbase-site', tag: 'version1', l: 2}},
    {name: 'createOozieSiteObj', e: {type: 'oozie-site', tag: 'version1', l: 2}},
    {name: 'createHiveSiteObj', e: {type: 'hive-site', tag: 'version1', l: 2}},
    {name: 'createWebHCatSiteObj', e: {type: 'webhcat-site', tag: 'version1', l: 2}},
    {name: 'createTezSiteObj', e: {type: 'tez-site', tag: 'version1', l: 2}},
    {name: 'createPigPropertiesSiteObj', e: {type: 'pig-properties', tag: 'version1', l: 1}},
    {name: 'createFalconStartupSiteObj', e: {type: 'falcon-startup.properties', tag: 'version1', l: 2}},
    {name: 'createFalconRuntimeSiteObj', e: {type: 'falcon-runtime.properties', tag: 'version1', l: 2}}
  ]);

  siteObjTests.forEach(function (test) {
    describe('#' + test.name, function () {

      it(test.name, function () {

        var siteObj = installerStep8Controller.createSiteObj(test.e.type, test.e.tag);
        expect(siteObj.tag).to.equal(test.e.tag);
        expect(Em.keys(siteObj.properties).length).to.equal(test.e.l);
      });

    });
  });

  describe('#createSelectedServicesData', function () {

    var tests = Em.A([
      {selectedServices: Em.A(['MAPREDUCE2']), e: 2},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN']), e: 5},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE']), e: 7},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE']), e: 9},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 12},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 13},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE']), e: 14},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG']), e: 15},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON']), e: 17},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM']), e: 18},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ']), e: 19},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ', 'ZOOKEEPER']), e: 21}
    ]);

    tests.forEach(function (test) {
      it(test.selectedServices.join(','), function () {
        var services = test.selectedServices.map(function (serviceName) {
          return Em.Object.create({isSelected: true, isInstalled: false, serviceName: serviceName});
        });
        installerStep8Controller = App.WizardStep8Controller.create({
          content: {controllerName: 'addServiceController', services: services},
          configs: configs
        });
        var serviceData = installerStep8Controller.createSelectedServicesData();
        expect(serviceData.mapProperty('ServiceInfo.service_name')).to.eql(test.selectedServices.toArray());
        installerStep8Controller.clearStep();
      });
    });

  });

  describe('#getRegisteredHosts', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: ['h1'],
        m: 'Two hosts, one registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: [],
        m: 'Two hosts, zero registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2'})
        },
        e: ['h1', 'h2'],
        m: 'Two hosts, two registered'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHosts = installerStep8Controller.getRegisteredHosts();
        expect(registeredHosts.mapProperty('hostName').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#createRegisterHostData', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h1', 'h2'],
        m: 'two registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'two registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2', isInstalled: false})
        },
        e: [],
        m: 'zero registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: true})
        },
        e: [],
        m: 'two registered, zeto insInstalled false'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHostData = installerStep8Controller.createRegisterHostData();
        expect(registeredHostData.mapProperty('Hosts.host_name').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#clusterName', function () {
    it('should be equal to content.cluster.name', function () {
      installerStep8Controller.set('content', {cluster: {name: 'new_name'}});
      expect(installerStep8Controller.get('clusterName')).to.equal('new_name');
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'clearStep', Em.K);
      sinon.stub(installerStep8Controller, 'formatProperties', Em.K);
      sinon.stub(installerStep8Controller, 'loadConfigs', Em.K);
      sinon.stub(installerStep8Controller, 'loadClusterInfo', Em.K);
      sinon.stub(installerStep8Controller, 'loadServices', Em.K);
      installerStep8Controller.set('content', {controllerName: 'installerController'});
    });
    afterEach(function () {
      installerStep8Controller.clearStep.restore();
      installerStep8Controller.formatProperties.restore();
      installerStep8Controller.loadConfigs.restore();
      installerStep8Controller.loadClusterInfo.restore();
      installerStep8Controller.loadServices.restore();
    });
    it('should call clearStep', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadClusterInfo', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadClusterInfo.calledOnce).to.equal(true);
    });
    it('should call loadServices', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call formatProperties if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call loadConfigs if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadConfigs.calledOnce).to.equal(true);
    });
    it('should set isSubmitDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
  });

  describe('#removeHiveConfigs', function () {
    Em.A([
        {
          globals: [
            {name: 'hive_database', value: 'New MySQL Database'},
            {name: 'hive_database_type', value: 'mysql'},
            {name: 'hive_ambari_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_existing_mysql_host', 'hive_existing_mysql_database', 'hive_existing_oracle_host',
            'hive_existing_oracle_database', 'hive_existing_postgresql_host', 'hive_existing_postgresql_database']),
          hive_database_type: 'mysql',
          m: 'hive_database: New MySQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'hive_database', value: 'Existing MySQL Database'},
            {name: 'hive_database_type', value: 'mysql'},
            {name: 'hive_existing_mysql_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_ambari_host', 'hive_ambari_database', 'hive_existing_oracle_host',
            'hive_existing_oracle_database', 'hive_existing_postgresql_host', 'hive_existing_postgresql_database']),
          hive_database_type: 'mysql',
          m: 'hive_database: Existing MySQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'hive_database', value: 'Existing PostgreSQL Database'},
            {name: 'hive_database_type', value: 'postgresql'},
            {name: 'hive_existing_postgresql_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_ambari_host', 'hive_ambari_database', 'hive_existing_oracle_host',
            'hive_existing_oracle_database', 'hive_existing_mysql_host', 'hive_existing_mysql_database']),
          hive_database_type: 'postgres',
          m: 'hive_database: Existing PostgreSQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'hive_database', value: 'Existing Oracle Database'},
            {name: 'hive_database_type', value: 'oracle'},
            {name: 'hive_existing_oracle_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_ambari_host', 'hive_ambari_database', 'hive_existing_mysql_host',
            'hive_existing_mysql_database', 'hive_existing_postgresql_host', 'hive_existing_postgresql_database']),
          hive_database_type: 'oracle',
          m: 'hive_database: Existing Oracle Database',
          host: 'h1'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          test.removed.forEach(function (c) {
            test.globals.pushObject({name: c})
          });
          var configs = installerStep8Controller.removeHiveConfigs(test.globals);
          test.removed.forEach(function(name) {
            expect(Em.isNone(configs.findProperty('name', name))).to.equal(true);
          });
          expect(configs.findProperty('name', 'hive_database_type').value).to.equal(test.hive_database_type);
          expect(configs.findProperty('name', 'hive_hostname').value).to.equal(test.host);
        });
      });
  });

  describe('#removeOozieConfigs', function () {
    Em.A([
        {
          globals: [
            {name: 'oozie_database', value: 'New Derby Database'},
            {name: 'oozie_database_type', value: 'derby'},
            {name: 'oozie_ambari_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_mysql_host',
            'oozie_existing_mysql_database', 'oozie_existing_oracle_host', 'oozie_existing_oracle_database',
            'oozie_existing_postgresql_host', 'oozie_existing_postgresql_database']),
          oozie_database_type: 'derby',
          m: 'oozie_database: New Derby Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'oozie_database', value: 'Existing MySQL Database'},
            {name: 'oozie_database_type', value: 'mysql'},
            {name: 'oozie_existing_mysql_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_oracle_host',
            'oozie_existing_oracle_database', 'oozie_derby_database', 'oozie_existing_postgresql_host', 'oozie_existing_postgresql_database']),
          oozie_database_type: 'mysql',
          m: 'oozie_database: Existing MySQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'oozie_database', value: 'Existing PostgreSQL Database'},
            {name: 'oozie_database_type', value: 'postgresql'},
            {name: 'oozie_existing_postgresql_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_oracle_host',
            'oozie_existing_oracle_database', 'oozie_existing_mysql_host', 'oozie_existing_mysql_database']),
          oozie_database_type: 'postgresql',
          m: 'oozie_database: Existing PostgreSQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'oozie_database', value: 'Existing Oracle Database'},
            {name: 'oozie_database_type', value: 'oracle'},
            {name: 'oozie_existing_oracle_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_mysql_host',
            'oozie_existing_mysql_database', 'oozie_derby_database', 'oozie_existing_postgresql_host', 'oozie_existing_postgresql_database']),
          oozie_database_type: 'oracle',
          m: 'oozie_database: Existing Oracle Database',
          host: 'h1'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          test.removed.forEach(function (c) {
            if (!test.globals.findProperty('name', c)) {
              test.globals.pushObject({name: c})
            }
          });
          var configs = installerStep8Controller.removeOozieConfigs(test.globals);
          test.removed.forEach(function(name) {
            expect(Em.isNone(configs.findProperty('name', name))).to.equal(true);
          });
          expect(configs.findProperty('name', 'oozie_database_type').value).to.equal(test.oozie_database_type);
          expect(configs.findProperty('name', 'oozie_hostname').value).to.equal(test.host);
        });
      });
  });

  describe('#getRegisteredHosts', function() {
    Em.A([
        {
          hosts: {},
          m: 'no content.hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: ''},
            h2:{bootStatus: ''}
          },
          m: 'no registered hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: 'REGISTERED', hostName: '', name: 'n1'},
            h2:{bootStatus: 'REGISTERED', hostName: '', name: 'n2'}
          },
          m: 'registered hosts available',
          e: ['n1', 'n2']
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {hosts: test.hosts});
          var hosts = installerStep8Controller.getRegisteredHosts();
          expect(hosts.mapProperty('hostName')).to.eql(test.e);
        });
      });
  });

  describe('#loadRepoInfo', function() {
    it('should use App.currentStackVersion', function() {
      var version = 'HDP-1.1.1';
      sinon.stub(App, 'get', function() {return version;});
      sinon.stub(App.ajax, 'send', Em.K);
      installerStep8Controller.loadRepoInfo();
      var data = App.ajax.send.args[0][0].data;
      expect(data).to.eql({stackName: 'HDP', stackVersion: '1.1.1'});
      App.ajax.send.restore();
      App.get.restore();
    });
  });

  describe('#loadRepoInfoSuccessCallback', function () {
    beforeEach(function () {
      installerStep8Controller.set('clusterInfo', Em.Object.create({}));
    });
    Em.A([
        {
          items: [],
          m: 'no data',
          e: {
            base_url: [],
            os_type: []
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'only redhat5',
          e: {
            base_url: ['url1'],
            os_type: ['redhat5']
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'redhat5, redhat6',
          e: {
            base_url: ['url1', 'url2'],
            os_type: ['redhat5', 'redhat6']
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'sles11',
                    base_url: 'url3'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'redhat5, redhat6, sles11',
          e: {
            base_url: ['url1', 'url2', 'url3'],
            os_type: ['redhat5', 'redhat6', 'sles11']
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.loadRepoInfoSuccessCallback({items: test.items});
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('base_url')).to.eql(test.e.base_url);
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('os_type')).to.eql(test.e.os_type);
        });
      });
  });

  describe('#loadRepoInfoErrorCallback', function() {
    it('should set [] to repoInfo', function() {
      installerStep8Controller.set('clusterInfo', Em.Object.create({repoInfo: [{}, {}]}));
      installerStep8Controller.loadRepoInfoErrorCallback({});
      expect(installerStep8Controller.get('clusterInfo.repoInfo.length')).to.eql(0);
    });
  });

  describe('#loadHiveDbValue', function() {
    beforeEach(function() {
      installerStep8Controller.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });
    Em.A([
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'New MySQL Database'}
          ],
          m: 'New MySQL Database',
          e: 'MySQL (New Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'New PostgreSQL Database'}
          ],
          m: 'New PostgreSQL Database',
          e: 'Postgres (New Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'Existing MySQL Database'},
            {name: 'hive_existing_mysql_database', value: 'dbname'}
          ],
          m: 'Existing MySQL Database',
          e: 'dbname (Existing MySQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'Existing PostgreSQL Database'},
            {name: 'hive_existing_postgresql_database', value: 'dbname'}
          ],
          m: 'Existing PostgreSQL Database',
          e: 'dbname (Existing PostgreSQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'Existing Oracle Database'},
            {name: 'hive_existing_oracle_database', value: 'dbname'}
          ],
          m: 'Existing Oracle Database',
          e: 'dbname (Existing Oracle Database)'
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          sinon.stub(installerStep8Controller.get('wizardController'), 'getDBProperty', function() {
            return test.serviceConfigProperties;
          });
          var dbComponent = installerStep8Controller.loadHiveDbValue();
          expect(dbComponent).to.equal(test.e);
          installerStep8Controller.get('wizardController').getDBProperty.restore();
        });
      });
  });

  describe('#loadHbaseMasterValue', function () {
    Em.A([
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'one host',
          e: 'h1'
        },
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}, {component: 'HBASE_MASTER', hostName: 'h2'}, {component: 'HBASE_MASTER', hostName: 'h3'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'many hosts',
          e: 'h1 ' + Em.I18n.t('installer.step8.other').format(2)
        }
      ]).forEach(function (test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadHbaseMasterValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadZkServerValue', function() {
    Em.A([
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: '1 host',
          e: '1 host'
        },
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: 'many hosts',
          e: '3 hosts'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadZkServerValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadOozieDbValue', function() {
    beforeEach(function() {
      installerStep8Controller.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });
    Em.A([
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'New Derby Database'},
            {name: 'oozie_derby_database', value: 'dbname'}
          ],
          m: 'New Derby Database',
          e: 'dbname (New Derby Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'Existing MySQL Database'},
            {name: 'oozie_existing_mysql_database', value: 'dbname'}
          ],
          m: 'Existing MySQL Database',
          e: 'dbname (Existing MySQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'Existing PostgreSQL Database'},
            {name: 'oozie_existing_postgresql_database', value: 'dbname'}
          ],
          m: 'Existing PostgreSQL Database',
          e: 'dbname (Existing PostgreSQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'Existing Oracle Database'},
            {name: 'oozie_existing_oracle_database', value: 'dbname'}
          ],
          m: 'Existing Oracle Database',
          e: 'dbname (Existing Oracle Database)'
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          sinon.stub(installerStep8Controller.get('wizardController'), 'getDBProperty', function() {
            return test.serviceConfigProperties;
          });
          var dbComponent = installerStep8Controller.loadOozieDbValue();
          expect(dbComponent).to.equal(test.e);
          installerStep8Controller.get('wizardController').getDBProperty.restore();
        });
      });
  });

  describe('#loadNagiosAdminValue', function() {
    it('should use serviceConfigProperties nagios_web_login and nagios_contact', function() {
      installerStep8Controller.set('content', {
        serviceConfigProperties: [
          {name: 'nagios_web_login', value: 'admin'},
          {name: 'nagios_contact', value: 'admin@admin.com'}
        ]
      });
      var nagiosAdmin = installerStep8Controller.loadNagiosAdminValue();
      expect(nagiosAdmin).to.equal('admin / (admin@admin.com)');
    });
  });

  describe('#submit', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'submitProceed', Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });
    afterEach(function() {
      installerStep8Controller.submitProceed.restore();
      App.showConfirmationPopup.restore();
    });
    Em.A([
        {
          controllerName: 'addHostController',
          securityEnabled: true,
          e: true
        },
        {
          controllerName: 'addHostController',
          securityEnabled: false,
          e: false
        },
        {
          controllerName: 'addServiceController',
          securityEnabled: true,
          e: false
        },
        {
          controllerName: 'addServiceController',
          securityEnabled: false,
          e: false
        }
      ]).forEach(function (test) {
        it(test.controllerName + ' ' + test.securityEnabled.toString(), function () {
          installerStep8Controller.reopen({isSubmitDisabled: false, securityEnabled: test.securityEnabled, content: {controllerName: test.controllerName}});
          installerStep8Controller.submit();
          if (test.e) {
            expect(App.showConfirmationPopup.calledOnce).to.equal(true);
            expect(installerStep8Controller.submitProceed.called).to.equal(false);
          }
          else {
            expect(App.showConfirmationPopup.called).to.equal(false);
            expect(installerStep8Controller.submitProceed.calledOnce).to.equal(true);
          }
        });
      });
    it('should call submitProceed when Ok clicked', function() {
      installerStep8Controller.reopen({isSubmitDisabled: false, securityEnabled: true, content: {controllerName: 'addHostController'}});
      installerStep8Controller.submit().onPrimary();
      expect(installerStep8Controller.submitProceed.calledOnce).to.equal(true);
    });
    it('shouldn\'t do nothing if isSubmitDisabled is true', function() {
      installerStep8Controller.reopen({isSubmitDisabled: true});
      installerStep8Controller.submit();
      expect(App.showConfirmationPopup.called).to.equal(false);
      expect(installerStep8Controller.submitProceed.called).to.equal(false);
    });
  });

  describe('#getExistingClusterNamesSuccessCallBack', function() {
    it('should set clusterNames received from server', function() {
      var data = {
          items:[
            {Clusters: {cluster_name: 'c1'}},
            {Clusters: {cluster_name: 'c2'}},
            {Clusters: {cluster_name: 'c3'}}
          ]
        },
        clasterNames = ['c1','c2','c3'];
      installerStep8Controller.getExistingClusterNamesSuccessCallBack(data);
      expect(installerStep8Controller.get('clusterNames')).to.eql(clasterNames);
    });
  });

  describe('#getExistingClusterNamesErrorCallback', function() {
    it('should set [] to clusterNames', function() {
      installerStep8Controller.set('clusterNames', ['c1', 'c2']);
      installerStep8Controller.getExistingClusterNamesErrorCallback();
      expect(installerStep8Controller.get('clusterNames')).to.eql([]);
    });
  });

  describe('#deleteClusters', function() {
    it('should call App.ajax.send for each provided clusterName', function() {
      sinon.stub(App.ajax, 'send', Em.K);
      var clusterNames = ['h1', 'h2', 'h3'];
      installerStep8Controller.deleteClusters(clusterNames);
      expect(App.ajax.send.callCount).to.equal(clusterNames.length);
      clusterNames.forEach(function(n, i) {
        expect(App.ajax.send.getCall(i).args[0].data).to.eql({name: n, isLast: i == clusterNames.length - 1});
      });
      App.ajax.send.restore();
    });
  });

  describe('#createSelectedServicesData', function() {
    it('should reformat provided data', function() {
      var selectedServices = [
        Em.Object.create({serviceName: 's1'}),
        Em.Object.create({serviceName: 's2'}),
        Em.Object.create({serviceName: 's3'})
      ];
      var expected = [
        {"ServiceInfo": { "service_name": 's1' }},
        {"ServiceInfo": { "service_name": 's2' }},
        {"ServiceInfo": { "service_name": 's3' }}
      ];
      installerStep8Controller.reopen({selectedServices: selectedServices});
      var createdData = installerStep8Controller.createSelectedServicesData();
      expect(createdData).to.eql(expected);
    });
  });

  describe('#createRegisterHostData', function() {
    it('should return empty data if no hosts', function() {
      sinon.stub(installerStep8Controller, 'getRegisteredHosts', function() {return [];});
      expect(installerStep8Controller.createRegisterHostData()).to.eql([]);
      installerStep8Controller.getRegisteredHosts.restore();
    });
    it('should return computed data', function() {
      var data = [
        {isInstalled: false, hostName: 'h1'},
        {isInstalled: true, hostName: 'h2'},
        {isInstalled: false, hostName: 'h3'}
      ];
      var expected = [
        {"Hosts": { "host_name": 'h1'}},
        {"Hosts": { "host_name": 'h3'}}
      ];
      sinon.stub(installerStep8Controller, 'getRegisteredHosts', function() {return data;});
      expect(installerStep8Controller.createRegisterHostData()).to.eql(expected);
      installerStep8Controller.getRegisteredHosts.restore();
    });
  });


  describe('#createStormSiteObj', function() {
    it('should replace quote \'"\' to "\'" for some properties', function() {
      var configs = [
          {filename: 'storm-site.xml', value: ["a", "b"], name: 'storm.zookeeper.servers'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            'storm.zookeeper.servers': '[\'a\',\'b\']'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj('version1')).to.eql(expected);
    });

    it('should not escape special characters', function() {
      var configs = [
          {filename: 'storm-site.xml', value: "abc\n\t", name: 'nimbus.childopts'},
          {filename: 'storm-site.xml', value: "a\nb", name: 'supervisor.childopts'},
          {filename: 'storm-site.xml', value: "a\t\tb", name: 'worker.childopts'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            'nimbus.childopts': 'abc\n\t',
            'supervisor.childopts': 'a\nb',
            'worker.childopts': 'a\t\tb'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj('version1')).to.eql(expected);
    });
  });

  describe('#ajaxQueueFinished', function() {
    it('should call App.router.next', function() {
      sinon.stub(App.router, 'send', Em.K);
      installerStep8Controller.ajaxQueueFinished();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#addRequestToAjaxQueue', function() {
    describe('testMode = true', function() {
      before(function() {
        App.set('testMode', true);
      });
      after(function() {
        App.set('testMode', false);
      });
      it('shouldn\'t do nothing', function() {
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({});
        expect(installerStep8Controller.get('ajaxRequestsQueue.queue.length')).to.equal(0);
      });
    });
    describe('testMode = true', function() {
      before(function() {
        App.set('testMode', false);
      });
      it('should add request', function() {
        var clusterName = 'c1';
        installerStep8Controller.reopen({clusterName: clusterName});
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({name:'name', data:{}});
        var request = installerStep8Controller.get('ajaxRequestsQueue.queue.firstObject');
        expect(request.error).to.equal('ajaxQueueRequestErrorCallback');
        expect(request.data.cluster).to.equal(clusterName);
      });
    });
  });

  describe('#ajaxQueueRequestErrorCallback', function() {
    var obj = Em.Object.create({
      registerErrPopup: Em.K,
      setStepsEnable: Em.K
    });
    beforeEach(function() {
      sinon.stub(App.router, 'get', function() {
        return obj;
      });
      sinon.spy(obj, 'registerErrPopup');
      sinon.spy(obj, 'setStepsEnable');
    });
    afterEach(function() {
      App.router.get.restore();
      obj.registerErrPopup.restore();
      obj.setStepsEnable.restore();
    });
    it('should set hasErrorOccurred true', function () {
      installerStep8Controller.set('hasErrorOccurred', false);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('hasErrorOccurred')).to.equal(true);
    });
    it('should set isSubmitDisabled false', function () {
      installerStep8Controller.set('isSubmitDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled false', function () {
      installerStep8Controller.set('isBackBtnDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
    it('should call setStepsEnable', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.setStepsEnable.calledOnce).to.equal(true);
    });
    it('should call registerErrPopup', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.registerErrPopup.calledOnce).to.equal(true);
    });
  });

  describe('#removeInstalledServicesConfigurationGroups', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'deleteConfigGroup', Em.K);
    });
    afterEach(function() {
      App.config.deleteConfigGroup.restore();
    });
    it('should call App.config.deleteConfigGroup for each received group', function() {
      var groups = [{}, {}, {}];
      installerStep8Controller.removeInstalledServicesConfigurationGroups(groups);
      expect(App.config.deleteConfigGroup.callCount).to.equal(groups.length);
    });
  });

  describe('#addDynamicProperties', function() {
    it('shouldn\'t add property', function() {
      var serviceConfigProperties = [
          {name: 'templeton.hive.properties'}
        ],
        configs = [];
      installerStep8Controller.reopen({content: {serviceConfigProperties: serviceConfigProperties}});
      installerStep8Controller.addDynamicProperties(configs);
      expect(configs.length).to.equal(0);
    });
    it('should add property', function() {
      var serviceConfigProperties = [],
        configs = [];
      installerStep8Controller.reopen({content: {serviceConfigProperties: serviceConfigProperties}});
      installerStep8Controller.addDynamicProperties(configs);
      expect(configs.length).to.equal(1);
    });
  });

  describe('#formatProperties', function() {

  });

  describe('#applyInstalledServicesConfigurationGroup', function() {
    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App.router, 'get', function() {
        return configurationController;
      });
    });
    afterEach(function() {
      $.ajax.restore();
      App.router.get.restore();
    });
    it('should do ajax request for each config group', function() {
      var configGroups = [{ConfigGroup: {id:''}}, {ConfigGroup: {id:''}}];
      installerStep8Controller.applyInstalledServicesConfigurationGroup(configGroups);
      expect($.ajax.callCount).to.equal(configGroups.length);
    });
  });

  describe('#getExistingClusterNames', function() {
    beforeEach(function() {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('should do ajax request', function() {
      installerStep8Controller.getExistingClusterNames();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#loadUiSideConfigs', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'addDynamicProperties', Em.K);
      sinon.stub(installerStep8Controller, 'getGlobConfigValueWithOverrides', function(t, v, n) {
        return {
          value: v,
          overrides: []
        }
      });
      sinon.stub(App.config, 'setConfigValue', Em.K);
    });
    afterEach(function() {
      installerStep8Controller.addDynamicProperties.restore();
      installerStep8Controller.getGlobConfigValueWithOverrides.restore();
      App.config.setConfigValue.restore();
    });

    it('all configs witohut foreignKey', function() {
      var configMapping = [
        {foreignKey: null, templateName: 't1', value: 'v1', name: 'c1', filename: 'f1'},
        {foreignKey: null, templateName: 't2', value: 'v2', name: 'c2', filename: 'f2'},
        {foreignKey: null, templateName: 't3', value: 'v3', name: 'c3', filename: 'f2'},
        {foreignKey: null, templateName: 't4', value: 'v4', name: 'c4', filename: 'f1'}
      ];
      var uiConfigs = installerStep8Controller.loadUiSideConfigs(configMapping);
      expect(uiConfigs.length).to.equal(configMapping.length);
      expect(uiConfigs.everyProperty('id', 'site property')).to.be.true;
      uiConfigs.forEach(function(c, index) {
        expect(c.overrides).to.be.an.array;
        expect(c.value).to.equal(configMapping[index].value);
        expect(c.name).to.equal(configMapping[index].name);
        expect(c.filename).to.equal(configMapping[index].filename);
      });
    });

    it('some configs witohut foreignKey', function() {
      var configMapping = [
        {foreignKey: null, templateName: 't1', value: 'v1', name: 'c1', filename: 'f1'},
        {foreignKey: null, templateName: 't2', value: 'v2', name: 'c2', filename: 'f2'},
        {foreignKey: null, templateName: 't3', value: 'v3', name: 'c3', filename: 'f2'},
        {foreignKey: null, templateName: 't4', value: 'v4', name: 'c4', filename: 'f1'},
        {foreignKey: 'fk1', templateName: 't5', value: 'v5', name: 'c5', filename: 'f1'},
        {foreignKey: 'fk2', templateName: 't6', value: 'v6', name: 'c6', filename: 'f1'},
        {foreignKey: 'fk3', templateName: 't7', value: 'v7', name: 'c7', filename: 'f2'},
        {foreignKey: 'fk4', templateName: 't8', value: 'v8', name: 'c8', filename: 'f2'}
      ];
      var uiConfigs = installerStep8Controller.loadUiSideConfigs(configMapping);
      expect(uiConfigs.length).to.equal(configMapping.length);
      expect(uiConfigs.everyProperty('id', 'site property')).to.be.true;
      uiConfigs.forEach(function(c, index) {
        if (Em.isNone(configMapping[index].foreignKey))
          expect(c.overrides).to.be.an.array;
        expect(c.value).to.equal(configMapping[index].value);
        expect(c.name).to.equal(configMapping[index].name);
        expect(c.filename).to.equal(configMapping[index].filename);
      });
    });
  });

  describe('Queued requests', function() {

    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'addRequestToAjaxQueue', Em.K);
    });

    afterEach(function() {
      installerStep8Controller.addRequestToAjaxQueue.restore();
    });

    describe('#createCluster', function() {
      it('shouldn\'t add request to queue if not installerController used', function() {
        installerStep8Controller.reopen({content: {controllerName: 'addServiceController'}});
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });
      it('App.currentStackVersion should be changed if localRepo selected', function() {
        App.set('currentStackVersion', 'HDP-1.1.1');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: true}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDPLocal-1.1.1' }})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql(data);
      });
      it('App.currentStackVersion shouldn\'t be changed if localRepo ins\'t selected', function() {
        App.set('currentStackVersion', 'HDP-1.1.1');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: false}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDP-1.1.1' }})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql(data);
      });
    });

    describe('#createSelectedServices', function() {
      it('shouldn\'t do nothing if no data', function() {
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function() {return [];});
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
        installerStep8Controller.createSelectedServicesData.restore();
      });
      it('should call addRequestToAjaxQueue with computed data', function() {
        var data = [
          {"ServiceInfo": { "service_name": 's1' }},
          {"ServiceInfo": { "service_name": 's2' }},
          {"ServiceInfo": { "service_name": 's3' }}
        ];
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function() {return data;});
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: JSON.stringify(data)});
        installerStep8Controller.createSelectedServicesData.restore();
      });
    });

    describe('#registerHostsToCluster', function() {
      it('shouldn\'t do nothing if no data', function() {
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function() {return [];});
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
        installerStep8Controller.createRegisterHostData.restore();
      });
      it('should call addRequestToAjaxQueue with computed data', function() {
        var data = [
          {"Hosts": { "host_name": 'h1'}},
          {"Hosts": { "host_name": 'h3'}}
        ];
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function() {return data;});
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: JSON.stringify(data)});
        installerStep8Controller.createRegisterHostData.restore();
      });
    });

    describe('#registerHostsToComponent', function() {

      it('shouldn\'t do request if no hosts provided', function() {
        installerStep8Controller.registerHostsToComponent([]);
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('should do request if hostNames are provided', function() {
        var hostNames = ['h1', 'h2'],
          componentName = 'c1';
        installerStep8Controller.registerHostsToComponent(hostNames, componentName);
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(data.RequestInfo.query).to.equal('Hosts/host_name=h1|Hosts/host_name=h2');
        expect(data.Body.host_components[0].HostRoles.component_name).to.equal('c1');
      });

    });

    describe('#applyConfigurationsToCluster', function() {
      it('should call addRequestToAjaxQueue', function() {
        var serviceConfigTags = [
            {
              type: 'hdfs',
              tag: 'tag1',
              properties: [
                {},
                {}
              ]
            }
          ],
          data = '['+JSON.stringify({
            Clusters: {
              desired_config: [serviceConfigTags[0]]
            }
          })+']';
        installerStep8Controller.reopen({
          installedServices: [
              Em.Object.create({
                isSelected: true,
                isInstalled: false,
                configTypesRendered: {hdfs:'tag1'}
              })
            ], selectedServices: []
        });
        installerStep8Controller.applyConfigurationsToCluster(serviceConfigTags);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: data});
      });
    });

    describe('#applyConfigurationGroups', function() {
      it('should call addRequestToAjaxQueue', function() {
        var data = [{}, {}];
        installerStep8Controller.applyConfigurationGroups(data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: JSON.stringify(data)});
      });
    });

    describe('#newServiceComponentErrorCallback', function() {

      it('should add request for new component', function() {
        var serviceName = 's1',
          componentName = 'c1';
        installerStep8Controller.newServiceComponentErrorCallback({}, {}, '', {}, {serviceName: serviceName, componentName: componentName});
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.serviceName).to.equal(serviceName);
        expect(data.components[0].ServiceComponentInfo.component_name).to.equal(componentName);
      });

    });


    describe('#createAdditionalHostComponents', function() {

      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });

      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });

      it('should add GANGLIA MONITOR (1)', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1'}, {hostName: 'h2'}];
          },
          content: {
            services: [
              Em.Object.create({serviceName: 'GANGLIA', isSelected: true, isInstalled: false})
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
      });

      it('should add GANGLIA MONITOR (2)', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1', isInstalled: true}, {hostName: 'h2', isInstalled: false}];
          },
          content: {
            services: [
              Em.Object.create({serviceName: 'GANGLIA', isSelected: true, isInstalled: true})
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
      });

      var newDatabases = [
        {name: 'New MySQL Database',
         component: 'MYSQL_SERVER'
        },
        {name: 'New PostgreSQL Database',
          component: 'POSTGRESQL_SERVER'
        },
      ];

      newDatabases.forEach(function (db) {
        it('should add {0}'.format(db.component), function() {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1'}, {hostName: 'h2'}];
            },
            content: {
              masterComponentHosts: [
                {component: 'HIVE_SERVER', hostName: 'h1'},
                {component: 'HIVE_SERVER', hostName: 'h2'}
              ],
              services: [
                Em.Object.create({serviceName: 'HIVE', isSelected: true, isInstalled: false})
              ],
              serviceConfigProperties: [
                {name: 'hive_database', value: db.name}
              ]
            }
          });
          installerStep8Controller.createAdditionalHostComponents();
          expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal(db.component);
        });

      });

    });


  });

  describe("#resolveProxyuserDependecies()", function() {
    it("No core-site configs", function() {
      expect(installerStep8Controller.resolveProxyuserDependecies([], [])).to.be.empty;
    });
    it("Only proxyuser group config", function() {
      var configs = [{
        name: 'proxyuser_group'
      }];
      installerStep8Controller.set('configs', [{
        name: 'proxyuser_group',
        value: 'val1'
      }]);
      expect(installerStep8Controller.resolveProxyuserDependecies(configs, [])).to.be.empty;
    });
    it("Property should be added", function() {
      var configs = [
        {
          name: 'proxyuser_group'
        },
        {
          name: 'hadoop.proxyuser.user.hosts',
          value: 'val2'
        }
      ];
      installerStep8Controller.set('configs', [{
        name: 'proxyuser_group',
        value: 'val1'
      }]);
      expect(installerStep8Controller.resolveProxyuserDependecies(configs, [])).to.be.eql({
        'hadoop.proxyuser.user.hosts': 'val2',
        'proxyuser_group': 'val1'
      });
    });
    it("Property should be skipped", function() {
      var configs = [
        {
          name: 'proxyuser_group'
        },
        {
          name: 'hadoop.proxyuser.user.hosts',
          value: 'val2'
        }
      ];
      installerStep8Controller.set('configs', [
        {
          name: 'proxyuser_group',
          value: 'val1'
        },
        {
          name: 'user1',
          value: 'user'
        }
      ]);
      installerStep8Controller.set('optionalCoreSiteConfigs', [
        {
          serviceName: 'S1',
          user: 'user1'
        }
      ]);
      expect(installerStep8Controller.resolveProxyuserDependecies(configs, [])).to.be.empty;
    });
  });

});

});

;require.register("test/controllers/wizard/step9_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Ember = require('ember');
var App = require('app');
require('models/stack_service_component');
require('models/hosts');
require('controllers/wizard');
require('controllers/installer');
require('controllers/wizard/step9_controller');
require('utils/helper');
require('utils/ajax/ajax');

var modelSetup = require('test/init_model_test');
var c, obj;
describe('App.InstallerStep9Controller', function () {
  beforeEach(function () {
    modelSetup.setupStackServiceComponent();
    c = App.WizardStep9Controller.create({
      content: {controllerName: ''},
      saveClusterStatus: Em.K,
      saveInstalledHosts: Em.K,
      togglePreviousSteps: Em.K,
      wizardController: Em.Object.create({
        requestsId: [],
        cluster: {oldRequestsId: []},
        getDBProperty: function(name) {
          return this.get(name);
        }
      })
    });
    obj = App.InstallerController.create();
    sinon.stub(App.ajax, 'send', function() {
      return {
        retry: function() {
          return {
            then: Em.K,
            complete: Em.K
          };
        },
        complete: Em.K
      };
    });
  });
  afterEach(function () {
    modelSetup.cleanStackServiceComponent();
    App.ajax.send.restore();
  });

  describe('#isSubmitDisabled', function () {
    var tests = Em.A([
      {controllerName: 'addHostController', state: 'STARTED', e: false},
      {controllerName: 'addHostController', state: 'START FAILED', e: false},
      {controllerName: 'addHostController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addHostController', state: 'PENDING', e: true},
      {controllerName: 'addHostController', state: 'INSTALLED', e: true},
      {controllerName: 'addServiceController', state: 'STARTED', e: false},
      {controllerName: 'addServiceController', state: 'START FAILED', e: false},
      {controllerName: 'addServiceController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addServiceController', state: 'PENDING', e: true},
      {controllerName: 'addServiceController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'STARTED', e: false},
      {controllerName: 'installerController', state: 'START FAILED', e: false},
      {controllerName: 'installerController', state: 'INSTALL FAILED', e: true},
      {controllerName: 'installerController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'PENDING', e: true}
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        saveClusterStatus: Em.K,
        saveInstalledHosts: Em.K,
        content: {
          controllerName: test.controllerName,
          cluster: {
            status: test.state
          }
        }
      });
      it('controllerName is ' + test.controllerName + '; cluster status is ' + test.state + '; isSubmitDisabled should be ' + test.e, function () {
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });

  });

  describe('#status', function () {
    var tests = Em.A([
      {
        hosts: [
          {status: 'failed'},
          {status: 'success'}
        ],
        isStepFailed: false,
        progress: '100',
        m: 'One host is failed',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is not failed',
        isStepFailed: false,
        progress: '100',
        e: 'warning'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is failed',
        isStepFailed: true,
        progress: '100',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 100',
        isStepFailed: false,
        progress: '100',
        e: 'success'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 50',
        isStepFailed: false,
        progress: '50',
        e: 'info'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        saveClusterStatus: Em.K,
        saveInstalledHosts: Em.K,
        hosts: test.hosts,
        isStepFailed: function () {
          return test.isStepFailed
        },
        progress: test.progress
      });
      controller.updateStatus();
      it(test.m, function () {
        expect(controller.get('status')).to.equal(test.e);
      });
    });
  });

  describe('#showRetry', function () {
    it('cluster status is not INSTALL FAILED', function () {
      c.reopen({content: {cluster: {status: 'INSTALLED'}}});
      expect(c.get('showRetry')).to.equal(false);
    });
    it('cluster status is INSTALL FAILED', function () {
      c.reopen({content: {cluster: {status: 'INSTALL FAILED'}}});
      expect(c.get('showRetry')).to.equal(true);
    });
  });

  describe('#resetHostsForRetry', function () {
    it('All should have status "pending" and message "Waiting"', function () {
      var hosts = {'host1': Em.Object.create({status: 'failed', message: 'Failed'}), 'host2': Em.Object.create({status: 'success', message: 'Success'})};
      c.reopen({content: {hosts: hosts}});
      c.resetHostsForRetry();
      for (var name in hosts) {
        if (hosts.hasOwnProperty(name)) {
          expect(c.get('content.hosts')[name].get('status', 'pending')).to.equal('pending');
          expect(c.get('content.hosts')[name].get('message', 'Waiting')).to.equal('Waiting');
        }
      }
    });
  });

  var hosts_for_load_and_render = {
    'host1': {
      message: 'message1',
      status: 'unknown',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: 'REGISTERED'
    },
    'host2': {
      message: '',
      status: 'failed',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host3': {
      message: '',
      status: 'waiting',
      progress: null,
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host4': {
      message: 'message4',
      status: null,
      progress: '10',
      logTasks: [
        {}
      ],
      bootStatus: 'REGISTERED'
    }
  };

  describe('#loadHosts', function () {

    beforeEach(function() {
      c.reopen({content: {hosts: hosts_for_load_and_render}});
      c.loadHosts();
    });

    it('Only REGISTERED hosts', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.length).to.equal(2);
    });
    it('All hosts have progress 0', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.everyProperty('progress', 0)).to.equal(true);
    });
    it('All hosts have progress 0', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.everyProperty('progress', 0)).to.equal(true);
    });
    it('All host don\'t have logTasks', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.everyProperty('logTasks.length', 0)).to.equal(true);
    });
  });

  describe('#hostHasClientsOnly', function () {
    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'old_status', progress: '10'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: false
      },
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: true
      }
    ]);
    tests.forEach(function (test) {
      it('', function () {
        c.reopen({hosts: test.hosts});
        c.hostHasClientsOnly(test.jsonError);
        test.hosts.forEach(function (host) {
          expect(c.get('hosts').findProperty('hostName', host.hostName).get('status')).to.equal(host.e.status);
          expect(c.get('hosts').findProperty('hostName', host.hostName).get('progress')).to.equal(host.e.progress);
        });
      });
    });
  });

  describe('#onSuccessPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'success'},
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'success'},
        m: 'All Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'All Tasks COMPLETED and cluster status FAILED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status FAILED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}});
        c.onSuccessPerHost(test.actions, test.host);
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#onErrorPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'pending'},
        isMasterFailed: false,
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'ABORTED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task ABORTED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'TIMEDOUT'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task TIMEDOUT and cluster status INSTALLED'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'failed'},
        isMasterFailed: true,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed true'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed false'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}, isMasterFailed: function () {
          return test.isMasterFailed;
        }});
        c.onErrorPerHost(test.actions, test.host);
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#isMasterFailed', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves')
          return ["TASKTRACKER", "DATANODE", "JOURNALNODE", "ZKFC", "APP_TIMELINE_SERVER", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    var tests = Em.A([
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'DATANODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'No one Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: true,
        m: 'One Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'PENDING', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'one Master is failed but command is not install'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        expect(c.isMasterFailed(test.actions)).to.equal(test.e);
      });
    });
  });

  describe('#onInProgressPerHost', function () {
    var tests = Em.A([
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: true},
        m: 'All Tasks COMPLETED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'IN_PROGRESS'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task IN_PROGRESS'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task QUEUED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'PENDING'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task PENDING'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.onInProgressPerHost(test.actions, test.host);
        expect(test.host.message == test.e.message).to.equal(test.e.b);
      });
    });
  });

  describe('#progressPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'IN_PROGRESS'}}
        ],
        e: {ret: 17, host: '17'},
        m: 'All types of status available. cluster status PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: [],
        e: {ret: 33, host: '33'},
        m: 'No tasks available. cluster status PENDING'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: [],
        e: {ret: 100, host: '100'},
        m: 'No tasks available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'IN_PROGRESS'}}
        ],
        e: {ret: 68, host: '68'},
        m: 'All types of status available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({progress: 0}),
        actions: [],
        e: {ret: 100, host: '100'},
        m: 'Cluster status is not PENDING or INSTALLED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}});
        var progress = c.progressPerHost(test.actions, test.host);
        expect(progress).to.equal(test.e.ret);
        expect(test.host.progress).to.equal(test.e.host);
      });
    });
  });

  describe('#clearStep', function () {
    it('All to default values', function () {
      c.reopen({hosts: [{},{},{}]});
      c.clearStep();
      expect(c.get('hosts.length')).to.equal(0);
      expect(c.get('status')).to.equal('info');
      expect(c.get('progress')).to.equal('0');
      expect(c.get('numPolls')).to.equal(1);
    });
  });

  describe('#replacePolledData', function () {
    it('replacing polled data', function () {
      c.reopen({polledData: [{},{},{}]});
      var newPolledData = [{}];
      c.replacePolledData(newPolledData);
      expect(c.get('polledData.length')).to.equal(newPolledData.length);
    });
  });

  describe('#isSuccess', function () {
    var tests = Em.A([
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: true,
        m: 'All tasks are COMPLETED'
      },
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'FAILED'}}
        ],
        e: false,
        m: 'Not all tasks are COMPLETED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        expect(c.isSuccess(test.polledData)).to.equal(test.e);
      });
    });
  });

  describe('#isStepFailed', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves')
          return ["TASKTRACKER", "DATANODE", "JOURNALNODE", "ZKFC", "APP_TIMELINE_SERVER", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    var tests = Em.A([
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: true,
        m: 'GANGLIA_MONITOR 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: false,
        m: 'GANGLIA_MONITOR 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: true,
        m: 'HBASE_REGIONSERVER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: false,
        m: 'HBASE_REGIONSERVER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: true,
        m: 'TASKTRACKER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: false,
        m: 'TASKTRACKER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'DATANODE 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'DATANODE 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'NAMENODE failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'Nothing failed failed'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({polledData: test.polledData});
        expect(c.isStepFailed()).to.equal(test.e);
      });
    });
  });

  describe('#setLogTasksStatePerHost', function () {
    var tests = Em.A([
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [],
        e: {m: 'COMPLETED', l: 2},
        m: 'host didn\'t have tasks and got 2 new'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 2},
        m: 'host had 2 tasks and got both updated'
      },
      {
        tasksPerHost: [],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'IN_PROGRESS', l: 2},
        m: 'host had 2 tasks and didn\'t get updates'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}},
          {Tasks: {id: 3, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 3},
        m: 'host had 2 tasks and got both updated and 1 new'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({hosts: [Em.Object.create({logTasks: test.tasks})]});
        c.setLogTasksStatePerHost(test.tasksPerHost, c.get('hosts')[0]);
        expect(c.get('hosts')[0].get('logTasks').everyProperty('Tasks.status', test.e.m)).to.equal(true);
        expect(c.get('hosts')[0].get('logTasks.length')).to.equal(test.e.l);
      });
    });
  });

 // On completion of Start all services error callback function,
  // Cluster Status should be INSTALL FAILED
  // All progress bar on the screen should be finished (100%) with blue color.
  // Retry button should be enabled, next button should be disabled

  describe('#launchStartServicesErrorCallback', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    it('Main progress bar on the screen should be finished (100%) with red color', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('progress')).to.equal('100');
      expect(c.get('status')).to.equal('failed');
    });

    it('All Host progress bars on the screen should be finished (100%) with blue color', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      c.get('hosts').forEach(function (host) {
        expect(host.get('progress')).to.equal('100');
        expect(host.get('status')).to.equal('info');
      });
    });

    it('Next button should be disabled', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

  });

  describe('#submit', function () {
    it('should call App.router.send', function () {
      sinon.stub(App.router, 'send', Em.K);
      c.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#back', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it('should call App.router.send', function () {
      c.reopen({isSubmitDisabled: false});
      c.back();
      expect(App.router.send.calledWith('back')).to.equal(true);
    });
    it('shouldn\'t call App.router.send', function () {
      c.reopen({isSubmitDisabled: true});
      c.back();
      expect(App.router.send.called).to.equal(false);
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'clearStep', Em.K);
      sinon.stub(c, 'loadHosts', Em.K);
    });
    afterEach(function () {
      c.clearStep.restore();
      c.loadHosts.restore();
    });
    it('should call clearStep', function () {
      c.loadStep();
      expect(c.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadHosts', function () {
      c.loadStep();
      expect(c.loadHosts.calledOnce).to.equal(true);
    });
  });

  describe('#startPolling', function () {
    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequestErrorCallback', Em.K);
    });
    afterEach(function () {
      c.getLogsByRequestErrorCallback.restore();
    });
    it('should set isSubmitDisabled to true', function () {
      c.set('isSubmitDisabled', false);
      c.startPolling();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
    it('should call doPolling', function () {
      sinon.stub(c, 'doPolling', Em.K);
      c.startPolling();
      expect(c.doPolling.calledOnce).to.equal(true);
      c.doPolling.restore();
    });
  });

  describe('#loadLogData', function () {

    beforeEach(function () {
      obj.reopen({
        cluster: {oldRequestsId: [1,2,3]},
        getDBProperty: function (name) {
          return this.get(name);
        }
      });
      c.reopen({wizardController: obj});
      sinon.stub(c, 'getLogsByRequest', Em.K);
    });

    afterEach(function () {
      c.getLogsByRequest.restore();
    });

    it('should call getLogsByRequest 1 time with 3', function () {
      c.loadLogData(true);
      expect(c.getLogsByRequest.calledWith(true, 3)).to.equal(true);
    });

    it('should set POLL_INTERVAL to 1 if testMode enabled', function () {
      sinon.stub(App, 'get', function(k) { if ('testMode' === k) return true; return Em.get(App, k);});
      c.loadLogData();
      expect(c.get('POLL_INTERVAL')).to.equal(1);
      App.get.restore();
    });

  });

  describe('#loadCurrentTaskLog', function () {
    beforeEach(function () {
      sinon.stub(c, 'loadLogData', Em.K);
      c.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });
    afterEach(function () {
      c.loadLogData.restore();
    });
    it('shouldn\'t call App.ajax.send if no currentOpenTaskId', function () {
      c.set('currentOpenTaskId', null);
      c.loadCurrentTaskLog();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should call App.ajax.send with provided data', function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      c.set('currentOpenTaskId', 1);
      c.set('currentOpenTaskRequestId', 2);
      c.set('content', {cluster: {name: 3}});
      c.loadCurrentTaskLog();
      expect(App.ajax.send.args[0][0].data).to.eql({taskId: 1, requestId: 2, clusterName: 3});
      c.togglePreviousSteps.restore();
    });
  });

  describe('#loadCurrentTaskLogSuccessCallback', function () {

    beforeEach(function() {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
    });

    afterEach(function() {
      c.getLogsByRequest.restore();
      c.loadLogData.restore();
    });

    it('should increment logTasksChangesCounter', function () {
      c.set('logTasksChangesCounter', 0);
      c.loadCurrentTaskLogSuccessCallback();
      expect(c.get('logTasksChangesCounter')).to.equal(1);
    });
    it('should update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('stdout');
      expect(t.stderr).to.equal('stderr');
    });
    it('shouldn\'t update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 2, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
    it('shouldn\'t update stdout, stderr (2)', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h2',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
  });

  describe('#loadCurrentTaskLogErrorCallback', function () {
    it('should set currentOpenTaskId to 0', function () {
      c.set('currentOpenTaskId', 123);
      c.loadCurrentTaskLogErrorCallback();
      expect(c.get('currentOpenTaskId')).to.equal(0);
    });
  });

  describe('#getLogsByRequest', function () {
    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
    });
    afterEach(function () {
      c.togglePreviousSteps.restore();
      c.loadLogData.restore();
    });
    it('should call App.ajax.send with provided data', function () {
      var polling = 1;
      var requestId = 2;
      c.set('content', {cluster: {name: 3}});
      c.set('numPolls', 4);
      c.getLogsByRequest(polling, requestId);
      expect(App.ajax.send.args[0][0].data).to.eql({polling: polling, requestId: requestId, cluster: 3, numPolls: 4});
    });
  });

  describe('#doPolling', function () {
    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.getLogsByRequest.restore();
      c.togglePreviousSteps.restore();
    });
    it('should increment numPolls if testMode', function () {
      App.set('testMode', true);
      c.set('numPolls', 0);
      c.doPolling();
      expect(c.get('numPolls')).to.equal(1);
      App.set('testMode', false);
    });
    it('should call getLogsByRequest', function () {
      c.set('content', {cluster: {requestId: 1}});
      c.doPolling();
      expect(c.getLogsByRequest.calledWith(true, 1)).to.equal(true);
    });
  });

  describe('#isAllComponentsInstalled', function () {
    it('shouldn\'t call App.ajax.send', function () {
      c.set('content', {controllerName: 'addServiceController'});
      c.isAllComponentsInstalled();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should call App.ajax.send', function () {
      c.set('content', {cluster: {name: 'n'}, controllerName: 'installerController'});
      c.isAllComponentsInstalled();
      expect(App.ajax.send.args[0][0].data).to.eql({cluster: 'n'});
    });
  });

  describe('#isAllComponentsInstalledErrorCallback', function () {
    beforeEach(function () {
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.togglePreviousSteps.restore();
    });
    it('should call saveClusterStatus', function () {
      c.isAllComponentsInstalledErrorCallback({});
      expect(c.saveClusterStatus.calledOnce).to.equal(true);
    });
  });

  describe('#navigateStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'loadStep', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
      sinon.stub(c, 'startPolling', Em.K);
    });
    afterEach(function () {
      c.togglePreviousSteps.restore();
      c.loadStep.restore();
      c.loadLogData.restore();
      c.startPolling.restore();
      App.get.restore();
    });
    it('should set custom data in testMode', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return true; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'st', isCompleted: true, requestId: 0}}});
      c.navigateStep();
      expect(c.get('content.cluster.status')).to.equal('PENDING');
      expect(c.get('content.cluster.isCompleted')).to.equal(false);
      expect(c.get('content.cluster.requestId')).to.equal(1);
    });
    it('isCompleted = true, requestId = 1', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {isCompleted: true, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
      expect(c.get('progress')).to.equal('100');
    });
    it('isCompleted = false, requestId = 1, status = INSTALL FAILED', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'INSTALL FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = START FAILED', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'START FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = OTHER', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'STARTED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(true)).to.equal(true);
    });
  });

  describe('#launchStartServicesSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', function() {
        return $.ajax();
      });
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'doPolling', Em.K);
      sinon.stub(c, 'hostHasClientsOnly', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.doPolling.restore();
      c.hostHasClientsOnly.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it('should call doPolling if some data were received', function () {
      c.launchStartServicesSuccessCallback({Requests: {id: 2}});
      expect(c.doPolling.calledOnce).to.equal(true);
    });
    Em.A([
        {
          jsonData: {Requests: {id: 2}},
          e: {
            hostHasClientsOnly: false,
            clusterStatus: {
              status: 'INSTALLED',
              requestId: 2,
              isStartError: false,
              isCompleted: false
            }
          }
        },
        {
          jsonData: null,
          e: {
            hostHasClientsOnly: true,
            clusterStatus: {
              status: 'STARTED',
              isStartError: false,
              isCompleted: true
            },
            status: 'success',
            progress: '100'
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.launchStartServicesSuccessCallback(test.jsonData);
          expect(c.hostHasClientsOnly.calledWith(test.e.hostHasClientsOnly)).to.equal(true);
          expect(c.saveClusterStatus.calledWith(test.e.clusterStatus)).to.equal(true);
          if (test.e.status) {
            expect(c.get('status')).to.equal(test.e.status);
          }
          if (test.e.progress) {
            expect(c.get('progress')).to.equal(test.e.progress);
          }
        });
      });
  });

});

});

;require.register("test/controllers/wizard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');

describe('App.WizardController', function () {

  var wizardController = App.WizardController.create({});

  var totalSteps = 11;
  var ruller = [];
  for(var i = 0; i < totalSteps; i++) {
    ruller.push(i);
  }

  describe('#setLowerStepsDisable', function() {
    for(var i = 1; i < totalSteps; i++) {
      var indx = i;
      var steps = [];
      for(var j = 1; j <= indx; j++) {
        steps.push(Em.Object.create({step:j,value:false}));
      }
      wizardController.set('isStepDisabled', steps);
      for(j = 1; j <= indx; j++) {
        it('Steps: ' + i + ' | Disabled: ' + (j-1), function() {
          wizardController.setLowerStepsDisable(j);
          expect(wizardController.get('isStepDisabled').filterProperty('value', true).length).to.equal(j-1);
        });
      }
    }
  });

  // isStep0 ... isStep10 tests
  App.WizardController1 = App.WizardController.extend({currentStep:''});
  var tests = [];
  for(var i = 0; i < totalSteps; i++) {
    var n = ruller.slice(0);
    n.splice(i,1);
    tests.push({i:i,n:n});
  }
  tests.forEach(function(test) {
    describe('isStep'+test.i, function() {
      var w = App.WizardController1.create();
      w.set('currentStep', test.i);
      it('Current Step is ' + test.i + ', so isStep' + test.i + ' is TRUE', function() {
        expect(w.get('isStep'+ test.i)).to.equal(true);
      });
      test.n.forEach(function(indx) {
        it('Current Step is ' + test.i + ', so isStep' + indx + ' is FALSE', function() {
          expect(w.get('isStep'+ indx)).to.equal(false);
        });
      });
    });
  });
  // isStep0 ... isStep10 tests end

  describe('#gotoStep', function() {
    var w = App.WizardController1.create();
    var steps = [];
    for(var j = 0; j < totalSteps; j++) {
      steps.push(Em.Object.create({step:j,value:false}));
    }
    steps.forEach(function(step, index) {
      step.set('value', true);
      w.set('isStepDisabled', steps);
      it('step ' + index + ' is disabled, so gotoStep('+index+') is not possible', function() {
        expect(w.gotoStep(index)).to.equal(false);
      });
    });
  });

  describe('#launchBootstrapSuccessCallback', function() {
    it('Save bootstrapRequestId', function() {
      var data = {requestId: 123};
      var params = {popup: {finishLoading: function(){}}};
      sinon.spy(params.popup, "finishLoading");
      wizardController.launchBootstrapSuccessCallback(data, {}, params);
      expect(params.popup.finishLoading.calledWith(123)).to.be.true;
      params.popup.finishLoading.restore();
    });
  });

});

});

;require.register("test/data/HDP2/secure_mapping_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
var mappedHdp2Properties = require('data/HDP2/secure_mapping');

describe('hdp2SiteMapping', function () {

  // All mapped properties should have value of string type
  mappedHdp2Properties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should be string', function () {
      expect(mappedProperty.value).to.be.a('string');
    });
  });
  mappedHdp2Properties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should have serviceName and filename attribute', function () {
      expect(mappedProperty).to.have.property('serviceName');
      expect(mappedProperty).to.have.property('filename');
    });
  });
});
});

;require.register("test/data/HDP2/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
var siteProperties = require('data/HDP2/site_properties').configProperties;

describe('hdp2SiteProperties', function () {

  // No site properties should be made invisible
  siteProperties.forEach(function(siteProperty){
    it('Check invisible attribute of "' + siteProperty.name  + '"' + '. It should not be defined ', function () {
      expect(siteProperty.isVisible).to.equal(undefined);
    });
  });

  // No site properties should have value and defaultValue defined on client side.
  // These should be always retrieved from server.

    siteProperties.forEach(function(siteProperty){
      it('Check value and defaultValue attribute of "' + siteProperty.name + '"' + '. It should not be defined ', function () {
        expect(siteProperty.value).to.equal(undefined);
        expect(siteProperty.defaultValue).to.equal(undefined);
    });
  });

  // No site properties should have description field duplicated on client side.
  // These should be always retrieved from server.
  siteProperties.forEach(function(siteProperty){
    it('Check description attribute of "' + siteProperty.name + '"' + '. It should not be defined ', function () {
      expect(siteProperty.description).to.equal(undefined);
    });
  });

  // All the site properties should be persisted in the configuration tag
  // So isRequiredByAgent should be never defined over here
  // These should be always retrieved from server and saved in the correct configuration resource via API.
  siteProperties.forEach(function(siteProperty){
    it('Check isRequiredByAgent attribute of "' + siteProperty.name + '"' + '. It should not be defined ', function () {
      expect(siteProperty.isRequiredByAgent).to.equal(undefined);
    });
  });

  // All Falcon site properties should be mapped to site file. There is a property with same name (*.domain)
  // in different site files of Falcon service

    var falconSiteProperties = siteProperties.filterProperty('serviceName','FALCON');
    falconSiteProperties.forEach(function(siteProperty){
      it('Check filename attribute for "' + siteProperty.name + '"' + ' property of Falcon service. It should be defined ', function () {
        expect(siteProperty).to.have.property('filename');
    });
  });

});
});

;require.register("test/data/secure_mapping_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
var mappedProperties = require('data/secure_mapping');

describe('hdp1SiteMapping', function () {

  // All mapped properties should have value of string type
  mappedProperties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should be string', function () {
      expect(mappedProperty.value).to.be.a('string');
    });
  });
  mappedProperties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should have serviceName and filename attribute', function () {
      expect(mappedProperty).to.have.property('serviceName');
      expect(mappedProperty).to.have.property('filename');
    });
  });
});
});

;require.register("test/init_model_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/stack_service_component');
require('mappers/server_data_mapper');
require('mappers/stack_service_mapper');

module.exports = {
  setupStackServiceComponent: function() {
    /**
     * initialization of App.StackServiceComponent and App.StackService models
     * @type {*}
     */
    App.stackServiceMapper.map(require('test/service_components'));
  },
  cleanStackServiceComponent: function() {
    App.StackServiceComponent.find().set('content',[]);
    App.StackService.find().set('content',[]);
  },
  setupStackVersion: function(context, version) {
    context.prevStackVersion = App.get('currentStackVersion');
    App.set('currentStackVersion', version);
  },
  restoreStackVersion: function(context) {
    App.set('currentStackVersion', context.prevStackVersion);
  },
  configs: require('test/mock_data_setup/configs_mock_data'),
  /**
   * Delete record from DS.Store and set its stateManager to proper state
   * @param {DS.Model} record
   * @method deleteRecord
   */
  deleteRecord: function (record) {
    record.deleteRecord();
    record.get('stateManager').transitionTo('loading');
  }
};
});

;require.register("test/init_router_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

//mock App.router object
App.router = Em.Object.create({
  transitionTo: Em.K,
  configurationController: Em.Object.create({
    getConfigsByTags: Em.K
  }),
  backgroundOperationsController: Em.Object.create({
    services: []
  })
});

});

;require.register("test/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/login_controller');

describe('App.LoginController', function () {

  var loginController = App.LoginController.create();

  describe('#validateCredentials()', function () {
    /*
    it('should return undefined if no username is present', function () {
      loginController.set('loginName', '');
      expect(loginController.validateCredentials()).to.equal(undefined);
    })
    it('should return undefined if no password is present', function () {
      loginController.set('password', '');
      expect(loginController.validateCredentials()).to.equal(undefined);
    })
    it('should return the user object with the specified username and password (dummy until actual integration)', function () {
      loginController.set('loginName', 'admin');
      loginController.set('password', 'admin');
      expect(loginController.validateCredentials().get('loginName'), 'admin');
    })
    */
  })
});

});

;require.register("test/mappers/hosts_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('models/host');
require('models/host_component');
require('mappers/server_data_mapper');
require('mappers/hosts_mapper');

describe('App.hostsMapper', function () {



});

});

;require.register("test/mappers/jobs_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('views/main/apps/item/dag_view');
require('mappers/server_data_mapper');
require('mappers/jobs_mapper');

describe('App.jobTimeLineMapper', function () {

  var test_input = {
    "map": [
      {
        "x": 1369394950,
        "y": 0
      },
      {
        "x": 1369394951,
        "y": 1
      },
      {
        "x": 1369394952,
        "y": 1
      },
      {
        "x": 1369394953,
        "y": 0
      }
    ],
    "shuffle": [
      {
        "x": 1369394950,
        "y": 0
      },
      {
        "x": 1369394951,
        "y": 0
      },
      {
        "x": 1369394952,
        "y": 1
      },
      {
        "x": 1369394953,
        "y": 1
      }
    ],
    "reduce": [
      {
        "x": 1369394950,
        "y": 0
      },
      {
        "x": 1369394951,
        "y": 0
      },
      {
        "x": 1369394952,
        "y": 0
      },
      {
        "x": 1369394953,
        "y": 0
      }
    ]
  };

  describe('#coordinatesModify()', function () {
    it('map', function() {
      var new_map = App.jobTimeLineMapper.coordinatesModify(test_input.map);
      expect(new_map.length).to.equal(6);

      expect(new_map[1].y).to.equal(new_map[0].y);
      expect(new_map[2].x).to.equal(new_map[1].x);

      expect(new_map[4].y).to.equal(new_map[5].y);
      expect(new_map[3].x).to.equal(new_map[4].x);
    });
    it('shuffle', function() {
      var new_shuffle = App.jobTimeLineMapper.coordinatesModify(test_input.shuffle);
      expect(new_shuffle.length).to.equal(6);

      expect(new_shuffle[2].y).to.equal(new_shuffle[1].y);
      expect(new_shuffle[3].x).to.equal(new_shuffle[2].x);

      expect(new_shuffle[3].y).to.equal(new_shuffle[4].y);
      expect(new_shuffle[4].x).to.equal(new_shuffle[5].x);
    });
    it('reduce', function() {
      var new_reduce = App.jobTimeLineMapper.coordinatesModify(test_input.reduce);
      expect(new_reduce.length).to.equal(4);
    });
  });
});

});

;require.register("test/mappers/runs_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');
require('mappers/runs_mapper');

describe('App.runsMapper', function () {

  var tests = [
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": []
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": []}}',
      m: 'One entry. Without targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1"]}}',
      m: 'One entry. With one target'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1,t2,t3']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1,t2,t3"]}}',
      m: 'One entry. With multiple targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": []
              },
              {
                "source": "scope-4",
                "targets": []
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": [],"scope-4": []}}',
      m: 'Two entries. Without targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1,t2,t3']
              },
              {
                "source": "scope-4",
                "targets": ['t1']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1,t2,t3"],"scope-4": ["t1"]}}',
      m: 'Two entries. With multiple targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1,t2,t3']
              },
              {
                "source": "scope-4",
                "targets": ['t1,t2,t3']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1,t2,t3"],"scope-4": ["t1,t2,t3"]}}',
      m: 'Two entries. With multiple targets'
    }
  ];

  describe('#generateWorkflow', function() {
    tests.forEach(function(test) {
      it (test.m, function() {
        var result = App.runsMapper.generateWorkflow(test.i, test.index);
        expect(result.workflowContext).to.equal(test.e);
        expect(result.index).to.equal(test.index + 1);
      });
    });
  });

});

});

;require.register("test/mappers/server_data_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');

describe('App.QuickDataMapper', function () {

  var test_json = {
    a1: {
      b1: {
        c1: 'val1'
      },
      b2: 'val2',
      b3: [
        {
          c2: 'val4'
        },
        {
          c2: 'val5'
        },
        {
          c2: 'val1'
        }
      ]
    },
    a2: 'val3',
    item: {
      'key.dotted': 'val6'
    }
  };

  describe('#getJsonProperty', function() {
    var tests = [
      {i:'a1.b1.c1',e:'val1'},
      {i:'a1.b2',e:'val2'},
      {i:'a2',e:'val3'},
      {i:'a1.b3[0].c2',e:'val4'},
      {i:'a1.b3[1].c2',e:'val5'}
    ];
    tests.forEach(function(test) {
      it(test.i, function() {
        var mapper = App.QuickDataMapper.create();
        expect(mapper.getJsonProperty(test_json, test.i)).to.equal(test.e);
      });
    });
  });

  describe('#parseIt', function() {
    var config = {
      $a2: 'a2',
      f1: 'a1.b1.c1',
      f2: 'a1.b3[0].c2',
      f3: 'a1.b3',
      f4_key: 'a1.b3',
      f4_type: 'array',
      f4: {
        item: 'c2'
      },
      f5: 'item.["key.dotted"]'
    };
    var mapper = App.QuickDataMapper.create();
    var result = mapper.parseIt(test_json, config);
    it('Property starts with $', function() {
      expect(result.a2).to.equal('a2');
    });
    it('Multi-components path', function() {
      expect(result.f1).to.equal('val1');
    });
    it('Path with array index', function() {
      expect(result.f2).to.equal('val4');
    });
    it('Path returns array', function() {
      expect(result.f3.length).to.equal(3);
    });
    it('Generate array of json fields', function() {
      expect(result.f4).to.eql(['val1','val4','val5']);
    });
    it('Check value with dotted key', function() {
      expect(result.f5).to.eql('val6');
    });
  });

});

});

;require.register("test/mappers/service_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('utils/helper');
require('mappers/server_data_mapper');
require('mappers/service_metrics_mapper');

describe('App.serviceMetricsMapper', function () {

  describe('#hbaseMapper', function() {

    it ('Round Average Load', function() {
      var tests = [
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1.23456789,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.23'
        },
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1.00,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.00'
        },
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.00'
        },
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1.2,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.20'
        }
      ];
      tests.forEach(function(test) {
        var result = App.serviceMetricsMapper.hbaseMapper(test);
        expect(result.average_load).to.equal(test.e);
      });
    });
  });

  describe('#stormMapper', function() {
    var tests = [
      {
        stackVersionNumber: '2.2',
        message: 'Storm mapper, stack version 2.2',
        expectedValues: {
          total_executors: 28,
          nimbus_uptime: "15m 1s",
          free_slots: 0,
          used_slots: 2,
          total_slots: 2,
          total_tasks: 28,
          topologies: 1
        },
        components: [
          {
            "ServiceComponentInfo" : {
              "component_name" : "STORM_UI_SERVER",
              "service_name" : "STORM"
            },
            "metrics" : {
              "api" : {
                "v1": {
                  "cluster": {
                    "summary": {
                      "executorsTotal": 28.0,
                      "nimbusUptime": "15m 1s",
                      "slotsFree": 0.0,
                      "slotsTotal": 2.0,
                      "slotsUsed": 2.0,
                      "supervisors": 1.0,
                      "tasksTotal": 28.0
                    }
                  },
                  "topology": {
                    "summary": [
                      {
                        "executorsTotal": 21.0,
                        "uptime": "5m 59s",
                        "schedulerInfo": null,
                        "name": "WordCountida8c06640_date2901141",
                        "workersTotal": 2.0,
                        "status": "ACTIVE",
                        "owner": "",
                        "tasksTotal": 21.0,
                        "id": "WordCountida8c06640_date2901141-2-1412195707"
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      {
        stackVersionNumber: '2.1',
        message: 'Storm mapper, stack version 2.1',
        expectedValues: {
          total_executors: 2,
          nimbus_uptime: "3.96 hours",
          free_slots: 2,
          used_slots: 0,
          total_slots: 2,
          total_tasks: 21,
          topologies: 0
        },
        components: [
          {
            "ServiceComponentInfo" : {
              "component_name" : "STORM_REST_API",
              "service_name" : "STORM"
            },
            "metrics" : {
              "api" : {
                "cluster" : {
                  "summary" : {
                    "executors.total" : 2.0,
                    "nimbus.uptime" : 14250.0,
                    "slots.free" : 2.0,
                    "slots.total" : 2.0,
                    "slots.used" : 0.0,
                    "supervisors" : 1.0,
                    "tasks.total" : 21.0,
                    "topologies" : 0.0
                  }
                }
              }
            }
          }
        ]
      }
    ];

    tests.forEach(function(test) {
      it(test.message, function() {
        sinon.stub(App, 'get', function(key) {
          if (key == 'currentStackVersionNumber') {
            return test.stackVersionNumber;
          }
        });
        var result = App.serviceMetricsMapper.stormMapper(test);
        expect(result).to.include(test.expectedValues);
        App.get.restore();
      });
    });

  });
});

});

;require.register("test/mappers/service_metrics_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */


var App = require('app');

describe('App.serviceMetricsMapper', function () {

  describe('#yarnMapper', function () {

    it('should set ACTIVE RM first in any cases (if RM HA enabled)', function() {
      var item = {
          components: [
            {
              ServiceComponentInfo: {
                component_name: 'RESOURCEMANAGER'
              },
              host_components: [
                {
                  HostRoles: {
                    ha_state: null,
                    host_name : 'h1'
                  }
                },
                {
                  HostRoles: {
                    ha_state: 'ACTIVE',
                    host_name : 'h2'
                  },
                  metrics: {
                    yarn: {
                      Queue: {
                        root: {
                          default: {}
                        }
                      }
                    }
                  }
                }
              ]
            }
          ]
        },
        result = App.serviceMetricsMapper.yarnMapper(item);
      expect(result.queue).to.equal("{\"root\":{\"default\":{}}}");
    });

  });

});
});

;require.register("test/mappers/stack_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('mappers/server_data_mapper');
require('mappers/stack_mapper');
require('models/stack');
require('models/operating_system');
require('models/repository');

describe('App.stackMapper', function () {
	describe("#map", function() {
    
    var test_data = {
        items: [{
          "Versions" : {
            "active" : true,
            "min_upgrade_version" : null,
            "parent_stack_version" : "1.3.3",
            "stack_name" : "HDP",
            "stack_version" : "1.3"
          },
          "operatingSystems" : [
            {
              "OperatingSystems" : {
                "os_type" : "redhat5",
                "stack_name" : "HDP",
                "stack_version" : "1.3"
              },
              "repositories" : [
                {
                   "Repositories" : {
                    "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                    "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                    "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.8.0",
                    "mirrors_list" : null,
                    "os_type" : "redhat5",
                    "repo_id" : "HDP-1.3",
                    "repo_name" : "HDP",
                    "stack_name" : "HDP",
                    "stack_version" : "1.3"
                  }
                },{
                  "Repositories" : {
                    "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                    "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                    "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                    "mirrors_list" : null,
                    "os_type" : "redhat5",
                    "repo_id" : "HDP-UTILS-1.1.0.16",
                    "repo_name" : "HDP-UTILS",
                    "stack_name" : "HDP",
                    "stack_version" : "1.3"
                  }
                }]
            },{
              "OperatingSystems" : {
                "os_type" : "redhat6",
                "stack_name" : "HDP",
                "stack_version" : "1.3"
              }, "repositories" : [
                  {
                    "Repositories" : {
                      "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
                      "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
                      "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.8.0",
                      "mirrors_list" : null,
                      "os_type" : "redhat6",
                      "repo_id" : "HDP-1.3",
                      "repo_name" : "HDP",
                      "stack_name" : "HDP",
                      "stack_version" : "1.3"
                    }
                  },
                  {
                    "Repositories" : {
                      "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
                      "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
                      "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
                      "mirrors_list" : null,
                      "os_type" : "redhat6",
                      "repo_id" : "HDP-UTILS-1.1.0.16",
                      "repo_name" : "HDP-UTILS",
                      "stack_name" : "HDP",
                      "stack_version" : "1.3"
                    }
                  }
                ]
            }]
      },{
        "Versions" : {
          "active" : false,
          "min_upgrade_version" : null,
          "parent_stack_version" : null,
          "stack_name" : "HDP",
          "stack_version" : "2.0.6"
        },
        "operatingSystems" : [
          {
            "OperatingSystems" : {
              "os_type" : "redhat5",
              "stack_name" : "HDP",
              "stack_version" : "2.0.6"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-2.0.6",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              },
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              }]
          }, {
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "stack_name" : "HDP",
              "stack_version" : "2.0.6"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.0.6",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              }, {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              }]
          }]
      },{
        "Versions" : {
          "active" : true,
          "min_upgrade_version" : null,
          "parent_stack_version" : null,
          "stack_name" : "HDP",
          "stack_version" : "2.1"
        },
        "operatingSystems" : [
          {
            "OperatingSystems" : {
              "os_type" : "redhat5",
              "stack_name" : "HDP",
              "stack_version" : "2.1"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-2.1",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              },
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              }]
          }, {
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "stack_name" : "HDP",
              "stack_version" : "2.1"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.1",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              }, {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              }]
          }]
      }] 
    };

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.Repository);
      App.resetDsStoreTypeMap(App.OperatingSystem);
      App.resetDsStoreTypeMap(App.Stack);
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function(){
      App.store.commit.restore();
    });

		
    it ('should map active Stack data', function() {
      App.stackMapper.map(test_data);
      expect(App.Stack.find().get('length')).to.equal(2);
      expect(App.Stack.find().everyProperty('active')).to.equal(true);
      expect(App.Stack.find().everyProperty('isSelected')).to.equal(false);
      expect(App.Stack.find().mapProperty('id')).to.eql(['HDP-2.1','HDP-1.3']);
    });

    it ('should map Operating System data', function() {
      App.stackMapper.map(test_data);
      expect(App.OperatingSystem.find().get('length')).to.equal(4);
      expect(App.OperatingSystem.find().mapProperty('id')).to.eql(['HDP-2.1-redhat5', 'HDP-2.1-redhat6', 'HDP-1.3-redhat5', 'HDP-1.3-redhat6']);
    });
    
    it ('should map Repository data', function() {
      App.stackMapper.map(test_data);
      expect(App.Repository.find().get('length')).to.equal(8);
    });
  });
});

});

;require.register("test/mappers/status_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');

describe('App.statusMapper', function () {


});

});

;require.register("test/mappers/users_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');
require('mappers/users_mapper');

describe('App.usersMapper', function () {

  describe('#isAdmin', function() {
    var tests = [
      {i:["AMBARI.ADMIN"],e:true,m:'has admin role'},
      {i:["CLUSTER.READ", "AMBARI.ADMIN"],e:true,m:'has admin role'},
      {i:["VIEW.USE"],e:false,m:'doesn\'t have admin role'},
      {i:["CLUSTER.OPERATE"],e:true,m:'has admin role'}
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.usersMapper.isAdmin(test.i)).to.equal(test.e);
      });
    });
  });

});

});

;require.register("test/mixins/common/chart/storm_linear_time_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/chart/storm_linear_time');

var slt,
  template,
  series,
  jsonDataFalse = {
    metrics: {
      id: 'metrics'
    }
  },
  jsonDataTrue = {
    metrics: {
      storm: {
        nimbus: {
          name: 'nimbus'
        }
      }
    }
  };

describe('App.StormLinearTimeChartMixin', function () {

  beforeEach(function () {
    slt = Em.Object.create(App.StormLinearTimeChartMixin, {
      stormChartDefinition: [
        {
          field: 'name',
          name: 'nimbus'
        }
      ]
    });
  });

  describe('#getDataForAjaxRequest', function () {
    it('should take data from stormChartDefinition', function () {
      template = slt.getDataForAjaxRequest().metricsTemplate;
      expect(template).to.contain('metrics');
      expect(template).to.contain('storm');
      expect(template).to.contain('nimbus');
    });
  });

  describe('#transformToSeries', function () {
    it('should be empty', function () {
      expect(slt.transformToSeries(jsonDataFalse)).to.be.empty;
    });
    it('should take one element from data', function () {
      slt.set('transformData', function (data, name) {
        return name + ': ' + JSON.stringify(data);
      });
      series = slt.transformToSeries(jsonDataTrue);
      expect(series).to.have.length(1);
      expect(series[0]).to.equal('nimbus: "nimbus"');
    });
  });

});

});

;require.register("test/mixins/common/localStorage_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/localStorage');

var localStorage,
  nameCases = [
    {
      toSet: {
        name: 'name'
      },
      toExpect: 'Name'
    },
    {
      toSet: {
        name: null,
        controller: {
          name: 'samplecontroller'
        }
      },
      toExpect: 'Samplecontroller'
    },
    {
      toSet: {
        controller: {
          name: 'sampleController'
        }
      },
      toExpect: 'Sample'
    }
  ];

describe('App.LocalStorage', function () {

  beforeEach(function () {
    localStorage = Em.Object.create(App.LocalStorage);
  });

  after(function () {
    App.db.cleanUp();
  });

  describe('#dbNamespace', function () {
    nameCases.forEach(function (item) {
      it('should be ' + item.toExpect, function () {
        localStorage.setProperties(item.toSet);
        expect(localStorage.get('dbNamespace')).to.equal(item.toExpect)
      });
    });
  });

  describe('#getDBProperty', function () {
    it('should take value from DB', function () {
      localStorage.set('name', 'name');
      localStorage.setDBProperty('key', 'value');
      expect(localStorage.getDBProperty('key')).to.equal('value');
    });
  });

});

});

;require.register("test/mixins/main/host/details/host_components/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/main/host/details/host_components/decommissionable');

var decommissionable,
  view,
  statusCases = [
    {
      status: App.HostComponentStatus.started,
      expected: false
    },
    {
      status: 'status',
      expected: true
    }
  ],
  responseCases = [
    {
      HostRoles: {
        desired_admin_state: 'state'
      },
      ServiceComponentInfo: {component_state: ''}
    },
    {
      HostRoles: {
        desired_admin_state: null
      },
      ServiceComponentInfo: {component_state: ''}
    }
  ],
  textCases = [
    {
      available: true,
      text: Em.I18n.t('common.decommission')
    },
    {
      available: false,
      text: Em.I18n.t('common.recommission')
    }
  ];

describe('App.Decommissionable', function () {

  beforeEach(function () {
    decommissionable = Em.Object.create(App.Decommissionable);
  });

  describe('#decommissionView.text', function () {

    beforeEach(function () {
      view = decommissionable.decommissionView.create();
      view.reopen({
        parentView: decommissionable
      });
    });

    textCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        view.set('parentView.isComponentDecommissionAvailable', item.available);
        expect(view.get('text')).to.equal(item.text);
      });
    });

  });

});

});

;require.register("test/mixins/wizard/addSeccurityConfigs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/wizard/addSecurityConfigs');

describe('App.AddSecurityConfigs', function () {

  var controller = App.AddSecurityConfigs.create({
    content: {},
    enableSubmit: function () {
      this._super()
    },
    secureMapping: [],
    secureProperties: []
  });

  describe('#secureServices', function() {
    it('content.services is correct', function() {
      controller.set('content.services', [{}]);
      expect(controller.get('secureServices')).to.eql([{}]);
      controller.reopen({
        secureServices: []
      })
    });
  });

  describe('#loadUiSideSecureConfigs()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'checkServiceForConfigValue', function() {
        return 'value2';
      });
      sinon.stub(controller, 'setConfigValue', Em.K);
      sinon.stub(controller, 'formatConfigName', Em.K);
    });
    afterEach(function(){
      controller.checkServiceForConfigValue.restore();
      controller.setConfigValue.restore();
      controller.formatConfigName.restore();
    });

    it('secureMapping is empty', function() {
      controller.set('secureMapping', []);

      expect(controller.loadUiSideSecureConfigs()).to.be.empty;
    });
    it('Config does not have dependedServiceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: null
      }]);

      expect(controller.loadUiSideSecureConfigs()).to.eql([{
        "id": "site property",
        "name": 'config1',
        "value": 'value1',
        "filename": 'file1'
      }]);
    });
    it('Config has dependedServiceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: null,
        dependedServiceName: 'service'
      }]);

      expect(controller.loadUiSideSecureConfigs()).to.eql([{
        "id": "site property",
        "name": 'config1',
        "value": 'value2',
        "filename": 'file1'
      }]);
    });
    it('Config has non-existent serviceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: true,
        serviceName: 'service'
      }]);
      sinon.stub(App.Service, 'find', function(){
        return [];
      });

      expect(controller.loadUiSideSecureConfigs()).to.be.empty;
      App.Service.find.restore();
    });
    it('Config has correct serviceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: true,
        serviceName: 'HDFS'
      }]);
      sinon.stub(App.Service, 'find', function(){
        return [{serviceName: 'HDFS'}];
      });

      expect(controller.loadUiSideSecureConfigs()).to.eql([{
        "id": "site property",
        "name": 'config1',
        "value": 'value1',
        "filename": 'file1'
      }]);
      expect(controller.setConfigValue.calledOnce).to.be.true;
      expect(controller.formatConfigName.calledOnce).to.be.true;
      App.Service.find.restore();
    });
  });

  describe('#checkServiceForConfigValue()', function() {
    it('services is empty', function() {
      var services = [];

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('value1');
    });
    it('Service is loaded', function() {
      var services = [{}];
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('value1');

      App.Service.find.restore();
    });
    it('Service is not loaded', function() {
      var services = [{
        replace: 'val'
      }];
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('ue1');

      App.Service.find.restore();
    });
  });

  describe('#formatConfigName()', function() {
    it('config.value is null', function() {
      var config = {
        value: null
      };

      expect(controller.formatConfigName([], config)).to.be.false;
    });
    it('config.name does not contain foreignKey', function() {
      var config = {
        value: 'value1',
        name: 'config1'
      };

      expect(controller.formatConfigName([], config)).to.be.false;
    });
    it('globalProperties is empty, use uiConfig', function() {
      var config = {
        value: 'value1',
        name: '<foreignKey[0]>',
        foreignKey: ['key1']
      };
      controller.set('globalProperties', []);
      var uiConfig = [{
        name: 'key1',
        value: 'globalValue1'
      }];

      expect(controller.formatConfigName(uiConfig, config)).to.be.true;
      expect(config._name).to.equal('globalValue1');
    });

  });

  describe('#setConfigValue()', function() {
    it('config.value is null', function() {
      var config = {
        value: null
      };

      expect(controller.setConfigValue(config)).to.be.false;
    });
    it('config.value does not match "templateName"', function() {
      var config = {
        value: ''
      };

      expect(controller.setConfigValue(config)).to.be.false;
    });
    it('No such property in global configs', function() {
      var config = {
        value: '<templateName[0]>',
        templateName: ['config1']
      };
      controller.set('globalProperties', []);

      expect(controller.setConfigValue(config)).to.be.true;
      expect(config.value).to.be.null;
    });

  });

  describe('#addHostConfig()', function() {

    afterEach(function () {
      App.Service.find.restore();
    });

    it('No such service loaded', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
    it('No such service in secureServices', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({isLoaded: true});
      });
      controller.set('secureServices', []);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
    it('Service does not have such host-component', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({
          isLoaded: true,
          hostComponents: []
        });
      });
      controller.set('secureServices', [{
        serviceName: 'service1'
      }]);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
  });

  describe('#getPrincipalNames()', function() {

    beforeEach(function () {
      controller.set('globalProperties', []);
      controller.set('secureProperties', []);
    });

    it('globalProperties and secureProperties are empty', function() {
      expect(controller.getPrincipalNames()).to.be.empty;
    });
    it('global property name does not match "principal_name"', function() {
      controller.set('globalProperties', [{
        name: 'config1'
      }]);
      expect(controller.getPrincipalNames()).to.be.empty;
    });
    it('secure property name does not match "principal_name"', function() {
      controller.set('secureProperties', [{
        name: 'config1'
      }]);
      expect(controller.getPrincipalNames()).to.be.empty;
    });
    it('property with such name already exists', function() {
      controller.set('globalProperties', [{
        name: 'principal_name'
      }]);
      controller.set('secureProperties', [{
        name: 'principal_name'
      }]);
      expect(controller.getPrincipalNames().mapProperty('name')).to.eql(['principal_name']);
    });
  });

  describe('#loadUsersFromServer()', function() {
    it('testMode = true', function() {
      controller.set('testModeUsers', [{
        name: 'user1',
        value: 'value1'
      }]);
      controller.set('serviceUsers', []);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });

      controller.loadUsersFromServer();
      expect(controller.get('serviceUsers')).to.eql([{
        name: 'user1',
        value: 'value1',
        id: 'puppet var'
      }]);
      App.get.restore();
    });
    it('testMode = false', function() {
      sinon.stub(App.router, 'set', Em.K);
      sinon.stub(App.db, 'getSecureUserInfo', function(){
        return [];
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });

      controller.loadUsersFromServer();
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      expect(App.router.set.calledWith('mainAdminSecurityController.serviceUsers', [])).to.be.true;

      App.router.set.restore();
      App.get.restore();
      App.db.getSecureUserInfo.restore();
    });
  });

});




});

;require.register("test/mock_data_setup/configs_mock_data", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  setupConfigGroupsObject: function(serviceName) {
    var serviceGroups = this.setupServiceConfigTagsObject(serviceName).mapProperty('siteName');
    var configGroups = [
      {
        "tag":"version1",
        "type":"core-site",
        "properties": {
          "fs.defaultFS" : "hdfs://c6401.ambari.apache.org:8020",
          "fs.trash.interval" : "360"
        }
      },
      {
        "tag":"version1",
        "type":"global",
        "properties":{
          "hadoop_heapsize":"1024",
          "storm_log_dir": "/var/log/storm",
          "stormuiserver_host": "c6401.ambari.apache.org",
          "nonexistent_property": "some value"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-site",
        "properties": {
          "dfs.datanode.data.dir": "/b,/a",
          "dfs.namenode.name.dir": "/b,/a,/c",
          "dfs.namenode.checkpoint.dir": "/b,/d,/a,/c",
          "dfs.datanode.failed.volumes.tolerated": "2",
          "content": "custom mock property"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-log4j",
        "properties": {
          "content": "hdfs log4j content"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "zoo cfg content"
        }
      },
      {
        "tag":"version1",
        "type":"storm-site",
        "properties": {
          "storm.zookeeper.servers": "['c6401.ambari.apache.org','c6402.ambari.apache.org']",
          "single_line_property": "value",
          "multi_line_property": "value \n value"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "value"
        }
      }
    ];
    return configGroups.filter(function(configGroup) {
      return serviceGroups.contains(configGroup.type);
    });
  },
  setupServiceConfigTagsObject: function(serviceName) {
    var configTags = {
      STORM: ['global','storm-site'],
      HDFS: ['global','hdfs-site','core-site','hdfs-log4j'],
      ZOOKEEPER: ['global', 'zoo.cfg']
    };
    var configTagsObject = [];
    if (serviceName) {
      configTags[serviceName].forEach(function(tag) {
        configTagsObject.push({
          siteName: tag,
          tagName: "version1",
          newTagName: null
        });
      });
    } else {
      for (var serviceName in configTags) {
        configTags[serviceName].forEach(function(tag) {
          configTagsObject.push({
            siteName: tag,
            tagName: "version1",
            newTagName: null
          });
        });
      }
    }
    return configTagsObject.uniq();
  },
  setupAdvancedConfigsObject: function() {
    return [
      {
        "serviceName": "HDFS",
        "name": "fs.defaultFS",
        "value": "hdfs://c6401.ambari.apache.org:8020",
        "description": "fs.defaultFS",
        "filename": "core-site.xml"
      },
      {
        "serviceName": "STORM",
        "name": "storm.zookeeper.servers",
        "value": "['localhost']",
        "description": "desc",
        "filename": "storm-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.data.dir",
        "value": "/hadoop/hdfs/data",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.name.dir",
        "value": "/hadoop/hdfs/namenode",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.checkpoint.dir",
        "value": "/hadoop/hdfs/namesecondary",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.failed.volumes.tolerated",
        "value": "2",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom mock property",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "hdfs log4j content",
        "description": "desc",
        "filename": "hdfs-log4j.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom hdfs log4j content",
        "description": "desc",
        "filename": "custom-hdfs-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "content",
        "value": "zookeeper log4j.xml content",
        "description": "desc",
        "filename": "zookeeper-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "custom.zoo.cfg",
        "value": "zoo cfg content",
        "description": "zoo.cfg config",
        "filename": "zoo.cfg"
      },
      {
        "serviceName": "YARN",
        "name": "content",
        "value": " value \n value",
        "filename": "capacity-scheduler.xml"
      },
      {
        "serviceName": "YARN",
        "name": "yarn.scheduler.capacity.root.default.capacity",
        "value": "100",
        "filename": "capacity-scheduler.xml"
      }
    ];
  },
  setupStoredConfigsObject: function() {
    return [
      {
        "name":"storm.zookeeper.servers",
        "value":[
          "c6401.ambari.apache.org",
          "c6402.ambari.apache.org"
        ],
        "defaultValue":"['c6401.ambari.apache.org','c6402.ambari.apache.org']",
        "filename":"storm-site.xml",
        "isUserProperty":false,
        "isOverridable":false,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"masterHosts",
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"General",
        "id":"site property",
        "displayName":"storm.zookeeper.servers"
      },
      {
        "name":"single_line_property",
        "value":"value",
        "defaultValue":"value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "id":"site property",
        "displayType":"advanced",
        "displayName":"single_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"multi_line_property",
        "value":"value \n value",
        "defaultValue":"value \n value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "id":"site property",
        "displayType":"multiLine",
        "displayName":"multi_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"nonexistent_property",
        "value":"some value",
        "defaultValue":"some value",
        "filename":"global.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "isVisible":false,
        "id":"puppet var",
        "displayName":null,
        "options":null
      },
      {
        "name":"dfs.datanode.data.dir",
        "value":"/a,/b",
        "defaultValue":"/a,/b",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"HDFS",
        "displayType":"directories",
        "isRequired":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "index":1,
        "isSecureConfig":false,
        "category":"DataNode",
        "id":"site property",
        "displayName":"DataNode directories"
      },
      {
        "name":"content",
        "value":"custom mock property",
        "defaultValue":"custom mock property",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "id":"site property",
        "displayName":"content"
      },
      {
        "name":"content",
        "value":"hdfs log4j content",
        "defaultValue":"hdfs log4j content",
        "filename":"hdfs-log4j.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "id":"site property",
        "displayName":"content"
      },
      {
        "name":"storm_log_dir",
        "value":"/var/log/storm",
        "defaultValue":"/var/log/storm",
        "filename":"global.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"directory",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"Storm log directory",
        "isSecureConfig":false,
        "category":"General",
        "id":"puppet var",
        "displayName":"storm_log_dir"
      }
    ];
  }
}

});

;require.register("test/models/alert_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alert');

var alert,
  sampleTime = 1399312800,
  statusCases = [
    {
      status: 0,
      property: 'isOk',
      format: 'OK'
    },
    {
      status: 1,
      property: 'isWarning',
      format: 'WARN'
    },
    {
      status: 2,
      property: 'isCritical',
      format: 'CRIT'
    },
    {
      status: 3,
      property: 'isPassive',
      format: 'MAINT'
    },
    {
      status: 4,
      property: '',
      format: 'UNKNOWN'
    }
  ],
  ignoredCases = [
    {
      title: 'title',
      result: false
    },
    {
      title: 'Percent',
      result: true
    }
  ],
  serviceTypeCases = [
    {
      type: 'MAPREDUCE',
      name: 'MapReduce',
      link: '#/main/services/MAPREDUCE/summary'
    },
    {
      type: 'HDFS',
      name: 'HDFS',
      link: '#/main/services/HDFS/summary'
    },
    {
      type: 'HBASE',
      name: 'HBase',
      link: '#/main/services/HBASE/summary'
    },
    {
      type: 'ZOOKEEPER',
      name: 'Zookeeper',
      link: '#/main/services/ZOOKEEPER/summary'
    },
    {
      type: 'OOZIE',
      name: 'Oozie',
      link: '#/main/services/OOZIE/summary'
    },
    {
      type: 'HIVE',
      name: 'Hive',
      link: '#/main/services/HIVE/summary'
    },
    {
      type: 'service',
      name: null,
      link: null
    },
    {
      type: null,
      name: null,
      link: null
    }
  ],
  titles = ['NodeManager health', 'NodeManager process', 'TaskTracker process', 'RegionServer process', 'DataNode process', 'DataNode space', 'ZooKeeper Server process', 'Supervisors process'];

describe('App.Alert', function () {

  beforeEach(function() {
    alert = App.Alert.create();
  });

  describe('#date', function () {
    it('is Mon May 05 2014', function () {
      alert.set('lastTime', sampleTime);
      expect(alert.get('date').toDateString()).to.equal('Mon May 05 2014');
    });
  });

  statusCases.forEach(function (item) {
    var status = item.status,
      property = item.property;
    if (property) {
      describe('#' + property, function () {
        it('status ' + status + ' is for ' + property, function () {
          alert.set('status', status);
          expect(alert.get(property)).to.be.true;
          var falseStates = statusCases.mapProperty('property').without(property).without('');
          var falseStatuses = [];
          falseStates.forEach(function (state) {
            falseStatuses.push(alert.get(state));
          });
          expect(falseStatuses).to.eql([false, false, false]);
        });
      });
    }
  });

  describe('#ignoredForServices', function () {
    titles.forEach(function (item) {
      it('should be true for ' + item, function () {
        alert.set('title', item);
        expect(alert.get('ignoredForServices')).to.be.true;
      });
    });
    it('should be false', function () {
      alert.set('title', 'title');
      expect(alert.get('ignoredForServices')).to.be.false;
    });
  });

  describe('#ignoredForHosts', function () {
    ignoredCases.forEach(function (item) {
      it('should be ' + item.result, function () {
        alert.set('title', item.title);
        expect(alert.get('ignoredForHosts')).to.equal(item.result);
      });
    });
  });

  describe('#timeSinceAlert', function () {
    statusCases.forEach(function (item) {
      var format = item.format;
      it('should indicate ' + format + ' status duration', function () {
        alert.setProperties({
          lastTime: sampleTime,
          status: item.status.toString()
        });
        expect(alert.get('timeSinceAlert')).to.have.string(format);
        expect(alert.get('timeSinceAlert.length')).to.be.above(format.length);
        alert.set('lastTime', 0);
        expect(alert.get('timeSinceAlert')).to.equal(format);
      });
    });
    it('should be empty', function () {
      alert.set('lastTime', undefined);
      expect(alert.get('timeSinceAlert')).to.be.empty;
    });
  });

  describe('#makeTimeAtleastMinuteAgo', function () {
    it('should set the minute-ago time', function () {
      var time = App.dateTime() - 50000,
        date = new Date(time - 10000);
      alert.set('lastTime', time);
      expect(alert.makeTimeAtleastMinuteAgo(alert.get('date'))).to.be.at.least(date);
    });
    it('should return the actual time', function () {
      var time = App.dateTime() - 70000;
      alert.set('lastTime', time);
      expect(alert.makeTimeAtleastMinuteAgo(alert.get('date'))).to.eql(alert.get('date'));
    });
  });

  describe('#timeSinceAlertDetails', function () {
    it ('should return the appropriate string', function () {
      alert.set('lastTime', sampleTime);
      var occurred = Em.I18n.t('services.alerts.occurredOn').format('May 05 2014', alert.get('date').toLocaleTimeString());
      var brChecked = Em.I18n.t('services.alerts.brLastCheck').format($.timeago(sampleTime));
      var checked = Em.I18n.t('services.alerts.lastCheck').format($.timeago(sampleTime));
      expect(alert.get('timeSinceAlertDetails')).to.equal(occurred);
      alert.set('lastCheck', sampleTime / 1000);
      expect(alert.get('timeSinceAlertDetails')).to.equal(occurred + brChecked);
      alert.set('lastTime', undefined);
      expect(alert.get('timeSinceAlertDetails')).to.equal(checked);
    });
    it ('should be empty', function () {
      alert.set('lastCheck', undefined);
      expect(alert.get('timeSinceAlertDetails')).to.be.empty;
    });
  });

  describe('#serviceName', function () {
    serviceTypeCases.forEach(function (item) {
      it('should be ' + item.name, function () {
        alert.set('serviceType', item.type);
        expect(alert.get('serviceName')).to.equal(item.name);
      });
    });
  });

  describe('#serviceLink', function () {
    serviceTypeCases.forEach(function (item) {
      it('should be ' + item.link, function () {
        alert.set('serviceType', item.type);
        expect(alert.get('serviceLink')).to.equal(item.link);
      });
    });
  });

});

});

;require.register("test/models/authentication_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/authentication');

var form,
  methods = [
    {
      name: 'method',
      fields: ['primaryServer', 'searchBaseDn', 'usernameAttribute']
    },
    {
      name: 'bindMethod',
      fields: ['bindUser', 'password', 'passwordRetype']
    }
  ],
  classCases = [
    {
      result: 0,
      message: 'fail',
      className: 'error'
    },
    {
      result: 1,
      message: 'success',
      className: 'success'
    }
  ];

describe('App.AuthenticationForm', function () {

  beforeEach(function() {
    form = App.AuthenticationForm.create();
  });

  methods.forEach(function (method) {
    method.fields.forEach(function (field) {
      describe('#' + field + '.isRequired', function () {
        for (var i = 2; i--; ) {
          it('should be ' + i + ' dependent on ' + method.name + ' value', function () {
            form.getField(method.name).set('value', i);
            expect(form.getField(field).get('isRequired')).to.equal(i);
          });
        }
      });
    });
  });

  describe('#testResult', function () {
    it('should be 0 or 1', function () {
      form.testConfiguration();
      expect([0, 1]).to.include(Number(form.get('testResult')));
    });
  });

  describe('#testConfigurationMessage', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.message, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationMessage')).to.equal(Em.I18n.t('admin.authentication.form.test.' + item.message));
      });
    });
  });

  describe('#testConfigurationClass', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.className, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationClass')).to.equal('text-' + item.className);
      });
    });
  });

});

});

;require.register("test/models/cluster_states_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/cluster_states');

var status = App.clusterStatus,
  notInstalledStates = ['CLUSTER_NOT_CREATED_1', 'CLUSTER_DEPLOY_PREP_2', 'CLUSTER_INSTALLING_3', 'SERVICE_STARTING_3'],
  values = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller',
    localdb: {}
  },
  response = {
    clusterState: 'DEFAULT',
    clusterName: 'cluster'
  },
  newValue = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller'
  };

describe('App.clusterStatus', function () {

  describe('#isInstalled', function () {
    notInstalledStates.forEach(function (item) {
      it('should be false', function () {
        status.set('clusterState', item);
        expect(status.get('isInstalled')).to.be.false;
      });
    });
    it('should be true', function () {
      status.set('clusterState', 'DEFAULT');
      expect(status.get('isInstalled')).to.be.true;
    });
  });

  describe('#value', function () {
    it('should be set from properties', function () {
      Em.keys(values).forEach(function (key) {
        status.set(key, values[key]);
      });
      expect(status.get('value')).to.eql(values);
    });
  });

  describe('#getUserPrefSuccessCallback', function () {
    it('should set the cluster parameters', function () {
      status.getUserPrefSuccessCallback(response);
      Em.keys(response).forEach(function (key) {
        expect(status.get(key)).to.equal(response[key]);
      });
    });
  });

  describe('#setClusterStatus', function () {

    beforeEach(function() {
      sinon.stub(status, 'postUserPref', function() {
        return $.ajax();
      });
    });

    afterEach(function () {
      status.postUserPref.restore();
      App.get.restore();
    });

    it('should return false in test mode', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'testMode') return true;
        return Em.get(App, k);
      });
      expect(status.setClusterStatus()).to.be.false;
    });

    it('should set cluster status in non-test mode', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'testMode') return false;
        return Em.get(App, k);
      });
      var clusterStatus = status.setClusterStatus(newValue);
      expect(clusterStatus).to.eql(newValue);
    });

  });

});

});

;require.register("test/models/config_group_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/config_group');
require('models/host');

var configGroup,
  hostRecord,
  hosts = [
    Em.Object.create({
      id: 'host0',
      hostName: 'host0',
      hostComponents: []
    }),
    Em.Object.create({
      id: 'host1',
      hostName: 'host1',
      hostComponents: []
    })
  ],
  host = Em.Object.create({
    id: 'host0',
    hostName: 'host0',
    hostComponents: []
  }),
  properties = [
    {
      name: 'n0',
      value: 'v0'
    },
    {
      name: 'n1',
      value: 'v1'
    }
  ],
  setParentConfigGroup = function (configGroup, hosts) {
    configGroup.set('parentConfigGroup', App.ConfigGroup.create());
    configGroup.set('parentConfigGroup.hosts', hosts.mapProperty('hostName'));
  };

describe('App.ConfigGroup', function () {

  beforeEach(function () {
    configGroup = App.ConfigGroup.create();
  });

  describe('#displayName', function () {
    it('should equal name if maximum length is not exceeded', function () {
      configGroup.set('name', 'n');
      expect(configGroup.get('displayName')).to.equal(configGroup.get('name'));
    });
    it('should be shortened if maximum length is exceeded', function () {
      var maxLength = App.config.CONFIG_GROUP_NAME_MAX_LENGTH;
      for (var i = maxLength + 1, name = ''; i--; ) {
        name += 'n';
      }
      configGroup.set('name', name);
      expect(configGroup.get('displayName')).to.contain('...');
      expect(configGroup.get('displayName')).to.have.length(2 * Math.floor(maxLength / 2) + 3);
    });
  });

  describe('#displayNameHosts', function () {
    it('should indicate the number of hosts', function () {
      var displayName = configGroup.get('displayName');
      configGroup.set('hosts', []);
      expect(configGroup.get('displayNameHosts')).to.equal(displayName + ' (0)');
      configGroup.set('hosts', hosts);
      expect(configGroup.get('displayNameHosts')).to.equal(displayName + ' (2)');
    });
  });

  describe('#availableHosts', function () {

    beforeEach(function () {
      App.clusterStatus.set('clusterState', 'DEFAULT');
      sinon.stub(App.Host, 'find', function() {
        return [host];
      });
      setParentConfigGroup(configGroup, hosts);
    });

    afterEach(function () {
      App.Host.find.restore();
    });

    it('should return an empty array as default', function () {
      configGroup.set('isDefault', true);
      expect(configGroup.get('availableHosts')).to.eql([]);
    });

    it('should return an empty array if there are no unused hosts', function () {
      configGroup.set('parentConfigGroup', App.ConfigGroup.create());
      expect(configGroup.get('availableHosts')).to.eql([]);
    });

    it('should take hosts from parentConfigGroup', function () {
      setParentConfigGroup(configGroup, hosts);
      configGroup.set('clusterHosts', hosts);
      expect(configGroup.get('availableHosts')).to.have.length(2);
    });
  });

  describe('#isAddHostsDisabled', function () {

    beforeEach(function () {
      hostRecord = App.Host.createRecord(host);
      setParentConfigGroup(configGroup, hosts);
      configGroup.set('isDefault', false);
      configGroup.reopen({availableHosts: [{}]});
    });

    afterEach(function () {
      modelSetup.deleteRecord(hostRecord);
    });

    it('should be false', function () {
      expect(configGroup.get('isAddHostsDisabled')).to.be.false;
    });
    it('should be true', function () {
      App.clusterStatus.set('clusterState', 'DEFAULT');
      configGroup.set('isDefault', true);
      expect(configGroup.get('isAddHostsDisabled')).to.be.true;
      configGroup.set('availableHosts', hosts);
      expect(configGroup.get('isAddHostsDisabled')).to.be.true;
    });
  });

  describe('#propertiesList', function () {
    it('should be formed from properties', function () {
      configGroup.set('properties', properties);
      properties.forEach(function (item) {
        Em.keys(item).forEach(function (prop) {
          expect(configGroup.get('propertiesList')).to.contain(item[prop]);
        });
      });
      expect(configGroup.get('propertiesList')).to.have.length(24);
    });
  });

});

});

;require.register("test/models/dataset_job_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/dataset_job');

var dataSetJob,
  dataSetJobData = {
    id: 'job',
    name: 'job'
  },
  timeCases = [
    {
      property: 'startFormatted',
      dateProperty: 'startDate'
    },
    {
      property: 'endFormatted',
      dateProperty: 'endDate'
    }
  ],
  timeTestData = [
    {
      title: 'should calculate time period',
      time: function () {
        return App.dateTime();
      },
      result: 'a moment ago'
    },
    {
      title: 'should be empty',
      time: function () {
        return 0;
      },
      result: ''
    }
  ],
  healthCases = [
    {
      status: 'SUCCEEDED',
      className: 'icon-ok'
    },
    {
      status: 'SUSPENDED',
      className: 'icon-cog'
    },
    {
      status: 'WAITING',
      className: 'icon-time'
    },
    {
      status: 'RUNNING',
      className: 'icon-play'
    },
    {
      status: 'KILLED',
      className: 'icon-exclamation-sign'
    },
    {
      status: 'FAILED',
      className: 'icon-warning-sign'
    },
    {
      status: 'ERROR',
      className: 'icon-remove'
    },
    {
      status: '',
      className: 'icon-question-sign'
    }
  ];

describe('App.DataSetJob', function () {

  beforeEach(function () {
    dataSetJob = App.DataSetJob.createRecord(dataSetJobData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(dataSetJob);
  });

  describe('#statusFormatted', function () {
    it('should be in lower case and capitalized', function () {
      dataSetJob.set('status', 'RUNNING');
      expect(dataSetJob.get('statusFormatted')).to.equal('Running');
    });
  });

  describe('#isSuspended', function () {
    it('should be false', function () {
      dataSetJob.set('status', 'RUNNING');
      expect(dataSetJob.get('isSuspended')).to.be.false;
    });
    it('should be true', function () {
      dataSetJob.set('status', 'SUSPENDED');
      expect(dataSetJob.get('isSuspended')).to.be.true;
    });
  });

  timeCases.forEach(function (item) {
    describe('#' + item.property, function () {
      timeTestData.forEach(function (test) {
        it(test.title, function () {
          dataSetJob.set(item.dateProperty, test.time());
          expect(dataSetJob.get(item.property)).to.equal(test.result);
        });
      });
    });
  });

  describe('#healthClass', function () {
    healthCases.forEach(function (item) {
      it('should be ' + item.className, function () {
        dataSetJob.set('status', item.status);
        expect(dataSetJob.get('healthClass')).to.equal(item.className);
      });
    });
  });

});

});

;require.register("test/models/dataset_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/dataset');

var dataset,
  datasetData = {
    id: 'dataset',
    name: 'dataset'
  },
  statusCases = [
    {
      status: 'RUNNING',
      property: 'isRunning'
    },
    {
      status: 'SUSPENDED',
      property: 'isSuspended'
    },
    {
      status: 'SUBMITTED',
      property: 'isSubmitted'
    }
  ],
  healthCases = [
    {
      title: 'should be live',
      data: {
        datasetJobs: [
          Em.Object.create({
            status: 'SUCCESSFUL'
          })
        ]
      },
      className: 'health-status-LIVE',
      icon: App.healthIconClassGreen
    },
    {
      title: 'should be dead for failed first job',
      data: {
        datasetJobs: [
          Em.Object.create({
            status: 'SUSPENDED',
            endDate: 1
          }),
          Em.Object.create({
            status: 'FAILED',
            endDate: 0
          })
        ]
      },
      className: 'health-status-DEAD-RED',
      icon: App.healthIconClassRed
    },
    {
      title: 'should be for no jobs',
      data: {
        datasetJobs: []
      },
      className: 'health-status-LIVE',
      icon: App.healthIconClassGreen
    }
  ];

describe('App.Dataset', function () {

  beforeEach(function () {
    dataset = App.Dataset.createRecord(datasetData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(dataset);
  });

  describe('#prefixedName', function () {
    it('should add mirroring prefix before the name', function () {
      dataset.set('name', 'name');
      expect(dataset.get('prefixedName')).to.equal(App.mirroringDatasetNamePrefix + 'name');
    });
  });

  describe('#statusFormatted', function () {
    it('should be in lower case and capitalized', function () {
      dataset.set('status', 'RUNNING');
      expect(dataset.get('statusFormatted')).to.equal('Running');
    });
  });

  statusCases.forEach(function (item) {
    describe(item.property, function () {

      beforeEach(function () {
        dataset.set('status', item.status);
      });

      it('should be true', function () {
        expect(dataset.get(item.property)).to.be.true;
      });

      it('others should be false', function () {
        var falseProperties = statusCases.mapProperty('property').without(item.property);
        var falseStates = [];
        falseProperties.forEach(function (prop) {
          falseStates.push(dataset.get(prop));
        });
        expect(falseStates).to.eql([false, false]);
      });

    });
  });

  describe('#healthClass', function () {
    healthCases.forEach(function (item) {
      it(item.title, function () {
        dataset.reopen(item.data);
        expect(dataset.get('healthClass')).to.equal(item.className);
      });
    });
  });

  describe('#healthIconClass', function () {
    healthCases.forEach(function (item) {
      it(item.title, function () {
        dataset.reopen(item.data);
        expect(dataset.get('healthIconClass')).to.equal(item.icon);
      });
    });
  });

});

});

;require.register("test/models/form_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/form');

var form,
  field,
  formField,
  resultCases = [
    {
      text: Em.I18n.t('form.saveError'),
      result: -1
    },
    {
      text: Em.I18n.t('form.saveSuccess'),
      result: 1
    },
    {
      text: '',
      result: 0
    }
  ],
  displayTypeCases = [
    {
      type: 'checkbox',
      classString: 'Checkbox'
    },
    {
      type: 'select',
      classString: 'Select'
    },
    {
      type: 'textarea',
      classString: 'TextArea'
    },
    {
      type: 'password',
      classString: 'TextField'
    },
    {
      type: 'hidden',
      classString: 'TextField'
    }
  ],
  hiddenCases = [
    {
      displayType: 'password',
      type: 'hidden',
      value: false
    },
    {
      displayType: 'hidden',
      type: 'hidden',
      value: true
    }
  ],
  expectError = function (message) {
    formField.validate();
    expect(formField.get('errorMessage')).to.equal(message);
  };

describe('App.Form', function () {

  beforeEach(function () {
    form = App.Form.create({
      fieldsOptions: [
        {
          name: 'field0',
          value: 'value0',
          isRequired: false
        }
      ]
    });
    field = form.get('fields').objectAt(0);
  });

  describe('#fields', function () {
    it('should get data from formFields', function () {
      var fields = form.get('fields');
      expect(fields).to.have.length(1);
      expect(field.get('name')).to.equal('field0');
    });
  });

  describe('#field', function () {
    it('should get data from formFields', function () {
      var field0 = form.get('field.field0');
      expect(form.get('field')).to.not.be.empty;
      expect(field0.get('name')).to.equal('field0');
      expect(field0.get('form')).to.eql(form);
    });
  });

  describe('#getField', function () {
    it('should get field0', function () {
      expect(form.getField('field0')).to.eql(form.get('field.field0'));
    });
    it('should be empty', function () {
      form.set('fields', []);
      expect(form.getField()).to.be.empty;
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      field.set('isRequired', false);
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      field.setProperties({
        isRequired: true,
        value: ''
      });
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#updateValues', function () {
    it('should update field0 value', function () {
      form.set('object', Em.Object.create({field0: 'value0upd'}));
      expect(field.get('value')).to.equal('value0upd');
    });
    it('should empty password value', function () {
      field.set('displayType', 'password');
      form.set('object', Em.Object.create());
      expect(field.get('value')).to.be.empty;
    });
    it('should clear values', function () {
      form.set('object', []);
      expect(field.get('value')).to.be.empty;
    });
  });

  describe('#clearValues', function () {
    it('should clear values', function () {
      var field0 = form.get('fields').objectAt(0);
      field0.set('value', 'value0');
      form.clearValues();
      expect(field0.get('value')).to.be.empty;
    });
  });

  describe('#resultText', function () {
    resultCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        form.set('result', item.result);
        expect(form.get('resultText')).to.equal(item.text);
      });
    });
  });

});

describe('App.FormField', function () {

  beforeEach(function () {
    formField = App.FormField.create();
  });

  describe('#isValid', function () {
    it('should be true', function () {
      expect(formField.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      formField.set('errorMessage', 'error');
      expect(formField.get('isValid')).to.be.false;
    });
  });

  describe('#viewClass', function () {
    displayTypeCases.forEach(function (item) {
      it('should be ' + item.classString, function () {
        formField.set('displayType', item.type);
        expect(formField.get('viewClass').toString()).to.contain(item.classString);
      });
    });
  });

  describe('#validate', function () {
    it('should return error message', function () {
      formField.set('isRequired', true);
      expectError('This is required');
    });
    it('should return empty error message', function () {
      formField.set('isRequired', false);
      expectError('');
      formField.set('value', 'value');
      expectError('');
    });
  });

  describe('#isHiddenField', function () {
    hiddenCases.forEach(function (item) {
      it('should be ' + item.value, function () {
        formField.setProperties(item);
        expect(formField.get('isHiddenField')).to.equal(item.value);
      });
    });
  });

});

});

;require.register("test/models/host_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');

describe('App.HostComponent', function() {

  App.store.load(App.HostComponent, {
    id: 'COMP_host',
    component_name: 'COMP1'
  });
  var hc = App.HostComponent.find('COMP_host');


  describe('#getStatusesList', function() {
    it('allowed statuses', function() {
      var statuses = ["STARTED","STARTING","INSTALLED","STOPPING","INSTALL_FAILED","INSTALLING","UPGRADE_FAILED","UNKNOWN","DISABLED","INIT"];
      expect(App.HostComponentStatus.getStatusesList()).to.include.members(statuses);
      expect(statuses).to.include.members(App.HostComponentStatus.getStatusesList());
    });
  });

  describe('#getStatusesList', function() {
    it('allowed statuses', function() {
      var statuses = ["STARTED","STARTING","INSTALLED","STOPPING","INSTALL_FAILED","INSTALLING","UPGRADE_FAILED","UNKNOWN","DISABLED","INIT"];
      expect(App.HostComponentStatus.getStatusesList()).to.include.members(statuses);
      expect(statuses).to.include.members(App.HostComponentStatus.getStatusesList());
    });
  });

  describe('#isClient', function() {
    it('', function() {
      sinon.stub(App.get('components.clients'), 'contains', Em.K);
      hc.propertyDidChange('isClient');
      hc.get('isClient');
      expect(App.get('components.clients').contains.calledWith('COMP1')).to.be.true;
      App.get('components.clients').contains.restore();
    });
  });

  describe('#displayName', function() {
    it('', function() {
      sinon.stub(App.format, 'role', Em.K);
      hc.propertyDidChange('displayName');
      hc.get('displayName');
      expect(App.format.role.calledWith('COMP1')).to.be.true;
      App.format.role.restore();
    });
  });

  describe('#isMaster', function() {
    it('', function() {
      sinon.stub(App.get('components.masters'), 'contains', Em.K);
      hc.propertyDidChange('isMaster');
      hc.get('isMaster');
      expect(App.get('components.masters').contains.calledWith('COMP1')).to.be.true;
      App.get('components.masters').contains.restore();
    });
  });

  describe('#isSlave', function() {
    it('', function() {
      sinon.stub(App.get('components.slaves'), 'contains', Em.K);
      hc.propertyDidChange('isSlave');
      hc.get('isSlave');
      expect(App.get('components.slaves').contains.calledWith('COMP1')).to.be.true;
      App.get('components.slaves').contains.restore();
    });
  });

  describe('#isDeletable', function() {
    it('', function() {
      sinon.stub(App.get('components.deletable'), 'contains', Em.K);
      hc.propertyDidChange('isDeletable');
      hc.get('isDeletable');
      expect(App.get('components.deletable').contains.calledWith('COMP1')).to.be.true;
      App.get('components.deletable').contains.restore();
    });
  });

  describe('#isRunning', function() {
    var testCases = [
      {
        workStatus: 'INSTALLED',
        result: false
      },
      {
        workStatus: 'STARTING',
        result: true
      },
      {
        workStatus: 'STARTED',
        result: true
      }
    ];
    testCases.forEach(function(test){
      it('workStatus - ' + test.workStatus, function() {
        hc.set('workStatus', test.workStatus);
        hc.propertyDidChange('isRunning');
        expect(hc.get('isRunning')).to.equal(test.result);
      });
    });
  });

  describe('#isDecommissioning', function() {
    var mock = [];
    beforeEach(function () {
      sinon.stub(App.HDFSService, 'find', function () {
        return mock;
      })
    });
    afterEach(function () {
      App.HDFSService.find.restore();
    });
    it('component name is not DATANODE', function() {
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('component name is DATANODE but no HDFS service', function() {
      hc.set('componentName', 'DATANODE');
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('HDFS has no decommission DataNodes', function() {
      hc.set('componentName', 'DATANODE');
      mock.push(Em.Object.create({
        decommissionDataNodes: []
      }));
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('HDFS has decommission DataNodes', function() {
      hc.set('componentName', 'DATANODE');
      hc.set('hostName', 'host1');
      mock.clear();
      mock.push(Em.Object.create({
        decommissionDataNodes: [{hostName: 'host1'}]
      }));
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.true;
    });
  });

  describe('#isActive', function() {
    it('passiveState is ON', function() {
      hc.set('passiveState', "ON");
      hc.propertyDidChange('isActive');
      expect(hc.get('isActive')).to.be.false;
    });
    it('passiveState is OFF', function() {
      hc.set('passiveState', "OFF");
      hc.propertyDidChange('isActive');
      expect(hc.get('isActive')).to.be.true;
    });
  });

  describe('#statusClass', function() {
    it('isActive is false', function() {
      hc.reopen({
        isActive: false
      });
      hc.propertyDidChange('statusClass');
      expect(hc.get('statusClass')).to.equal('icon-medkit');
    });
    it('isActive is true', function() {
      var status = 'INSTALLED';
      hc.set('isActive', true);
      hc.set('workStatus', status);
      hc.propertyDidChange('statusClass');
      expect(hc.get('statusClass')).to.equal(status);
    });
  });

  describe('#statusIconClass', function () {
    var testCases = [
      {
        statusClass: 'STARTED',
        result: 'icon-ok-sign'
      },
      {
        statusClass: 'STARTING',
        result: 'icon-ok-sign'
      },
      {
        statusClass: 'INSTALLED',
        result: 'icon-warning-sign'
      },
      {
        statusClass: 'STOPPING',
        result: 'icon-warning-sign'
      },
      {
        statusClass: 'UNKNOWN',
        result: 'icon-question-sign'
      },
      {
        statusClass: '',
        result: ''
      }
    ];

    it('reset statusClass to plain property', function () {
      hc.reopen({
        statusClass: ''
      })
    });
    testCases.forEach(function (test) {
      it('statusClass - ' + test.statusClass, function () {
        hc.set('statusClass', test.statusClass);
        hc.propertyDidChange('statusIconClass');
        expect(hc.get('statusIconClass')).to.equal(test.result);
      });
    });
  });

  describe('#componentTextStatus', function() {
    it('', function() {
      var status = 'INSTALLED';
      sinon.stub(App.HostComponentStatus, 'getTextStatus', Em.K);
      hc.set('workStatus', status);
      hc.propertyDidChange('componentTextStatus');
      hc.get('componentTextStatus');
      expect(App.HostComponentStatus.getTextStatus.calledWith(status)).to.be.true;
      App.HostComponentStatus.getTextStatus.restore();
    });
  });
});
});

;require.register("test/models/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var misc = require('utils/misc');

require('models/host');

describe('App.Host', function () {

  var data = [
    {
      id: 'host1',
      host_name: 'host1',
      memory: 200000,
      disk_total: 100.555,
      disk_free: 90.555,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 18100000
    },
    {
      id: 'host2',
      host_name: 'host2',
      memory: 99999,
      disk_total: 90,
      disk_free: 90,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 170000
    },
    {
      id: 'host3',
      host_name: 'host3',
      memory: 99999,
      disk_total: 99.999,
      disk_free: 0,
      health_status: 'UNKNOWN',
      last_heart_beat_time: (new Date()).getTime()
    }
  ];
  before(function() {
    App.set('testMode', false);
  });
  App.Host.reopen({
    hostComponents: []
  });
  App.store.loadMany(App.Host, data);

  var host1 = App.Host.find('host1');

  describe('#diskUsedFormatted', function () {

    it('host1 - 10GB ', function () {
      expect(host1.get('diskUsedFormatted')).to.equal('10GB');
    });
    it('host2 - 0GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsedFormatted')).to.equal('0GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsedFormatted')).to.equal('100GB');
    });
  });

  describe('#diskTotalFormatted', function () {

    it('host1 - 100.56GB ', function () {
      expect(host1.get('diskTotalFormatted')).to.equal('100.56GB');
    });
    it('host2 - 90GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskTotalFormatted')).to.equal('90GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskTotalFormatted')).to.equal('100GB');
    });
  });

  describe('#diskUsageFormatted', function () {

    it('host1 - 9.94% ', function () {
      expect(host1.get('diskUsageFormatted')).to.equal('9.94%');
    });
    it('host2 - 0%', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsageFormatted')).to.equal('0%');
    });
    it('host3 - 100%', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsageFormatted')).to.equal('100%');
    });
  });

  describe('#isNotHeartBeating', function () {
    it('host2 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('isNotHeartBeating')).to.equal(false);
    });
    it('host3 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('isNotHeartBeating')).to.equal(true);
    });
  });

  describe('#cpuUsage', function () {
    var testCases = [
      {
        params: {
          cpuSystem: undefined,
          cpuUser: undefined
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 0,
          cpuUser: 0
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 1,
          cpuUser: 0
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 0,
          cpuUser: 1
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 1,
          cpuUser: 1
        },
        result: 2
      }
    ];
    testCases.forEach(function (test) {
      it('cpuSystem - ' + test.params.cpuSystem + ', cpuUser - ' + test.params.cpuUser, function () {
        host1.set('cpuSystem', test.params.cpuSystem);
        host1.set('cpuUser', test.params.cpuUser);
        host1.propertyDidChange('cpuUsage');

        expect(host1.get('cpuUsage')).to.equal(test.result);
      });
    });
  });

  describe('#memoryUsage', function () {
    var testCases = [
      {
        params: {
          memFree: undefined,
          memTotal: undefined
        },
        result: 0
      },
      {
        params: {
          memFree: 0,
          memTotal: 0
        },
        result: 0
      },
      {
        params: {
          memFree: 1,
          memTotal: 0
        },
        result: 0
      },
      {
        params: {
          memFree: 0,
          memTotal: 1
        },
        result: 0
      },
      {
        params: {
          memFree: 1,
          memTotal: 2
        },
        result: 50
      }
    ];
    testCases.forEach(function (test) {
      it('memFree - ' + test.params.memFree + ', memTotal - ' + test.params.memTotal, function () {
        host1.set('memFree', test.params.memFree);
        host1.set('memTotal', test.params.memTotal);
        host1.propertyDidChange('memoryUsage');

        expect(host1.get('memoryUsage')).to.equal(test.result);
      });
    });
  });

  describe('#componentsWithStaleConfigs', function () {
    it('One component with stale configs', function () {
      host1.set('hostComponents', [Em.Object.create({
        staleConfigs: true
      })]);
      host1.propertyDidChange('componentsWithStaleConfigs');
      expect(host1.get('componentsWithStaleConfigs')).to.eql([Em.Object.create({
        staleConfigs: true
      })]);
    });
    it('No components with stale configs', function () {
      host1.set('hostComponents', [Em.Object.create({
        staleConfigs: false
      })]);
      host1.propertyDidChange('componentsWithStaleConfigs');
      expect(host1.get('componentsWithStaleConfigs')).to.be.empty;
    });
  });

  describe('#componentsInPassiveStateCount', function () {
    it('No component in passive state', function () {
      host1.set('hostComponents', [Em.Object.create({
        passiveState: 'OFF'
      })]);
      host1.propertyDidChange('componentsInPassiveStateCount');

      expect(host1.get('componentsInPassiveStateCount')).to.equal(0);
    });
    it('One component in passive state', function () {
      host1.set('hostComponents', [Em.Object.create({
        passiveState: 'ON'
      })]);
      host1.propertyDidChange('componentsInPassiveStateCount');

      expect(host1.get('componentsInPassiveStateCount')).to.equal(1);
    });
  });

  describe('#disksMounted', function () {
    it('', function () {
      host1.set('diskInfo', [
        {}
      ]);
      host1.propertyDidChange('disksMounted');
      expect(host1.get('disksMounted')).to.equal(1);
    });
  });

  describe('#coresFormatted', function () {
    it('', function () {
      host1.set('cpu', 1);
      host1.set('cpuPhysical', 2);
      host1.propertyDidChange('coresFormatted');
      expect(host1.get('coresFormatted')).to.equal('1 (2)');
    });
  });

  describe('#diskUsed', function () {
    it('diskFree and diskTotal are 0', function () {
      host1.set('diskFree', 0);
      host1.set('diskTotal', 0);
      host1.propertyDidChange('diskUsed');
      expect(host1.get('diskUsed')).to.equal(0);
    });
    it('diskFree is 0 and diskTotal is 10', function () {
      host1.set('diskFree', 0);
      host1.set('diskTotal', 10);
      host1.propertyDidChange('diskUsed');
      expect(host1.get('diskUsed')).to.equal(10);
    });
  });

  describe('#diskUsage', function () {
    it('', function () {
      host1.reopen({
        diskUsed: 10
      });
      host1.set('diskTotal', 100);
      host1.propertyDidChange('diskUsage');
      expect(host1.get('diskUsage')).to.equal(10);
    });
  });

  describe('#memoryFormatted', function () {
    it('', function () {
      host1.set('memory', 1024);
      sinon.stub(misc, 'formatBandwidth', Em.K);
      host1.propertyDidChange('memoryFormatted');
      host1.get('memoryFormatted');
      expect(misc.formatBandwidth.calledWith(1048576)).to.be.true;
      misc.formatBandwidth.restore()
    });
  });

  describe('#loadAvg', function () {
    var testCases = [
      {
        params: {
          loadOne: null,
          loadFive: null,
          loadFifteen: null
        },
        result: null
      },
      {
        params: {
          loadOne: 1.111,
          loadFive: 5.555,
          loadFifteen: 15.555
        },
        result: '1.11'
      },
      {
        params: {
          loadOne: null,
          loadFive: 5.555,
          loadFifteen: 15.555
        },
        result: '5.55'
      },
      {
        params: {
          loadOne: null,
          loadFive: null,
          loadFifteen: 15.555
        },
        result: '15.55'
      }
    ];

    testCases.forEach(function (test) {
      it('loadOne - ' + test.params.loadOne + ', loadFive - ' + test.params.loadFive + ', loadFifteen - ' + test.params.loadFifteen, function () {
        host1.set('loadOne', test.params.loadOne);
        host1.set('loadFive', test.params.loadFive);
        host1.set('loadFifteen', test.params.loadFifteen);
        host1.propertyDidChange('loadAvg');
        expect(host1.get('loadAvg')).to.equal(test.result);
      });
    });
  });

  describe('#healthClass', function () {
    var testCases = [
      {
        params: {
          passiveState: 'ON',
          healthStatus: null
        },
        result: 'icon-medkit'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'UNKNOWN'
        },
        result: 'health-status-DEAD-YELLOW'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'HEALTHY'
        },
        result: 'health-status-LIVE'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'UNHEALTHY'
        },
        result: 'health-status-DEAD-RED'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'ALERT'
        },
        result: 'health-status-DEAD-ORANGE'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: null
        },
        result: 'health-status-DEAD-YELLOW'
      }
    ];

    testCases.forEach(function (test) {
      it('passiveState - ' + test.params.passiveState + ', healthStatus - ' + test.params.healthStatus, function () {
        host1.set('passiveState', test.params.passiveState);
        host1.set('healthStatus', test.params.healthStatus);
        host1.propertyDidChange('healthClass');
        expect(host1.get('healthClass')).to.equal(test.result);
      });
    });
  });

  describe('#healthIconClass', function () {
    var testCases = [
      {
        params: {
          healthClass: 'health-status-LIVE'
        },
        result: 'icon-ok-sign'
      },
      {
        params: {
          healthClass: 'health-status-DEAD-RED'
        },
        result: 'icon-warning-sign'
      },
      {
        params: {
          healthClass: 'health-status-DEAD-YELLOW'
        },
        result: 'icon-question-sign'
      },
      {
        params: {
          healthClass: 'health-status-DEAD-ORANGE'
        },
        result: 'icon-minus-sign'
      },
      {
        params: {
          healthClass: ''
        },
        result: ''
      }
    ];

    it('reset healthClass to plain property', function(){
      host1.reopen({
        healthClass: ''
      });
    });
    testCases.forEach(function (test) {
      it('healthClass - ' + test.params.healthClass, function () {
        host1.set('healthClass', test.params.healthClass);
        host1.propertyDidChange('healthIconClass');
        expect(host1.get('healthIconClass')).to.equal(test.result);
      });
    });
  });
});

});

;require.register("test/models/hosts_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/hosts');

var hostInfo,
  statusCases = [
    {
      status: 'REGISTERED',
      bootStatusForDisplay: 'Success',
      bootBarColor: 'progress-success',
      bootStatusColor: 'text-success',
      isBootDone: true
    },
    {
      status: 'FAILED',
      bootStatusForDisplay: 'Failed',
      bootBarColor: 'progress-danger',
      bootStatusColor: 'text-error',
      isBootDone: true
    },
    {
      status: 'PENDING',
      bootStatusForDisplay: 'Preparing',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'RUNNING',
      bootStatusForDisplay: 'Installing',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'DONE',
      bootStatusForDisplay: 'Registering',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'REGISTERING',
      bootStatusForDisplay: 'Registering',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    }
  ],
  tests = ['bootStatusForDisplay', 'bootBarColor', 'bootStatusColor', 'isBootDone'];

describe('App.HostInfo', function () {

  beforeEach(function () {
    hostInfo = App.HostInfo.create();
  });

  tests.forEach(function (property) {
    describe('#' + property, function () {
      statusCases.forEach(function (testCase) {
        it('should be ' + testCase[property], function () {
          hostInfo.set('bootStatus', testCase.status);
          expect(hostInfo.get(property)).to.equal(testCase[property]);
        });
      });
    });
  });

});

});

;require.register("test/models/rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host');
require('models/rack');

describe('App.Rack', function () {

  var data = {
    id: 'rack1',
    name: 'rack1'
  };

  App.store.load(App.Rack, data);

  describe('#liveHostsCount', function () {

    it('rack1 has two live hosts', function () {
      var rack = App.Rack.find().findProperty('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(2);
    });

    it('rack1 has three live hosts', function () {
      App.store.load(App.Host, {
        id: 'host3',
        host_name: 'host3',
        health_status: 'HEALTHY'
      });
      var rack = App.Rack.find().findProperty('name', 'rack1');
      rack.set('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(3);
    });
  });


});

});

;require.register("test/models/run_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/run');

var run,
  job,
  runData = {
    id: 'run'
  },
  jobData = {
    id: 'job'
  },
  cases = [
    {
      id: 'pig_run',
      type: 'Pig'
    },
    {
      id: 'hive_run',
      type: 'Hive'
    },
    {
      id: 'mr_run',
      type: 'MapReduce'
    },
    {
      id: 'run_pig_hive_mr_id',
      type: ''
    }
  ];

describe('App.Run', function () {

  beforeEach(function () {
    run = App.Run.createRecord(runData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(run);
  });

  describe('#idFormatted', function () {
    it('should shorten id to 20 characters', function () {
      for (var i = 21, name = ''; i--; ) {
        name += 'n';
      }
      run.set('id', name);
      expect(run.get('idFormatted')).to.have.length(20);
    });
  });

  describe('#jobs', function () {

    beforeEach(function () {
      job = App.Job.createRecord(jobData);
      job.reopen({
        run: runData
      });
    });

    afterEach(function () {
      modelSetup.deleteRecord(job);
    });

    it('should load corresponding jobs from the store', function () {
      run.set('loadAllJobs', true);
      expect(run.get('jobs')).to.have.length(1);
      expect(run.get('jobs').objectAt(0).get('run.id')).to.equal('run');
    });

  });

  describe('#duration', function () {
    it('should convert elapsedTime into time format', function () {
      run.set('elapsedTime', 1000);
      expect(run.get('duration')).to.equal('1.00 secs');
    });
  });

  describe('#isRunning', function () {
    it('should be true', function () {
      run.setProperties({
        numJobsTotal: 5,
        numJobsCompleted: 0
      });
      expect(run.get('isRunning')).to.be.true;
    });
    it('should be false', function () {
      run.setProperties({
        numJobsTotal: 5,
        numJobsCompleted: 5
      });
      expect(run.get('isRunning')).to.be.false;
    });
  });

  describe('#inputFormatted', function () {
    it('should convert input into bandwidth format', function () {
      run.set('input', 1024);
      expect(run.get('inputFormatted')).to.equal('1.0KB');
    });
  });

  describe('#outputFormatted', function () {
    it('should convert output into bandwidth format', function () {
      run.set('output', 1024);
      expect(run.get('outputFormatted')).to.equal('1.0KB');
    });
  });

  describe('#lastUpdateTime', function () {
    it('should sum elapsedTime and startTime', function () {
      run.setProperties({
        elapsedTime: 1000,
        startTime: 2000
      });
      expect(run.get('lastUpdateTime')).to.equal(3000);
    });
  });

  describe('#lastUpdateTimeFormattedShort', function () {
    it('should form date and time from lastUpdateTime', function () {
      run.setProperties({
        elapsedTime: 1000,
        startTime: 100000000000
      });
      expect(run.get('lastUpdateTimeFormattedShort')).to.equal('Sat Mar 03 1973');
    });
  });

  describe('#type', function () {
    cases.forEach(function (item) {
      it('should be ' + (item.type ? item.type : 'empty'), function () {
        run.set('id', item.id);
        expect(run.get('type')).to.equal(item.type);
      });
    });
  });

});

});

;require.register("test/models/service/flume_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/flume');

var flumeAgent,
  flumeAgentData = {
    id: 'agent',
    name: 'agent'
  },
  cases = [
    {
      status: 'RUNNING',
      healthClass: App.healthIconClassGreen
    },
    {
      status: 'NOT_RUNNING',
      healthClass: App.healthIconClassRed
    },
    {
      status: 'UNKNOWN',
      healthClass: App.healthIconClassYellow
    },
    {
      status: 'ANOTHER_STATUS',
      healthClass: App.healthIconClassYellow
    }
  ];

describe('App.FlumeAgent', function () {

  beforeEach(function () {
    flumeAgent = App.FlumeAgent.createRecord(flumeAgentData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(flumeAgent);
  });

  describe('#healthClass', function () {
    cases.forEach(function (item) {
      var healthClass = item.healthClass;
      it('should be ' + healthClass, function () {
        flumeAgent.set('status', item.status);
        expect(flumeAgent.get('healthClass')).to.equal(healthClass);
      });
    });
  });

});

});

;require.register("test/models/service/hdfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/hdfs');

var hdfsService,
  hdfsServiceData = {
    id: 'hdfs'
  },
  hostComponentsData = [
    {
      id: 'journalnode',
      componentName: 'JOURNALNODE'
    }
  ],
  cases = [
    {
      propertyName: 'journalNodes',
      componentId: 'journalnode'
    }
  ];

describe('App.HDFSService', function () {

  beforeEach(function () {
    hdfsService = App.HDFSService.createRecord(hdfsServiceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(hdfsService);
  });

  cases.forEach(function (item) {
    var propertyName = item.propertyName;
    describe('#' + propertyName, function () {
      it('should take one component from hostComponents', function () {
        hdfsService.reopen({
          hostComponents: hostComponentsData
        });
        expect(hdfsService.get(propertyName)).to.have.length(1);
        expect(hdfsService.get(propertyName)[0].id).to.equal(item.componentId);
      });
    });
  });

});

});

;require.register("test/models/service/yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/yarn');

var yarnService,
  yarnServiceData = {
    id: 'yarn'
  },
  hostComponentsData = [
    {
      id: 'ats',
      componentName: 'APP_TIMELINE_SERVER',
      host: {
        id: 'host'
      }
    },
    {
      id: 'nodemanager',
      componentName: 'NODEMANAGER',
      host: {
        id: 'host'
      }
    },
    {
      id: 'yarnclient',
      componentName: 'YARN_CLIENT',
      host: {
        id: 'host'
      }
    }
  ],
  configs = [
    {
      properties: {
        'yarn.timeline-service.webapp.address': '0.0.0.0:0000'
      },
      tag: 'version2',
      type: 'yarn-site'
    }
  ],
  nodeCountCases = [
    {
      assets: {
        nodeManagersStarted: 0,
        nodeManagersInstalled: 1,
        nodeManagersTotal: 1,
        nodeManagersCountActive: 0,
        nodeManagersCountRebooted: 0,
        nodeManagersCountUnhealthy: 0,
        nodeManagersCountDecommissioned: 0
      },
      nodeManagersCountLost: 1
    },
    {
      assets: {
        nodeManagersStarted: 1,
        nodeManagersInstalled: 1,
        nodeManagersTotal: 1,
        nodeManagersCountActive: 1,
        nodeManagersCountRebooted: 1,
        nodeManagersCountUnhealthy: 0,
        nodeManagersCountDecommissioned: 0
      },
      nodeManagersCountLost: 0
    }
  ],
  setHostComponents = function () {
    yarnService.reopen({
      hostComponents: hostComponentsData
    });
  };

describe('App.YARNService', function () {

  beforeEach(function () {
    yarnService = App.YARNService.createRecord(yarnServiceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(yarnService);
  });

  describe('#ahsWebPort', function () {

    afterEach(function () {
      App.db.setConfigs([]);
    });

    it('should be 8188 as default', function () {
      App.db.setConfigs([]);
      expect(yarnService.get('ahsWebPort')).to.equal('8188');
    });

    it('should get value from configs', function () {
      App.db.setConfigs(configs);
      expect(yarnService.get('ahsWebPort')).to.equal('0000');
    });

  });

  describe('#queueFormatted', function () {
    it('should return formatted string', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queueFormatted')).to.equal('default (/root)<br/>');
    });
  });

  describe('#queuesCount', function () {
    it('should be 1', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queuesCount')).to.equal(1);
    });
  });

  describe('#maxMemory', function () {
    it('should add availableMemory to allocatedMemory', function () {
      yarnService.set('allocatedMemory', 1024);
      yarnService.set('availableMemory', 2048);
      expect(yarnService.get('maxMemory')).to.equal(3072);
    });
  });

  describe('#allQueueNames', function () {
    it('should list all queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('allQueueNames')).to.eql(['root', 'root/default']);
    });
  });

  describe('#childQueueNames', function () {
    it('should list child queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('childQueueNames')).to.eql(['root/default']);
    });
  });

  describe('#nodeManagersCountLost', function () {
    nodeCountCases.forEach(function (item) {
      it('should be ' + item.nodeManagersCountLost, function () {
        setHostComponents();
        for (var prop in item.assets) {
          yarnService.set(prop, item.assets[prop]);
        };
        expect(yarnService.get('nodeManagersCountLost')).to.equal(item.nodeManagersCountLost);
      });
    });
  });

});

});

;require.register("test/models/service_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/service_config');

var serviceConfig,
  serviceConfigCategory,
  group,
  serviceConfigProperty,
  serviceConfigPropertyInit,
  configsData = [
    Ember.Object.create({
      overrides: [
        {
          error: true,
          errorMessage: 'error'
        },
        {
          error: true
        },
        {}
      ]
    }),
    Ember.Object.create({
      isValid: false,
      isVisible: true
    }),
      Ember.Object.create({
      isValid: true,
      isVisible: true
    }),
    Ember.Object.create({
      isValid: false,
      isVisible: false
    })
  ],
  configCategoriesData = [
    Em.Object.create({
      slaveErrorCount: 1
    }),
    Em.Object.create({
      slaveErrorCount: 2
    })
  ],
  nameCases = [
    {
      name: 'DataNode',
      primary: 'DATANODE'
    },
    {
      name: 'TaskTracker',
      primary: 'TASKTRACKER'
    },
    {
      name: 'RegionServer',
      primary: 'HBASE_REGIONSERVER'
    },
    {
      name: 'name',
      primary: null
    }
  ],
  components = [
    {
      name: 'NameNode',
      master: true
    },
    {
      name: 'SNameNode',
      master: true
    },
    {
      name: 'JobTracker',
      master: true
    },
    {
      name: 'HBase Master',
      master: true
    },
    {
      name: 'Oozie Master',
      master: true
    },
    {
      name: 'Hive Metastore',
      master: true
    },
    {
      name: 'WebHCat Server',
      master: true
    },
    {
      name: 'ZooKeeper Server',
      master: true
    },
    {
      name: 'Nagios',
      master: true
    },
    {
      name: 'Ganglia',
      master: true
    },
    {
      name: 'DataNode',
      slave: true
    },
    {
      name: 'TaskTracker',
      slave: true
    },
    {
      name: 'RegionServer',
      slave: true
    }
  ],
  masters = components.filterProperty('master'),
  slaves = components.filterProperty('slave'),
  groupsData = {
    groups: [
      Em.Object.create({
        errorCount: 1
      }),
      Em.Object.create({
        errorCount: 2
      })
    ]
  },
  groupNoErrorsData = [].concat(configsData.slice(2)),
  groupErrorsData = [configsData[1]],
  overridableFalseData = [
    {
      isOverridable: false
    },
    {
      isEditable: false,
      overrides: configsData[0].overrides
    },
    {
      displayType: 'masterHost'
    }
  ],
  overridableTrueData = [
    {
      isOverridable: true,
      isEditable: true
    },    {
      isOverridable: true,
      overrides: []
    },
    {
      isOverridable: true
    }
  ],
  overriddenFalseData = [
    {
      overrides: null,
      isOriginalSCP: true
    },
    {
      overrides: [],
      isOriginalSCP: true
    }
  ],
  overriddenTrueData = [
    {
      overrides: configsData[0].overrides
    },
    {
      isOriginalSCP: false
    }
  ],
  removableFalseData = [
    {
      isEditable: false
    },
    {
      hasOverrides: true
    },
    {
      isUserProperty: false,
      isOriginalSCP: true
    }
  ],
  removableTrueData = [
    {
      isEditable: true,
      hasOverrides: false,
      isUserProperty: true
    },
    {
      isEditable: true,
      hasOverrides: false,
      isOriginalSCP: false
    }
  ],
  initPropertyData = [
    {
      initial: {
        displayType: 'password',
        value: 'value'
      },
      result: {
        retypedPassword: 'value'
      }
    },
    {
      initial: {
        id: 'puppet var',
        value: '',
        defaultValue: 'default'
      },
      result: {
        value: 'default'
      }
    }
  ],
  notDefaultFalseData = [
    {
      isEditable: false
    },
    {
      defaultValue: null
    },
    {
      value: 'value',
      defaultValue: 'value'
    }
  ],
  notDefaultTrueData = {
    isEditable: true,
    value: 'value',
    defaultValue: 'default'
  },
  types = ['masterHost', 'slaveHosts', 'masterHosts', 'slaveHost', 'radio button'],
  classCases = [
    {
      initial: {
        displayType: 'checkbox'
      },
      viewClass: App.ServiceConfigCheckbox
    },
    {
      initial: {
        displayType: 'password'
      },
      viewClass: App.ServiceConfigPasswordField
    },
    {
      initial: {
        displayType: 'combobox'
      },
      viewClass: App.ServiceConfigComboBox
    },
    {
      initial: {
        displayType: 'radio button'
      },
      viewClass: App.ServiceConfigRadioButtons
    },
    {
      initial: {
        displayType: 'directories'
      },
      viewClass: App.ServiceConfigTextArea
    },
    {
      initial: {
        displayType: 'content'
      },
      viewClass: App.ServiceConfigTextAreaContent

    },
    {
      initial: {
        displayType: 'multiLine'
      },
      viewClass: App.ServiceConfigTextArea
    },
    {
      initial: {
        displayType: 'custom'
      },
      viewClass: App.ServiceConfigBigTextArea
    },
    {
      initial: {
        displayType: 'masterHost'
      },
      viewClass: App.ServiceConfigMasterHostView
    },
    {
      initial: {
        displayType: 'masterHosts'
      },
      viewClass: App.ServiceConfigMasterHostsView
    },
    {
      initial: {
        displayType: 'slaveHosts'
      },
      viewClass: App.ServiceConfigSlaveHostsView
    },
    {
      initial: {
        unit: true,
        displayType: 'type'
      },
      viewClass: App.ServiceConfigTextFieldWithUnit
    },
    {
      initial: {
        unit: false,
        displayType: 'type'
      },
      viewClass: App.ServiceConfigTextField
    }
  ];


describe('App.ServiceConfig', function () {

  beforeEach(function () {
    serviceConfig = App.ServiceConfig.create();
  });

  describe('#errorCount', function () {
    it('should be 0', function () {
      serviceConfig.setProperties({
        configs: [],
        configCategories: []
      });
      expect(serviceConfig.get('errorCount')).to.equal(0);
    });
    it('should sum counts of all errors', function () {
      serviceConfig.setProperties({
        configs: configsData,
        configCategories: configCategoriesData
      });
      expect(serviceConfig.get('errorCount')).to.equal(6);
    });
  });

});

describe('App.ServiceConfigCategory', function () {

  beforeEach(function () {
    serviceConfigCategory = App.ServiceConfigCategory.create();
  });

  describe('#primaryName', function () {
    nameCases.forEach(function (item) {
      it('should return ' + item.primary, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('primaryName')).to.equal(item.primary);
      })
    });
  });

  describe('#isForMasterComponent', function () {
    masters.forEach(function (item) {
      it('should be true for ' + item.name, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('isForMasterComponent')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isForMasterComponent')).to.be.false;
    });
  });

  describe('#isForSlaveComponent', function () {
    slaves.forEach(function (item) {
      it('should be true for ' + item.name, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('isForSlaveComponent')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isForSlaveComponent')).to.be.false;
    });
  });

  describe('#slaveErrorCount', function () {
    it('should be 0', function () {
      serviceConfigCategory.set('slaveConfigs', []);
      expect(serviceConfigCategory.get('slaveErrorCount')).to.equal(0);
    });
    it('should sum all errorCount values', function () {
      serviceConfigCategory.set('slaveConfigs', groupsData);
      expect(serviceConfigCategory.get('slaveErrorCount')).to.equal(3);
    });
  });

  describe('#isAdvanced', function () {
    it('should be true', function () {
      serviceConfigCategory.set('name', 'Advanced');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.false;
    });
  });

});

describe('App.Group', function () {

  beforeEach(function () {
    group = App.Group.create();
  });

  describe('#errorCount', function () {
    it('should be 0', function () {
      group.set('properties', groupNoErrorsData);
      expect(group.get('errorCount')).to.equal(0);
    });
    it('should be 1', function () {
      group.set('properties', groupErrorsData);
      expect(group.get('errorCount')).to.equal(1);
    });
  });

});

describe('App.ServiceConfigProperty', function () {

  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create();
  });

  describe('#overrideErrorTrigger', function () {
    it('should be an increment', function () {
      serviceConfigProperty.set('overrides', configsData[0].overrides);
      expect(serviceConfigProperty.get('overrideErrorTrigger')).to.equal(1);
      serviceConfigProperty.set('overrides', []);
      expect(serviceConfigProperty.get('overrideErrorTrigger')).to.equal(2);
    });
  });

  describe('#isPropertyOverridable', function () {
    overridableFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.false;
      });
    });
    overridableTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.true;
      });
    });
  });

  describe('#isOverridden', function () {
    overriddenFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isOverridden')).to.be.false;
      });
    });
    overriddenTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isOverridden')).to.be.true;
      });
    });
  });

  describe('#isRemovable', function () {
    removableFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isRemovable')).to.be.false;
      });
    });
    removableTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isRemovable')).to.be.true;
      });
    });
  });

  describe('#init', function () {
    initPropertyData.forEach(function (item) {
      it('should set initial data', function () {
        serviceConfigPropertyInit = App.ServiceConfigProperty.create(item.initial);
        Em.keys(item.result).forEach(function (prop) {
          expect(serviceConfigPropertyInit.get(prop)).to.equal(item.result[prop]);
        });
      });
    });
  });

  describe('#isNotDefaultValue', function () {
    notDefaultFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.false;
      });
    });
    it('should be true', function () {
      Em.keys(notDefaultTrueData).forEach(function (prop) {
        serviceConfigProperty.set(prop, notDefaultTrueData[prop]);
      });
      expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.true;
    });
  });

  describe('#cantBeUndone', function () {
    types.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.set('displayType', item);
        expect(serviceConfigProperty.get('cantBeUndone')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigProperty.set('displayType', 'type');
      expect(serviceConfigProperty.get('cantBeUndone')).to.be.false;
    });
  });

  describe('#setDefaultValue', function () {
    it('should change the default value', function () {
      serviceConfigProperty.set('defaultValue', 'value0');
      serviceConfigProperty.setDefaultValue(/\d/, '1');
      expect(serviceConfigProperty.get('defaultValue')).to.equal('value1');
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      serviceConfigProperty.set('errorMessage', '');
      expect(serviceConfigProperty.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigProperty.set('errorMessage', 'message');
      expect(serviceConfigProperty.get('isValid')).to.be.false;
    });
  });

  describe('#viewClass', function () {
    classCases.forEach(function (item) {
      it ('should be ' + item.viewClass, function () {
        Em.keys(item.initial).forEach(function (prop) {
          serviceConfigProperty.set(prop, item.initial[prop]);
        });
        expect(serviceConfigProperty.get('viewClass')).to.eql(item.viewClass);
      });
    });
  });

  describe('#validate', function () {
    it('not required', function () {
      serviceConfigProperty.setProperties({
        isRequired: false,
        value: ''
      });
      expect(serviceConfigProperty.get('errorMessage')).to.be.empty;
      expect(serviceConfigProperty.get('error')).to.be.false;
    });
    it('should validate', function () {
      serviceConfigProperty.setProperties({
        isRequired: true,
        value: 'value'
      });
      expect(serviceConfigProperty.get('errorMessage')).to.be.empty;
      expect(serviceConfigProperty.get('error')).to.be.false;
    });
    it('should fail', function () {
      serviceConfigProperty.setProperties({
        isRequired: true,
        value: 'value'
      });
      serviceConfigProperty.set('value', '');
      expect(serviceConfigProperty.get('errorMessage')).to.equal('This is required');
      expect(serviceConfigProperty.get('error')).to.be.true;
    });
  });

});

describe('#initialValue - kafka.ganglia.metrics.host', function () {

  var tests = [
    {
      message: 'kafka.ganglia.metrics.host property should have the value of ganglia hostname when ganglia is selected',
      localDB: {masterComponentHosts: [
        {component: 'GANGLIA_SERVER', hostName: 'c6401'}
      ]},
      expected: 'c6401'
    },
    {
      message: 'kafka.ganglia.metrics.host property should have the value "localhost" when ganglia is not selected',
      localDB: {masterComponentHosts: [
        {component: 'NAMENODE', hostName: 'c6401'}
      ]},
      expected: 'localhost'
    }
  ];
  var serviceConfigProperty;
  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create({name: 'kafka.ganglia.metrics.host', value: 'localhost'});
  });
  tests.forEach(function(test){
    it(test.message, function () {
      serviceConfigProperty.initialValue(test.localDB);
      expect(serviceConfigProperty.get('value')).to.equal(test.expected);
    });
  });
});

describe('#initialValue - hive_database', function () {

  var cases = [
      {
        alwaysEnableManagedMySQLForHive: true,
        currentStateName: '',
        isManagedMySQLForHiveEnabled: false,
        receivedValue: 'New MySQL Database',
        value: 'New MySQL Database',
        options: [
          {
            displayName: 'New MySQL Database'
          }
        ],
        hidden: false
      },
      {
        alwaysEnableManagedMySQLForHive: false,
        currentStateName: 'configs',
        isManagedMySQLForHiveEnabled: false,
        receivedValue: 'New MySQL Database',
        value: 'New MySQL Database',
        options: [
          {
            displayName: 'New MySQL Database'
          }
        ],
        hidden: false
      },
      {
        alwaysEnableManagedMySQLForHive: false,
        currentStateName: '',
        isManagedMySQLForHiveEnabled: true,
        receivedValue: 'New MySQL Database',
        value: 'New MySQL Database',
        options: [
          {
            displayName: 'New MySQL Database'
          }
        ],
        hidden: false
      },
      {
        alwaysEnableManagedMySQLForHive: false,
        currentStateName: '',
        isManagedMySQLForHiveEnabled: false,
        receivedValue: 'New MySQL Database',
        value: 'Existing MySQL Database',
        options: [
          {
            displayName: 'New MySQL Database'
          }
        ],
        hidden: true
      },
      {
        alwaysEnableManagedMySQLForHive: false,
        currentStateName: '',
        isManagedMySQLForHiveEnabled: false,
        receivedValue: 'New PostgreSQL Database',
        value: 'New PostgreSQL Database',
        options: [
          {
            displayName: 'New MySQL Database'
          }
        ],
        hidden: true
      }
    ],
    title = 'value should be set to {0}';

  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create({
      name: 'hive_database'
    });
  });

  afterEach(function() {
    App.get.restore();
  });

  cases.forEach(function (item) {
    it(title.format(item.value), function () {
      sinon.stub(App, 'get')
        .withArgs('supports.alwaysEnableManagedMySQLForHive').returns(item.alwaysEnableManagedMySQLForHive)
        .withArgs('router.currentState.name').returns(item.currentStateName)
        .withArgs('isManagedMySQLForHiveEnabled').returns(item.isManagedMySQLForHiveEnabled);
      serviceConfigProperty.set('value', item.receivedValue);
      serviceConfigProperty.set('options', item.options);
      serviceConfigProperty.initialValue({});
      expect(serviceConfigProperty.get('value')).to.equal(item.value);
      expect(serviceConfigProperty.get('options').findProperty('displayName', 'New MySQL Database').hidden).to.equal(item.hidden);
    });
  });

});

});

;require.register("test/models/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service');

var service,
  serviceData = {
    id: 'service'
  },
  healthCases = [
    {
      status: 'STARTED',
      health: 'green'
    },
    {
      status: 'STARTING',
      health: 'green-blinking'
    },
    {
      status: 'INSTALLED',
      health: 'red'
    },
    {
      status: 'STOPPING',
      health: 'red-blinking'
    },
    {
      status: 'UNKNOWN',
      health: 'yellow'
    },
    {
      status: 'ANOTHER',
      health: 'yellow'
    }
  ],
  statusPropertiesCases = [
    {
      status: 'INSTALLED',
      property: 'isStopped'
    },
    {
      status: 'STARTED',
      property: 'isStarted'
    }
  ],
  services = [
    {
      name: 'HDFS',
      configurable: true
    },
    {
      name: 'YARN',
      configurable: true
    },
    {
      name: 'MAPREDUCE',
      configurable: true
    },
    {
      name: 'MAPREDUCE2',
      configurable: true
    },
    {
      name:'TEZ',
      clientOnly: true,
      configurable: true
    },
    {
      name: 'HBASE',
      configurable: true
    },
    {
      name: 'HIVE',
      configurable: true
    },
    {
      name: 'FLUME',
      configurable: true
    },
    {
      name: 'FALCON',
      configurable: true
    },
    {
      name: 'STORM',
      configurable: true
    },
    {
      name: 'OOZIE',
      configurable: true
    },
    {
      name: 'GANGLIA',
      configurable: true
    },
    {
      name: 'NAGIOS',
      configurable: true
    },
    {
      name: 'ZOOKEEPER',
      configurable: true
    },
    {
      name: 'PIG',
      configurable: true,
      clientOnly: true
    },
    {
      name: 'SQOOP',
      clientOnly: true
    },
    {
      name: 'HUE',
      configurable: true
    }
  ],
  clientsOnly = services.filterProperty('clientOnly').mapProperty('name'),
  configurable = services.filterProperty('configurable').mapProperty('name'),
  hostComponentsDataFalse = [
    [],
    [
      {
        staleConfigs: false
      }
    ],
    [
      {
        serviceName: 'HIVE',
        staleConfigs: false
      }
    ]
  ],
  hostComponentsDataTrue = [
    [
      Em.Object.create({
        staleConfigs: true,
        displayName: 'service0'
      })
    ],
    [
      Em.Object.create({
        host: {
          publicHostName: 'host0'
        },
        staleConfigs: true,
        displayName: 'service1'
      })
    ]
  ],
  restartData = {
    host0: ['service0', 'service1']
};

describe('App.Service', function () {

  beforeEach(function () {
    service = App.Service.createRecord(serviceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(service);
  });

  describe('#isInPassive', function () {
    it('should be true', function () {
      service.set('passiveState', 'ON');
      expect(service.get('isInPassive')).to.be.true;
    });
    it('should be false', function () {
      service.set('passiveState', 'OFF');
      expect(service.get('isInPassive')).to.be.false;
    });
  });

  describe('#healthStatus', function () {
    healthCases.forEach(function (item) {
      it('should be ' + item.health, function () {
        service.set('workStatus', item.status);
        expect(service.get('healthStatus')).to.equal(item.health);
      });
    });
  });

  statusPropertiesCases.forEach(function (item) {
    var status = item.status,
      property = item.property;
    describe('#' + property, function () {
      it('status ' + status + ' is for ' + property, function () {
        service.set('workStatus', status);
        expect(service.get(property)).to.be.true;
        var falseStates = statusPropertiesCases.mapProperty('property').without(property);
        var falseStatuses = [];
        falseStates.forEach(function (state) {
          falseStatuses.push(service.get(state));
        });
        expect(falseStatuses).to.eql([false]);
      });
    });
  });

  describe('#isRestartRequired', function () {
    hostComponentsDataFalse.forEach(function (item) {
      it('should be false', function () {
        service.reopen({
          hostComponents: item
        });
        expect(service.get('isRestartRequired')).to.be.false;
      });
    });
    hostComponentsDataTrue.forEach(function (item) {
      it('should be true', function () {
        service.reopen({
          hostComponents: item
        });
        expect(service.get('isRestartRequired')).to.be.true;
      });
    });
  });

  describe('#restartRequiredMessage', function () {
    it('should form message for 2 services on 1 host', function () {
      service.set('restartRequiredHostsAndComponents', restartData);
      expect(service.get('restartRequiredMessage')).to.contain('host0');
      expect(service.get('restartRequiredMessage')).to.contain('service0');
      expect(service.get('restartRequiredMessage')).to.contain('service1');
    });
  });

  describe('#serviceTypes', function () {
    var testCases = [
      {
        serviceName: 'PIG',
        result: []
      },
      {
        serviceName: 'GANGLIA',
        result: ['MONITORING']
      },
      {
        serviceName: 'NAGIOS',
        result: ['MONITORING']
      },
      {
        serviceName: 'HDFS',
        result: ['HA_MODE']
      },
      {
        serviceName: 'YARN',
        result: ['HA_MODE']
      }
    ];
    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        service.set('serviceName', test.serviceName);
        service.propertyDidChange('serviceTypes');
        expect(service.get('serviceTypes')).to.eql(test.result);
      });
    });
  });


});

});

;require.register("test/models/stack_service_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/stack_service_component');

/**

  Component properties template:

  {
    componentName: 'SUPERVISOR',
    expected: {
      displayName: 'Supervisor',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isClient: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      defaultNoOfMasterHosts: 1,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false,
      selectionSchemeForMasterComponent: {"else": 0}
    }
  }

**/
var componentPropertiesValidationTests = [
  {
    componentName: 'SUPERVISOR',
    expected: {
      displayName: 'Supervisor',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerSlaveClientPage: true,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'ZOOKEEPER_SERVER',
    expected: {
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isMaster: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: true,
      isMasterAddableInstallerWizard: true,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      defaultNoOfMasterHosts: 3,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'APP_TIMELINE_SERVER',
    expected: {
      displayName: 'App Timeline Server',
      minToInstall: 0,
      maxToInstall: 1,
      isRequired: false,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: false,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: false,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'GANGLIA_MONITOR',
    expected: {
      displayName: 'Ganglia Monitor',
      minToInstall: Infinity,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: true,
      isNotPreferableOnAmbariServerHost: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'FLUME_HANDLER',
    expected: {
      displayName: 'Flume',
      minToInstall: 0,
      maxToInstall: Infinity,
      isRequired: false,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: true,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'HIVE_METASTORE',
    expected: {
      displayName: 'Hive Metastore',
      minToInstall: 1,
      maxToInstall: 1,
      isRequired: true,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: false,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: false,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: true
    }
  },
  {
    componentName: 'HIVE_SERVER',
    expected: {
      displayName: 'HiveServer2',
      minToInstall: 1,
      maxToInstall: 1,
      isRequired: true,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: false,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: false,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      coHostedComponents: ['HIVE_METASTORE','WEBHCAT_SERVER'],
      isOtherComponentCoHosted: true,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'DATANODE',
    expected: {
      displayName: 'DataNode',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isNotPreferableOnAmbariServerHost: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'POSTGRESQL_SERVER',
    expected: {
      isShownOnInstallerAssignMasterPage: false,
    }
  },
  {
    componentName: 'MYSQL_SERVER',
    expected: {
      isShownOnInstallerAssignMasterPage: false,
    }
  },
];

describe('App.StackServiceComponent', function() {
  before(function() {
    modelSetup.setupStackServiceComponent();
  });

  describe('component properties validation', function() {
    componentPropertiesValidationTests.forEach(function(test) {
      describe('properties validation for ' + test.componentName + ' component', function() {
        var component = App.StackServiceComponent.find(test.componentName);
        var properties = Em.keys(test.expected);
        properties.forEach(function(property) {
          it('#{0} should be {1}'.format(property, JSON.stringify(test.expected[property])), function() {
            expect(component.get(property)).to.be.eql(test.expected[property]);
          })
        });
      });
    });
  });

  after(function() {
    modelSetup.cleanStackServiceComponent();
  });
});

});

;require.register("test/models/stack_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/stack_service');

describe('App.StackService', function () {

  App.store.load(App.StackService, {
    id: 'S1'
  });

  var ss = App.StackService.find('S1');
  ss.reopen({
    serviceComponents: []
  });

  describe('#isDFS', function () {
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.false;
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.true;
    });
    it('service name is "GLUSTERFS"', function () {
      ss.set('serviceName', 'GLUSTERFS');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.true;
    });
  });

  describe('#isPrimaryDFS', function () {
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('isPrimaryDFS');
      expect(ss.get('isPrimaryDFS')).to.be.false;
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('isPrimaryDFS');
      expect(ss.get('isPrimaryDFS')).to.be.true;
    });
  });

  describe('#configTypesRendered', function () {
    ss.set('configTypes', {
      'core-site': {},
      'hdfs-site': {},
      'oozie-site': {}
    });
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {},'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "GLUSTERFS"', function () {
      ss.set('serviceName', 'GLUSTERFS');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {},'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {}, 'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "FALCON"', function () {
      ss.set('serviceName', 'FALCON');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {}, 'hdfs-site': {}});
    });
  });

  describe('#displayNameOnSelectServicePage', function () {
    it('No coSelectedServices', function () {
      ss.set('serviceName', 'HDFS');
      ss.set('displayName', 'HDFS');
      ss.propertyDidChange('displayNameOnSelectServicePage');
      expect(ss.get('displayNameOnSelectServicePage')).to.equal('HDFS');
    });
    it('Present coSelectedServices', function () {
      ss.set('serviceName', 'YARN');
      ss.set('displayName', 'YARN');
      ss.propertyDidChange('displayNameOnSelectServicePage');
      expect(ss.get('displayNameOnSelectServicePage')).to.equal('YARN + MapReduce2');
    });
  });

  describe('#isHiddenOnSelectServicePage', function () {
    var testCases = [
      {
        serviceName: 'HDFS',
        result: false
      },
      {
        serviceName: 'MAPREDUCE2',
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        ss.set('serviceName', test.serviceName);
        ss.propertyDidChange('isHiddenOnSelectServicePage');
        expect(ss.get('isHiddenOnSelectServicePage')).to.equal(test.result);
      });
    });
  });

  describe('#isMonitoringService', function () {
    var testCases = [
      {
        serviceName: 'HDFS',
        result: false
      },
      {
        serviceName: 'NAGIOS',
        result: true
      },
      {
        serviceName: 'GANGLIA',
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        ss.set('serviceName', test.serviceName);
        ss.propertyDidChange('isMonitoringService');
        expect(ss.get('isMonitoringService')).to.equal(test.result);
      });
    });
  });

  describe('#hasClient', function () {
    it('No client serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasClient');
      expect(ss.get('hasClient')).to.be.false;
    });
    it('Has client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isClient: true})]);
      ss.propertyDidChange('hasClient');
      expect(ss.get('hasClient')).to.be.true;
    });
  });

  describe('#hasMaster', function () {
    it('No master serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasMaster');
      expect(ss.get('hasMaster')).to.be.false;
    });
    it('Has master serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isMaster: true})]);
      ss.propertyDidChange('hasMaster');
      expect(ss.get('hasMaster')).to.be.true;
    });
  });

  describe('#hasSlave', function () {
    it('No slave serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasSlave');
      expect(ss.get('hasSlave')).to.be.false;
    });
    it('Has slave serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true})]);
      ss.propertyDidChange('hasSlave');
      expect(ss.get('hasSlave')).to.be.true;
    });
  });

  describe('#isClientOnlyService', function () {
    it('Has not only client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true}), Em.Object.create({isClient: true})]);
      ss.propertyDidChange('isClientOnlyService');
      expect(ss.get('isClientOnlyService')).to.be.false;
    });
    it('Has only client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isClient: true})]);
      ss.propertyDidChange('isClientOnlyService');
      expect(ss.get('isClientOnlyService')).to.be.true;
    });
  });

  describe('#isNoConfigTypes', function () {
    it('configTypes is null', function () {
      ss.set('configTypes', null);
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.true;
    });
    it('configTypes is empty', function () {
      ss.set('configTypes', {});
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.true;
    });
    it('configTypes is correct', function () {
      ss.set('configTypes', {'key': {}});
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.false;
    });
  });

  describe('#customReviewHandler', function () {
    it('service name is HDFS', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('customReviewHandler');
      expect(ss.get('customReviewHandler')).to.be.undefined;
    });
    it('service name is HIVE', function () {
      ss.set('serviceName', 'HIVE');
      ss.propertyDidChange('customReviewHandler');
      expect(ss.get('customReviewHandler')).to.eql({
        "Database": "loadHiveDbValue"
      });
    });
  });

  describe('#defaultsProviders', function () {
    it('service name is HDFS', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('defaultsProviders');
      expect(ss.get('defaultsProviders')).to.be.undefined;
    });
    it('service name is HIVE', function () {
      ss.set('serviceName', 'HIVE');
      ss.propertyDidChange('defaultsProviders');
      expect(ss.get('defaultsProviders')).to.not.be.empty;
    });
  });

  describe('#configsValidator', function () {
    it('service name is HDFS', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configsValidator');
      expect(ss.get('configsValidator')).to.be.undefined;
    });
    it('service name is HIVE', function () {
      ss.set('serviceName', 'HIVE');
      ss.propertyDidChange('configsValidator');
      expect(ss.get('configsValidator')).to.not.be.empty;
    });
  });

  describe('#configCategories', function () {
    it('HDFS service with no serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "General",
        "Advanced",
        "Advanced key",
        "Custom key"
      ]);
    });
    it('HDFS service with DATANODE serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({componentName: 'DATANODE'})]);
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "DATANODE",
        "General",
        "Advanced",
        "Advanced key",
        "Custom key"]);
    });
  });


});

});

;require.register("test/models/user_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/user');

var user,
  form,
  userNameField,
  userData = {
    id: 'user'
  },
  objectData = Em.Object.create({
    userName: 'name',
    isLdap: true
  });

describe('App.User', function () {

  beforeEach(function () {
    user = App.User.createRecord(userData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(user);
  });

  describe('#id', function () {
    it('should take value from userName', function () {
      user.set('userName', 'name');
      expect(user.get('id')).to.equal('name');
    });
  });

  describe('#type', function () {
    it('should be LDAP', function () {
      user.set('isLdap', true);
      expect(user.get('type')).to.equal('LDAP');
    });
    it('should be Local', function () {
      user.set('isLdap', false);
      expect(user.get('type')).to.equal('Local');
    });
  });

});

describe('App.EditUserForm', function () {

  beforeEach(function () {
    form = App.EditUserForm.create();
  });

  describe('#object', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return userData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should take data from controller', function () {
      expect(form.get('object')).to.eql(userData);
    });

  });

  describe('#disableUsername', function () {
    it('should update userName field', function () {
      form.set('object', userData);
      expect(form.get('field.userName.disabled')).to.equal('disabled');
    });
  });

  describe('#disableAdminCheckbox', function () {

    before(function () {
      sinon.stub(App, 'get', function(k) {
        switch (k) {
          case 'router':
            return {
              getLoginName: Em.K
            };
          case 'supports.ldapGroupMapping':
            return true;
          default:
            return Em.get(App, k);
        }
      });
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return objectData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.get.restore();
      App.router.get.restore();
    });

    it('should not disable', function () {
      expect(form.get('field.admin.disabled')).to.be.false;
    });

    it('should disable', function () {
      form.set('object', objectData);
      expect(form.get('field.admin.disabled')).to.be.true;
    });

  });

  describe('#isValid', function () {
    it('should be true as default', function () {
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      form.set('field.new_password.isRequired', true);
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#save', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return objectData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should record form values to object', function () {
      form.set('field.userName.value', 'name');
      form.save();
      expect(form.get('object.userName')).to.equal('name');
    });
  });

});

describe('App.CreateUserForm', function () {

  beforeEach(function () {
    form = App.CreateUserForm.create();
  });

  describe('#object', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserCreateController.content') return userData;
        return Em.get(App, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should take data from controller', function () {
      expect(form.get('object')).to.eql(userData);
    });

  });

  describe('#field.userName.toLowerCase', function () {
    it('should convert userName into lower case', function () {
      userNameField = form.getField('userName');
      userNameField.set('value', 'NAME');
      expect(userNameField.get('value')).to.equal('name');
    });
  });

  describe('#isValid', function () {
    it('should be false as default', function () {
      expect(form.isValid()).to.be.false;
    });
    it('should be true', function () {
      form.get('fields').forEach(function (item) {
        if (item.get('isRequired')) {
          item.set('value', 'value');
        }
      });
      expect(form.isValid()).to.be.true;
    });
  });

  describe('#isWarn', function () {
    it('should be false as default', function () {
      expect(form.isWarn()).to.be.false;
    });
    it('should be true', function () {
      form.getField('userName').set('value', '1');
      expect(form.isWarn()).to.be.true;
    });
    it('should be false', function () {
      form.getField('userName').set('value', 'name');
      expect(form.isWarn()).to.be.false;
    });
  });

});

});

;require.register("test/router_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('router');

describe('App.Router', function () {
  var router = App.Router.create();

  describe('#loginSuccessCallback()', function() {
    it('should log in user and load views', function () {
      var mainViewsControllerMock = Em.Object.create({
        loadAmbariViews: sinon.stub()
      });
      var userName = 'test';
      sinon.stub(App.usersMapper, 'map');
      sinon.stub(router, 'setUserLoggedIn');
      sinon.stub(App.router, 'get').withArgs('mainViewsController').returns(mainViewsControllerMock);
      sinon.stub(App.ajax, 'send');

      router.loginSuccessCallback({},{},{loginName: userName});

      expect(mainViewsControllerMock.loadAmbariViews.calledOnce).to.be.true;
      expect(router.setUserLoggedIn.calledOnce).to.be.true;
      expect(router.setUserLoggedIn.calledWith(userName)).to.be.true;

      App.usersMapper.map.restore();
      router.setUserLoggedIn.restore();
      App.router.get.restore();
      App.ajax.send.restore();
    })
  });

});

});

;require.register("test/service_components", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  "items" : [
    {
      "StackServices" : {
        "comments" : "Apache Hadoop Distributed Processing Framework",
        "service_name" : "MAPREDUCE",
        "display_name" : "MapReduce",
        "service_version" : "1.2.0.1.3.3.0",
        "stack_name" : "HDP",
        "stack_version" : "1.3.2",
        "required_services" : [
          "YARN"
        ]
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "HISTORYSERVER",
            "display_name" : "History Server",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          },
          "dependencies": []
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "JOBTRACKER",
            "display_name" : "JobTracker",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          },
          "dependencies": []
        },
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "MAPREDUCE_CLIENT",
            "display_name" : "MapReduce Client",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          },
          "dependencies": []
        },
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "TASKTRACKER",
            "display_name" : "TaskTracker",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          },
          "dependencies": []
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FALCON",
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "FALCON",
        "display_name" : "Falcon",
        "service_version" : "0.5.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "config_types" : {
          "falcon-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "falcon-runtime.properties" : {
            "supports" : {
              "final" : "false"
            }
          },
          "falcon-startup.properties" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        },
        "required_services" : [
          "OOZIE"
        ]
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FALCON/serviceComponents/FALCON_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "FALCON_CLIENT",
            "display_name" : "Falcon Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FALCON/serviceComponents/FALCON_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "FALCON_SERVER",
            "display_name" : "Falcon Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FALCON/serviceComponents/FALCON_SERVER/dependencies/OOZIE_CLIENT",
              "Dependencies" : {
                "component_name" : "OOZIE_CLIENT",
                "dependent_component_name" : "FALCON_SERVER",
                "dependent_service_name" : "FALCON",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FALCON/serviceComponents/FALCON_SERVER/dependencies/OOZIE_SERVER",
              "Dependencies" : {
                "component_name" : "OOZIE_SERVER",
                "dependent_component_name" : "FALCON_SERVER",
                "dependent_service_name" : "FALCON",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FLUME",
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "FLUME",
        "display_name" : "Flume",
        "service_version" : "1.4.0.2.1.1.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "config_types" : {
          "flume-conf" : {
            "supports" : {
              "final" : "false"
            }
          },
          "flume-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "flume-log4j" : {
            "supports" : {
              "final" : "false"
            }
          }
        },
        "required_services" : [
          "HDFS"
        ]
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/FLUME/serviceComponents/FLUME_HANDLER",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "FLUME_HANDLER",
            "display_name" : "Flume",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "FLUME",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/GANGLIA",
      "StackServices" : {
        "comments" : "Ganglia Metrics Collection system (<a href=\"http://oss.oetiker.ch/rrdtool/\" target=\"_blank\">RRDTool</a> will be installed too)",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "GANGLIA",
        "display_name" : "Ganglia",
        "service_version" : "3.5.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : null,
        "config_types" : {
          "ganglia-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/GANGLIA/serviceComponents/GANGLIA_MONITOR",
          "StackServiceComponents" : {
            "cardinality" : "ALL",
            "component_category" : "SLAVE",
            "component_name" : "GANGLIA_MONITOR",
            "display_name" : "Ganglia Monitor",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/GANGLIA/serviceComponents/GANGLIA_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "GANGLIA_SERVER",
            "display_name" : "Ganglia Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HBASE",
      "StackServices" : {
        "comments" : "Non-relational distributed database and centralized service for configuration management &\n        synchronization\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HBASE",
        "display_name" : "HBase",
        "service_version" : "0.98.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER",
          "HDFS"
        ],
        "config_types" : {
          "hbase-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hbase-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hbase-policy" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hbase-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HBASE/serviceComponents/HBASE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HBASE_CLIENT",
            "display_name" : "HBase Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HBASE/serviceComponents/HBASE_MASTER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "MASTER",
            "component_name" : "HBASE_MASTER",
            "display_name" : "HBase Master",
            "custom_commands" : [
              "DECOMMISSION"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HBASE/serviceComponents/HBASE_MASTER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "HBASE_MASTER",
                "dependent_service_name" : "HBASE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HBASE/serviceComponents/HBASE_MASTER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "HBASE_MASTER",
                "dependent_service_name" : "HBASE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HBASE/serviceComponents/HBASE_REGIONSERVER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "HBASE_REGIONSERVER",
            "display_name" : "RegionServer",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS",
      "StackServices" : {
        "comments" : "Apache Hadoop Distributed File System",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HDFS",
        "display_name" : "HDFS",
        "service_version" : "2.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER"
        ],
        "config_types" : {
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hadoop-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hadoop-policy" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hdfs-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hdfs-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS/serviceComponents/DATANODE",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "DATANODE",
            "display_name" : "DataNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS/serviceComponents/HDFS_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HDFS_CLIENT",
            "display_name" : "HDFS Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS/serviceComponents/JOURNALNODE",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "JOURNALNODE",
            "display_name" : "JournalNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS/serviceComponents/NAMENODE",
          "StackServiceComponents" : {
            "cardinality" : "1-2",
            "component_category" : "MASTER",
            "component_name" : "NAMENODE",
            "display_name" : "NameNode",
            "custom_commands" : [
              "DECOMMISSION"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS/serviceComponents/SECONDARY_NAMENODE",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "SECONDARY_NAMENODE",
            "display_name" : "SNameNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HDFS/serviceComponents/ZKFC",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "ZKFC",
            "display_name" : "ZKFailoverController",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE",
      "StackServices" : {
        "comments" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HIVE",
        "display_name" : "Hive",
        "service_version" : "0.13.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER",
          "YARN"
        ],
        "config_types" : {
          "hive-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-exec-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "tez-site" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HIVE_CLIENT",
            "display_name" : "Hive Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_METASTORE",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HIVE_METASTORE",
            "display_name" : "Hive Metastore",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true,
            "location" : "HIVE/HIVE_SERVER"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HIVE_SERVER",
            "display_name" : "HiveServer2",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_SERVER/dependencies/TEZ_CLIENT",
              "Dependencies" : {
                "component_name" : "TEZ_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HIVE_SERVER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/WEBHCAT/serviceComponents/WEBHCAT_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "WEBHCAT_SERVER",
            "display_name" : "WebHCat Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/WEBHCAT_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/WEBHCAT_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/WEBHCAT/serviceComponents/WEBHCAT_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/WEBHCAT/serviceComponents/WEBHCAT_SERVER/dependencies/ZOOKEEPER_CLIENT",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/WEBHCAT/serviceComponents/WEBHCAT_SERVER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/MYSQL_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "0-1",
            "component_category" : "MASTER",
            "component_name" : "MYSQL_SERVER",
            "display_name" : "MySQL Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/HIVE/serviceComponents/HCAT",
          "StackServiceComponents" : {
            "cardinality" : null,
            "component_category" : "CLIENT",
            "component_name" : "HCAT",
            "display_name" : "HCat",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/MAPREDUCE2",
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "MAPREDUCE2",
        "display_name" : "MapReduce2",
        "service_version" : "2.1.0.2.0.6.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "mapred-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "mapred-queue-acls" : {
            "supports" : {
              "final" : "true"
            }
          },
          "mapred-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/MAPREDUCE2/serviceComponents/HISTORYSERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HISTORYSERVER",
            "display_name" : "History Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true,
            "location" : "YARN/RESOURCEMANAGER"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/MAPREDUCE2/serviceComponents/HISTORYSERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "HISTORYSERVER",
                "dependent_service_name" : "MAPREDUCE2",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/MAPREDUCE2/serviceComponents/MAPREDUCE2_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "CLIENT",
            "component_name" : "MAPREDUCE2_CLIENT",
            "display_name" : "MapReduce2 Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS",
      "StackServices" : {
        "comments" : "Nagios Monitoring and Alerting system",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "NAGIOS",
        "display_name" : "Nagios",
        "service_version" : "3.5.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [ ],
        "config_types" : {
          "nagios-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "NAGIOS_SERVER",
            "display_name" : "Nagios Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "NAGIOS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER/dependencies/HCAT",
              "Dependencies" : {
                "component_name" : "HCAT",
                "dependent_component_name" : "NAGIOS_SERVER",
                "dependent_service_name" : "NAGIOS",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "NAGIOS_SERVER",
                "dependent_service_name" : "NAGIOS",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "NAGIOS_SERVER",
                "dependent_service_name" : "NAGIOS",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER/dependencies/OOZIE_CLIENT",
              "Dependencies" : {
                "component_name" : "OOZIE_CLIENT",
                "dependent_component_name" : "NAGIOS_SERVER",
                "dependent_service_name" : "NAGIOS",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER/dependencies/TEZ_CLIENT",
              "Dependencies" : {
                "component_name" : "TEZ_CLIENT",
                "dependent_component_name" : "NAGIOS_SERVER",
                "dependent_service_name" : "NAGIOS",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/NAGIOS/serviceComponents/NAGIOS_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "NAGIOS_SERVER",
                "dependent_service_name" : "NAGIOS",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE",
      "StackServices" : {
        "comments" : "System for workflow coordination and execution of Apache Hadoop jobs.  This also includes the installation of the optional Oozie Web Console which relies on and will install the <a target=\"_blank\" href=\"http://www.sencha.com/legal/open-source-faq/\">ExtJS</a> Library.\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "OOZIE",
        "display_name" : "Oozie",
        "service_version" : "4.0.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "oozie-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "yarn-site" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "OOZIE_CLIENT",
            "display_name" : "Oozie Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_CLIENT/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "OOZIE_CLIENT",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_CLIENT/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "OOZIE_CLIENT",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "OOZIE_SERVER",
            "display_name" : "Oozie Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/OOZIE/serviceComponents/OOZIE_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/PIG",
      "StackServices" : {
        "comments" : "Scripting platform for analyzing large datasets",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "PIG",
        "display_name" : "Pig",
        "service_version" : "0.12.1.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "pig-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "pig-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "pig-properties" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/PIG/serviceComponents/PIG",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "CLIENT",
            "component_name" : "PIG",
            "display_name" : "Pig",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "PIG",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/SQOOP",
      "StackServices" : {
        "comments" : "Tool for transferring bulk data between Apache Hadoop and\n        structured data stores such as relational databases\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "SQOOP",
        "display_name" : "Sqoop",
        "service_version" : "1.4.4.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "HDFS"
        ],
        "config_types" : {
          "sqoop-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/SQOOP/serviceComponents/SQOOP",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "SQOOP",
            "display_name" : "Sqoop",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "SQOOP",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/SQOOP/serviceComponents/SQOOP/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "SQOOP",
                "dependent_service_name" : "SQOOP",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/SQOOP/serviceComponents/SQOOP/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "SQOOP",
                "dependent_service_name" : "SQOOP",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM",
      "StackServices" : {
        "comments" : "Apache Hadoop Stream processing framework",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "STORM",
        "display_name" : "Storm",
        "service_version" : "0.9.1.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER"
        ],
        "config_types" : {
          "storm-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "storm-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM/serviceComponents/DRPC_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "DRPC_SERVER",
            "display_name" : "DRPC Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM/serviceComponents/NIMBUS",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "NIMBUS",
            "display_name" : "Nimbus",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM/serviceComponents/NIMBUS/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "NIMBUS",
                "dependent_service_name" : "STORM",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM/serviceComponents/STORM_REST_API",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "STORM_REST_API",
            "display_name" : "Storm REST API Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM/serviceComponents/STORM_UI_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "STORM_UI_SERVER",
            "display_name" : "Storm UI Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/STORM/serviceComponents/SUPERVISOR",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "SUPERVISOR",
            "display_name" : "Supervisor",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/TEZ",
      "StackServices" : {
        "comments" : "Tez is the next generation Hadoop Query Processing framework written on top of YARN.",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "TEZ",
        "display_name" : "Tez",
        "service_version" : "0.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "tez-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "tez-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/TEZ/serviceComponents/TEZ_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "TEZ_CLIENT",
            "display_name" : "Tez Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "TEZ",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/YARN",
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "YARN",
        "display_name" : "YARN",
        "service_version" : "2.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "HDFS",
          "TEZ"
        ],
        "config_types" : {
          "capacity-scheduler" : {
            "supports" : {
              "final" : "true"
            }
          },
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "yarn-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "yarn-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "yarn-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/YARN/serviceComponents/APP_TIMELINE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "0-1",
            "component_category" : "MASTER",
            "component_name" : "APP_TIMELINE_SERVER",
            "display_name" : "App Timeline Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/YARN/serviceComponents/NODEMANAGER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "NODEMANAGER",
            "display_name" : "NodeManager",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/YARN/serviceComponents/RESOURCEMANAGER",
          "StackServiceComponents" : {
            "cardinality" : "1-2",
            "component_category" : "MASTER",
            "component_name" : "RESOURCEMANAGER",
            "display_name" : "ResourceManager",
            "custom_commands" : [
              "DECOMMISSION",
              "REFRESHQUEUES"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/YARN/serviceComponents/YARN_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "YARN_CLIENT",
            "display_name" : "YARN Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/ZOOKEEPER",
      "StackServices" : {
        "comments" : "Centralized service which provides highly reliable distributed\n        coordination.",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "ZOOKEEPER",
        "display_name" : "ZooKeeper",
        "service_version" : "3.4.5.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [ ],
        "config_types" : {
          "zoo.cfg" : {
            "supports" : {
              "final" : "false"
            }
          },
          "zookeeper-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "zookeeper-log4j" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "serviceComponents" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/ZOOKEEPER/serviceComponents/ZOOKEEPER_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "ZOOKEEPER_CLIENT",
            "display_name" : "ZooKeeper Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks2/HDP/versions/2.1/stackServices/ZOOKEEPER/serviceComponents/ZOOKEEPER_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "MASTER",
            "component_name" : "ZOOKEEPER_SERVER",
            "display_name" : "ZooKeeper Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ]
    }
  ]
};

});

;require.register("test/stack", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


module.exports = {
  "items": [
    {
      "Versions": {
        "active": true,
        "min_upgrade_version": null,
        "parent_stack_version": "1.3.3",
        "stack_name": "HDP",
        "stack_version": "1.3"
      },
      "operatingSystems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "1.3"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.8.0",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-1.3",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "1.3"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.16",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "1.3"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "1.3"
          }, "repositories": [
          {
            "Repositories": {
              "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
              "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
              "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.8.0",
              "mirrors_list": null,
              "os_type": "redhat6",
              "repo_id": "HDP-1.3",
              "repo_name": "HDP",
              "stack_name": "HDP",
              "stack_version": "1.3"
            }
          },
          {
            "Repositories": {
              "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "mirrors_list": null,
              "os_type": "redhat6",
              "repo_id": "HDP-UTILS-1.1.0.16",
              "repo_name": "HDP-UTILS",
              "stack_name": "HDP",
              "stack_version": "1.3"
            }
          }
        ]
        }
      ]
    },
    {
      "Versions": {
        "active": false,
        "min_upgrade_version": null,
        "parent_stack_version": null,
        "stack_name": "HDP",
        "stack_version": "2.0.6"
      },
      "operatingSystems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "2.0.6"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-2.0.6",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "2.0.6"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-2.0.6",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            }
          ]
        }
      ]
    },
    {
      "Versions": {
        "active": true,
        "min_upgrade_version": null,
        "parent_stack_version": null,
        "stack_name": "HDP",
        "stack_version": "2.1"
      },
      "operatingSystems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "2.1"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-2.1",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "2.1"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-2.1",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        }
      ]
    }
  ]
};

});

;require.register("test/utils/ajax/ajax_queue_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var ajaxQueue;

describe('App.ajaxQueue', function () {

  beforeEach(function() {
    ajaxQueue = App.ajaxQueue.create();
    sinon.spy(ajaxQueue, 'runNextRequest');
    sinon.spy(ajaxQueue, 'finishedCallback');
    sinon.spy(App.ajax, 'send');
  });

  afterEach(function() {
    ajaxQueue.clear();
    ajaxQueue.runNextRequest.restore();
    ajaxQueue.finishedCallback.restore();
    App.ajax.send.restore();
  });

  describe('#clear', function() {
    it('should clear queue', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      ajaxQueue.clear();
      expect(ajaxQueue.get('queue.length')).to.equal(0);
    });
  });

  describe('#addRequest', function() {
    it('should add request', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      expect(ajaxQueue.get('queue.length')).to.equal(1);
    });
    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'', sender: Em.Object.create()})}).to.throw(Error);
    });
    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'some', sender: {}})}).to.throw(Error);
    });
  });

  describe('#addRequests', function() {
    it('should add requests', function() {
      ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: Em.Object.create()}
      ]));
      expect(ajaxQueue.get('queue.length')).to.equal(2);
    });

    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'', sender: Em.Object.create()}
      ]));}).to.throw(Error);
    });

    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: {}}
      ]));}).to.throw(Error);
    });

  });

  describe('#start', function() {
    it('should call runNextRequest', function() {
      ajaxQueue.start();
      expect(ajaxQueue.runNextRequest.called).to.equal(true);
    });
  });

  describe('#runNextRequest', function() {
    it('for empty queue App.ajax.send shouldn\'t be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('when queue is empty finishedCallback should be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(ajaxQueue.finishedCallback.called).to.equal(true);
    });
    it('if abortOnError is false queue shouldn\'t be interrupted', function() {
      ajaxQueue.clear();
      ajaxQueue.set('abortOnError', false);
      ajaxQueue.addRequest({name:'some_fake', sender: Em.Object.create()}).addRequest({name: 'some_fake2', sender: Em.Object.create()}).start();
      expect(ajaxQueue.runNextRequest.callCount).to.equal(3); // One for empty-queue
    });
  });

});

});

;require.register("test/utils/ajax/ajax_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/ajax/ajax');

describe('App.ajax', function() {

  beforeEach(function() {
    App.set('apiPrefix', '/api/v1');
    App.set('clusterName', 'tdk');
  });

  describe('#send', function() {
    beforeEach(function() {
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
    });
    it('Without sender', function() {
      expect(App.ajax.send({})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('Invalid config.name', function() {
      expect(App.ajax.send({name:'fake_name', sender: this})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('With proper data', function() {
      App.ajax.send({name: 'router.logoff', sender: this});
      expect($.ajax.calledOnce).to.equal(true);
    });

  });

  describe('#formatUrl', function() {

    var tests = [
      {
        url: null,
        data: {},
        e: null,
        m: 'url is null'
      },
      {
        url: 'site/{param}',
        data: null,
        e: 'site/',
        m: 'url with one param, but data is null'
      },
      {
        url: 'clean_url',
        data: {},
        e: 'clean_url',
        m: 'url without placeholders'
      },
      {
        url: 'site/{param}',
        data: {},
        e: 'site/',
        m: 'url with param, but there is no such param in the data'
      },
      {
        url: 'site/{param}/{param}',
        data: {param: 123},
        e: 'site/123/123',
        m: 'url with param which appears two times'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = App.ajax.fakeFormatUrl(test.url, test.data);
        expect(r).to.equal(test.e);
      });
    });
  });

  describe('Check "real" property for each url object', function() {
    var names = App.ajax.fakeGetUrlNames();
    names.forEach(function(name) {
      it(name, function() {
        var url = App.ajax.fakeGetUrl(name);
        expect(url.real).to.be.a('string');
      });
    });
  });

  describe('#formatRequest', function() {

    it('App.testMode = true', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      var r = App.ajax.fakeFormatRequest({real:'/', mock: '/some_url'}, {});
      expect(r.type).to.equal('GET');
      expect(r.url).to.equal('/some_url');
      expect(r.dataType).to.equal('json');
      App.get.restore();
    });
    var tests = [
      {
        urlObj: {
          real: '/real_url',
          format: function() {
            return {
              type: 'PUT'
            }
          }
        },
        data: {},
        m: '',
        e: {type: 'PUT', url: '/api/v1/real_url'}
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.stub(App, 'get', function(k) {
          if ('testMode' === k) return false;
          return Em.get(App, k);
        });
        var r = App.ajax.fakeFormatRequest(test.urlObj, test.data);
        expect(r.type).to.equal(test.e.type);
        expect(r.url).to.equal(test.e.url);
        App.get.restore();
      });
    });
  });

});

});

;require.register("test/utils/batch_scheduled_requests_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/helper');
require('views/common/rolling_restart_view');
var batchUtils = require('utils/batch_scheduled_requests');
var modelSetup = require('test/init_model_test');
describe('batch_scheduled_requests', function() {

  beforeEach(function(){
    modelSetup.setupStackServiceComponent();
  });
  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#getRollingRestartComponentName', function() {
    var tests = [
      {serviceName: 'HDFS', componentName: 'DATANODE'},
      {serviceName: 'YARN', componentName: 'NODEMANAGER'},
      {serviceName: 'MAPREDUCE', componentName: 'TASKTRACKER'},
      {serviceName: 'HBASE', componentName: 'HBASE_REGIONSERVER'},
      {serviceName: 'STORM', componentName: 'SUPERVISOR'},
      {serviceName: 'SOME_INVALID_SERVICE', componentName: null}
    ];

    tests.forEach(function(test) {
      it(test.serviceName + ' - ' + test.componentName, function() {
        expect(batchUtils.getRollingRestartComponentName(test.serviceName)).to.equal(test.componentName);
      });
    });

  });

  describe('#getBatchesForRollingRestartRequest', function() {
    var tests = [
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 2,
        m: 'DATANODES on three hosts, batchSize = 2',
        e: {
          batchCount: 2
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 3,
        m: 'DATANODES on 3 hosts, batchSize = 3',
        e: {
          batchCount: 1
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 1,
        m: 'DATANODES on 3 hosts, batchSize = 1',
        e: {
          batchCount: 3
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(batchUtils.getBatchesForRollingRestartRequest(test.hostComponents, test.batchSize).length).to.equal(test.e.batchCount);
      });
    });
  });

  describe('#launchHostComponentRollingRestart', function() {

    beforeEach(function() {
      sinon.spy(batchUtils, 'showRollingRestartPopup');
      sinon.spy(batchUtils, 'showWarningRollingRestartPopup');
      sinon.stub(App, 'get', function(k) {
        if ('components.rollinRestartAllowed' === k)
          return ['DATANODE', 'TASKTRACKER', 'NODEMANAGER', 'HBASE_REGIONSERVER', 'SUPERVISOR'];
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      batchUtils.showRollingRestartPopup.restore();
      batchUtils.showWarningRollingRestartPopup.restore();
      App.get.restore();
    });

    var tests = Em.A([
      {componentName: 'DATANODE', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'TASKTRACKER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'NODEMANAGER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'HBASE_REGIONSERVER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SUPERVISOR', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SOME_OTHER_COMPONENT', e:{showRollingRestartPopup:false, showWarningRollingRestartPopup:true}}
    ]);

    tests.forEach(function(test) {
      it(test.componentName, function() {
        batchUtils.launchHostComponentRollingRestart(test.componentName);
        expect(batchUtils.showRollingRestartPopup.calledOnce).to.equal(test.e.showRollingRestartPopup);
        expect(batchUtils.showWarningRollingRestartPopup.calledOnce).to.equal(test.e.showWarningRollingRestartPopup);
      });
    });

  });

  describe('#restartHostComponents', function() {

    beforeEach(function() {
      sinon.spy($, 'ajax');
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    var tests = Em.A([
      {
        hostComponentList: Em.A([
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h1'
          }),
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h2'
          })
        ]),
        e: {
          ajaxCalledOnce: true,
          resource_filters: [{"service_name": "HDFS", "component_name":"NAMENODE","hosts":"h1,h2"}]
        },
        m: '1 component on 2 hosts'
      },
      {
        hostComponentList: Em.A([
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h1'
          }),
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h2'
          }),
          Em.Object.create({
            componentName: 'HBASE_MASTER',
            hostName: 'h2'
          })
        ]),
        e: {
          ajaxCalledOnce: true,
          resource_filters: [{"service_name": "HDFS", "component_name":"NAMENODE","hosts":"h1,h2"},{"service_name": "HBASE", "component_name":"HBASE_MASTER","hosts":"h2"}]
        },
        m: '1 component on 2 hosts, 1 on 1 host'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        batchUtils.restartHostComponents(test.hostComponentList);
        expect($.ajax.calledOnce).to.equal(test.e.ajaxCalledOnce);
        expect( JSON.parse($.ajax.args[0][0].data)['Requests/resource_filters']).to.eql(test.e.resource_filters);
      });
    });

    it('Empty data', function() {
      batchUtils.restartHostComponents([]);
      expect($.ajax.called).to.equal(false);
    });

  });

});

});

;require.register("test/utils/blueprint_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var blueprintUtils = require('utils/blueprint');

describe('utils/blueprint', function() {
  var masterBlueprint = {
    blueprint: {
      host_groups: [
        {
          name: "host-group-1",
          components: [
            { name: "ZOOKEEPER_SERVER" },
            { name: "NAMENODE" },
            { name: "HBASE_MASTER" }
          ]
        },
        {
          name: "host-group-2",
          components: [
            { name: "SECONDARY_NAMENODE" }
          ]
        }
      ]
    },
    blueprint_cluster_binding: {
      host_groups: [
        {
          name: "host-group-1",
          hosts: [
            { fqdn: "host1" },
            { fqdn: "host2" }
          ]
        },
        {
          name: "host-group-2",
          hosts: [
            { fqdn: "host3" }
          ]
        }
      ]
    }
  };

  var slaveBlueprint = {
    blueprint: {
      host_groups: [
        {
          name: "host-group-1",
          components: [
            { name: "DATANODE" }
          ]
        },
        {
          name: "host-group-2",
          components: [
            { name: "DATANODE" },
            { name: "HDFS_CLIENT" },
            { name: "ZOOKEEPER_CLIENT" }
          ]
        }
      ]
    },
    blueprint_cluster_binding: {
      host_groups: [
        {
          name: "host-group-1",
          hosts: [
            { fqdn: "host3" }
          ]
        },
        {
          name: "host-group-2",
          hosts: [
            { fqdn: "host4" },
            { fqdn: "host5" }
          ]
        }
      ]
    }
  };

  describe('#getHostsFromBlueprint', function() {
    it('should extract all hosts from blueprint', function() {
      expect(blueprintUtils.getHostsFromBlueprint(masterBlueprint)).to.deep.equal(["host1", "host2", "host3"]);
    });
  });

  describe('#getHostsFromBlueprintByGroupName', function() {
    it('should extract hosts from blueprint by given group name', function() {
      expect(blueprintUtils.getHostsFromBlueprintByGroupName(masterBlueprint, "host-group-1")).to.deep.equal([
        { fqdn: "host1" },
        { fqdn: "host2" }
      ]);
    });

    it('should return empty array if group with given name doesn\'t exist', function() {
      expect(blueprintUtils.getHostsFromBlueprintByGroupName(masterBlueprint, "not an existing group")).to.deep.equal([]);
    });
  });

  describe('#getComponentsFromBlueprintByGroupName', function() {
    it('should extract all components from blueprint for given host', function() {
      expect(blueprintUtils.getComponentsFromBlueprintByGroupName(masterBlueprint, "host-group-1")).to.deep.equal([
        { name: "ZOOKEEPER_SERVER" },
        { name: "NAMENODE" },
        { name: "HBASE_MASTER" }
      ]);
    });

    it('should return empty array if group doesn\'t exists', function() {
      expect(blueprintUtils.getComponentsFromBlueprintByGroupName(masterBlueprint, "not an existing group")).to.deep.equal([]);
    });

    it('should return empty array if group name isn\'t valid', function() {
      expect(blueprintUtils.getComponentsFromBlueprintByGroupName(masterBlueprint, undefined)).to.deep.equal([]);
    });
  });

  describe('#matchGroups', function() {
    it('should compose same host group into pairs', function() {
      expect(blueprintUtils.matchGroups(masterBlueprint, slaveBlueprint)).to.deep.equal([
        { g1: "host-group-1" },
        { g1: "host-group-2", g2: "host-group-1" },
        { g2: "host-group-2" }
      ]);
    });
  });

  describe('#filterByComponents', function() {
    it('should remove all components except', function() {
      expect(blueprintUtils.filterByComponents(masterBlueprint, ["NAMENODE"])).to.deep.equal({
        blueprint: {
          host_groups: [
            {
              name: "host-group-1",
              components: [
                { name: "NAMENODE" }
              ]
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              name: "host-group-1",
              hosts: [
                { fqdn: "host1" },
                { fqdn: "host2" }
              ]
            }
          ]
        }
      });
    });
  });

  describe('#addComponentsToBlueprint', function() {
    it('should add components to blueprint', function() {
      var components = ["FLUME_HANDLER", "HCAT"];
      expect(blueprintUtils.addComponentsToBlueprint(masterBlueprint, components)).to.deep.equal({
        blueprint: {
          host_groups: [
            {
              name: "host-group-1",
              components: [
                { name: "ZOOKEEPER_SERVER" },
                { name: "NAMENODE" },
                { name: "HBASE_MASTER" },
                { name: "FLUME_HANDLER" },
                { name: "HCAT" }
              ]
            },
            {
              name: "host-group-2",
              components: [
                { name: "SECONDARY_NAMENODE" },
                { name: "FLUME_HANDLER" },
                { name: "HCAT" }
              ]
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              name: "host-group-1",
              hosts: [
                { fqdn: "host1" },
                { fqdn: "host2" }
              ]
            },
            {
              name: "host-group-2",
              hosts: [
                { fqdn: "host3" }
              ]
            }
          ]
        }
      });
    });
  });

  describe('#mergeBlueprints', function() {
    it('should merge components', function() {
      expect(blueprintUtils.mergeBlueprints(masterBlueprint, slaveBlueprint)).to.deep.equal(
        {
          blueprint: {
            host_groups: [
              {
                name: "host-group-1",
                components: [
                  { name: "ZOOKEEPER_SERVER" },
                  { name: "NAMENODE" },
                  { name: "HBASE_MASTER" }
                ]
              },
              {
                name: "host-group-2",
                components: [
                  { name: "SECONDARY_NAMENODE" },
                  { name: "DATANODE" }
                ]
              },
              {
                name: "host-group-3",
                components: [
                  { name: "DATANODE" },
                  { name: "HDFS_CLIENT" },
                  { name: "ZOOKEEPER_CLIENT" }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: "host-group-1",
                hosts: [
                  { fqdn: "host1" },
                  { fqdn: "host2" }
                ]
              },
              {
                name: "host-group-2",
                hosts: [
                  { fqdn: "host3" }
                ]
              },
              {
                name: "host-group-3",
                hosts: [
                  { fqdn: "host4" },
                  { fqdn: "host5" }
                ]
              }
            ]
          }
        }
      );
    });
  });

  describe('#buildConfisJSON', function () {
    var tests = [
      {
        "services": [
          Em.Object.create({
            serviceName: "YARN",
            configTypes: {
              "yarn-site": {},
              "yarn-env": {}
            },
            isInstalled: true
          })
        ],
        "stepConfigs": [
          Em.Object.create({
            serviceName: "YARN",
            configs: [
              Em.Object.create({
                name: "p1",
                value: "v1",
                filename: "yarn-site.xml"
              }),
              Em.Object.create({
                name: "p2",
                value: "v2",
                filename: "yarn-site.xml"
              }),
              Em.Object.create({
                name: "p3",
                value: "v3",
                filename: "yarn-env.xml"
              })
            ]
          })
        ],
        "configurations": {
          "yarn-site": {
            "properties": {
              "p1": "v1",
              "p2": "v2"
            }
          },
          "yarn-env": {
            "properties": {
              "p3": "v3"
            }
          }
        }
      }
    ];
    tests.forEach(function (test) {
      it("generate configs for request (use in validation)", function () {
        expect(blueprintUtils.buildConfisJSON(test.services, test.stepConfigs)).to.eql(test.configurations);
      });
    });
  });

  describe('#generateHostGroups', function () {
    var tests = [
      {
        "hostNames": ["host1", "host2"],
        "hostComponents": [
          Em.Object.create({
            componentName: "C1",
            hostName: "host1"
          }),
          Em.Object.create({
            componentName: "C2",
            hostName: "host1"
          }),
          Em.Object.create({
            componentName: "C1",
            hostName: "host2"
          }),
          Em.Object.create({
            componentName: "C3",
            hostName: "host2"
          })
        ],
        result: {
          blueprint: {
            host_groups: [
              {
                name: "host-group-1",
                "components": [
                  {
                    "name": "C1"
                  },
                  {
                    "name": "C2"
                  }
                ]
              },
              {
                name: "host-group-2",
                "components": [
                  {
                    "name": "C1"
                  },
                  {
                    "name": "C3"
                  }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                "name": "host-group-1",
                "hosts": [
                  {
                    "fqdn": "host1"
                  }
                ]
              },
              {
                "name": "host-group-2",
                "hosts": [
                  {
                    "fqdn": "host2"
                  }
                ]
              }
            ]
          }
        }
      }
    ];
    tests.forEach(function (test) {
      it("generate host groups", function () {
        expect(blueprintUtils.generateHostGroups(test.hostNames, test.hostComponents)).to.eql(test.result);
      });
    });
  });
});
});

;require.register("test/utils/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('config');
require('utils/config');
require('models/service/hdfs');
var setups = require('test/init_model_test');
var modelSetup = setups.configs;

describe('App.config', function () {

  App.supports.capacitySchedulerUi = true;

  var loadServiceSpecificConfigs = function(context, serviceName) {
    context.configGroups = modelSetup.setupConfigGroupsObject(serviceName);
    context.advancedConfigs = modelSetup.setupAdvancedConfigsObject();
    context.tags = modelSetup.setupServiceConfigTagsObject(serviceName);
    context.result = App.config.mergePreDefinedWithLoaded(context.configGroups, context.advancedConfigs, context.tags, App.Service.find().findProperty('id', serviceName).get('serviceName'));
  };

  var loadAllServicesConfigs = function(context, serviceNames) {
    context.configGroups = modelSetup.setupConfigGroupsObject();
  }

  var loadServiceModelsData = function(serviceNames) {
    serviceNames.forEach(function(serviceName) {
      App.store.load(App.Service, {
        id: serviceName,
        service_name: serviceName
      });
    });
  };

  var setupContentForMergeWithStored = function(context) {
    loadServiceModelsData(context.installedServiceNames);
    loadAllServicesConfigs(context);
    setups.setupStackVersion(this, 'HDP-2.1');
    context.result = App.config.mergePreDefinedWithStored(context.storedConfigs, modelSetup.setupAdvancedConfigsObject(), context.installedServiceNames);
  };

  var removeServiceModelData = function(serviceIds) {
    serviceIds.forEach(function(serviceId) {
      var record = App.Service.find(serviceId);
      record.deleteRecord();
      record.get('stateManager').transitionTo('loading');
    });
  };

  describe('#handleSpecialProperties', function () {
    var config = {};
    it('value should be transformed to "1024" from "1024m"', function () {
      config = {
        displayType: 'int',
        value: '1024m',
        defaultValue: '1024m'
      };
      App.config.handleSpecialProperties(config);
      expect(config.value).to.equal('1024');
      expect(config.defaultValue).to.equal('1024');
    });
    it('value should be transformed to true from "true"', function () {
      config = {
        displayType: 'checkbox',
        value: 'true',
        defaultValue: 'true'
      };
      App.config.handleSpecialProperties(config);
      expect(config.value).to.equal(true);
      expect(config.defaultValue).to.equal(true);
    });
    it('value should be transformed to false from "false"', function () {
      config = {
        displayType: 'checkbox',
        value: 'false',
        defaultValue: 'false'
      };
      App.config.handleSpecialProperties(config);
      expect(config.value).to.equal(false);
      expect(config.defaultValue).to.equal(false);
    });
  });

  describe('#capacitySchedulerFilter', function() {
    var testMessage = 'filter should {0} detect `{1}` property';
    describe('Stack version >= 2.0', function() {
      before(function() {
        setups.setupStackVersion(this, 'HDP-2.1');
      });
      var tests = [
        {
          config: {
            name: 'yarn.scheduler.capacity.maximum-am-resource-percent'
          },
          e: false
        },
        {
          config: {
            name: 'yarn.scheduler.capacity.root.capacity'
          },
          e: false
        },
        {
          config: {
            name: 'yarn.scheduler.capacity.root.default.capacity'
          },
          e: true
        }
      ];

      tests.forEach(function(test){
        it(testMessage.format( !!test.e ? '' : 'not', test.config.name), function() {
          expect(App.config.get('capacitySchedulerFilter')(test.config)).to.eql(test.e);
        });
      });
      after(function() {
        setups.restoreStackVersion(this);
      })
    });

    describe('Stack version < 2.0', function() {
      before(function() {
        setups.setupStackVersion(this, 'HDP-1.3');
      });
      var tests = [
        {
          config: {
            name: 'mapred.capacity-scheduler.maximum-system-jobs'
          },
          e: false
        },
        {
          config: {
            name: 'yarn.scheduler.capacity.root.capacity'
          },
          e: false
        },
        {
          config: {
            name: 'mapred.capacity-scheduler.queue.default.capacity'
          },
          e: true
        },
        {
          config: {
            name: 'mapred.queue.default.acl-administer-jobs'
          },
          e: true
        }
      ];

      tests.forEach(function(test){
        it(testMessage.format( !!test.e ? '' : 'not', test.config.name), function() {
          expect(App.config.get('capacitySchedulerFilter')(test.config)).to.eql(test.e);
        });
      });

      after(function() {
        setups.restoreStackVersion(this);
      });
    });
  });

  describe('#fileConfigsIntoTextarea', function () {
    var filename = 'capacity-scheduler.xml';
    var configs = [
      {
        name: 'config1',
        value: 'value1',
        defaultValue: 'value1',
        filename: 'capacity-scheduler.xml'
      },
      {
        name: 'config2',
        value: 'value2',
        defaultValue: 'value2',
        filename: 'capacity-scheduler.xml'
      }
    ];
    it('two configs into textarea', function () {
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('config1=value1\nconfig2=value2\n');
      expect(result[0].defaultValue).to.equal('config1=value1\nconfig2=value2\n');
    });
    it('three config into textarea', function () {
      configs.push({
        name: 'config3',
        value: 'value3',
        defaultValue: 'value3',
        filename: 'capacity-scheduler.xml'
      });
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('config1=value1\nconfig2=value2\nconfig3=value3\n');
      expect(result[0].defaultValue).to.equal('config1=value1\nconfig2=value2\nconfig3=value3\n');
    });
    it('one of three configs has different filename', function () {
      configs[1].filename = 'another filename';
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      //result contains two configs: one with different filename and one textarea config
      expect(result.length).to.equal(2);
      expect(result[1].value).to.equal('config1=value1\nconfig3=value3\n');
      expect(result[1].defaultValue).to.equal('config1=value1\nconfig3=value3\n');
    });
    it('none configs into empty textarea', function () {
      filename = 'capacity-scheduler.xml';
      configs.clear();
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('');
      expect(result[0].defaultValue).to.equal('');
    });

  });

  describe('#textareaIntoFileConfigs', function () {
    var filename = 'capacity-scheduler.xml';
    var testData = [
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1",
          "filename": "capacity-scheduler.xml"
        })]
      },
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1\nconfig2=value2\n",
          "filename": "capacity-scheduler.xml"
        })]
      },
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1,value2\n",
          "filename": "capacity-scheduler.xml"
        })]
      },
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1 config2=value2\n",
          "filename": "capacity-scheduler.xml"
        })]
      }
    ];

    it('config1=value1 to one config', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[0].configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('value1');
      expect(result[0].name).to.equal('config1');
    });
    it('config1=value1\\nconfig2=value2\\n to two configs', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[1].configs, filename);
      expect(result.length).to.equal(2);
      expect(result[0].value).to.equal('value1');
      expect(result[0].name).to.equal('config1');
      expect(result[1].value).to.equal('value2');
      expect(result[1].name).to.equal('config2');
    });
    it('config1=value1,value2\n to one config', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[2].configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('value1,value2');
      expect(result[0].name).to.equal('config1');
    });
    it('config1=value1 config2=value2 to two configs', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[3].configs, filename);
      expect(result.length).to.equal(1);
    });
  });

  describe('#addAvancedConfigs()', function() {
    before(function() {
      this.storedConfigs = modelSetup.setupStoredConfigsObject();
    });

    it('`custom.zoo.cfg` absent in stored configs', function() {
      expect(this.storedConfigs.findProperty('name', 'custom.zoo.cfg')).to.be.undefined;
    });

    it('`custom.zoo.cfg.` from advanced configs should be added to stored configs', function() {
      App.config.addAdvancedConfigs(this.storedConfigs, modelSetup.setupAdvancedConfigsObject(), 'ZOOKEEPER');
      var property = this.storedConfigs.findProperty('name', 'custom.zoo.cfg');
      expect(property).to.be.ok;
      expect(property.category).to.eql('Advanced zoo.cfg');
    });

    it('`capacity-scheduler.xml` property with name `content` should have `displayType` `multiLine`', function() {
      expect(this.storedConfigs.filterProperty('filename', 'capacity-scheduler.xml').findProperty('name','content').displayType).to.eql('multiLine');
    });
  });

  describe('#trimProperty',function() {
    var testMessage = 'displayType `{0}`, value `{1}`{3} should return `{2}`';
    var tests = [
      {
        config: {
          displayType: 'directory',
          value: ' /a /b /c'
        },
        e: '/a,/b,/c'
      },
      {
        config: {
          displayType: 'directories',
          value: ' /a /b '
        },
        e: '/a,/b'
      },
      {
        config: {
          displayType: 'datanodedirs',
          value: ' [DISK]/a [SSD]/b '
        },
        e: '[DISK]/a,[SSD]/b'
      },
      {
        config: {
          displayType: 'host',
          value: ' localhost '
        },
        e: 'localhost'
      },
      {
        config: {
          displayType: 'password',
          value: ' passw ord '
        },
        e: ' passw ord '
      },
      {
        config: {
          displayType: 'advanced',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'advanced',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'advanced',
          value: 'http://localhost ',
          name: 'javax.jdo.option.ConnectionURL'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'advanced',
          value: 'http://localhost    ',
          name: 'oozie.service.JPAService.jdbc.url'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'custom',
          value: ' custom value '
        },
        e: ' custom value'
      },
      {
        config: {
          displayType: 'masterHosts',
          value: ['host1.com', 'host2.com']
        },
        e: ['host1.com', 'host2.com']
      }
    ];

    tests.forEach(function(test) {
      it(testMessage.format(test.config.displayType, test.config.value, test.e, !!test.config.name ? ', name `' + test.config.name + '`' : ''), function() {
        expect(App.config.trimProperty(test.config)).to.eql(test.e);
        expect(App.config.trimProperty(Em.Object.create(test.config), true)).to.eql(test.e);
      });
    });
  });

  describe('#OnNnHAHideSnn()', function() {
    it('`SNameNode` category present in `ServiceConfig`. It should be removed.', function() {
      App.store.load(App.HDFSService, {
        'id': 'HDFS'
      });
      var ServiceConfig = Em.Object.create({
        configCategories: [ { name: 'SNameNode' } ]
      });
      expect(ServiceConfig.get('configCategories').findProperty('name','SNameNode')).to.ok;
      App.config.OnNnHAHideSnn(ServiceConfig);
      expect(ServiceConfig.get('configCategories').findProperty('name','SNameNode')).to.undefined;
      var record = App.HDFSService.find('HDFS');
      record.deleteRecord();
      record.get('stateManager').transitionTo('loading');
    });
    it('`SNameNode` category absent in `ServiceConfig`. Nothing to do.', function() {
      App.store.load(App.HDFSService, {
        'id': 'HDFS'
      });
      var ServiceConfig = Em.Object.create({
        configCategories: [ { name: 'DataNode' } ]
      });
      App.config.OnNnHAHideSnn(ServiceConfig);
      expect(ServiceConfig.get('configCategories').findProperty('name','DataNode')).to.ok;
      expect(ServiceConfig.get('configCategories.length')).to.eql(1);
    });
  });

  describe('#preDefinedConfigFile', function() {
    before(function() {
      setups.setupStackVersion(this, 'BIGTOP-0.8');
    });

    it('bigtop site properties should be ok.', function() {
      var bigtopSiteProperties = App.config.preDefinedConfigFile('site_properties');
      expect(bigtopSiteProperties).to.be.ok;
    });

    it('a non-existing file should not be ok.', function () {
      var notExistingSiteProperty = App.config.preDefinedConfigFile('notExisting');
      expect(notExistingSiteProperty).to.not.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#preDefinedSiteProperties-bigtop', function () {
    before(function() {
      setups.setupStackVersion(this, 'BIGTOP-0.8');
    });

    it('bigtop should use New PostgreSQL Database as its default hive metastore database', function () {
      expect(App.config.get('preDefinedSiteProperties').findProperty('defaultValue', 'New PostgreSQL Database')).to.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#preDefinedSiteProperties-hdp2', function () {
    before(function() {
      setups.setupStackVersion(this, 'HDP-2.0');
    });

    it('HDP2 should use New MySQL Database as its default hive metastore database', function () {
      expect(App.config.get('preDefinedSiteProperties').findProperty('defaultValue', 'New MySQL Database')).to.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#generateConfigPropertiesByName', function() {
    var tests = [
      {
        names: ['property_1', 'property_2'],
        properties: undefined,
        e: {
          keys: ['name', 'displayName', 'isVisible', 'isReconfigurable']
        },
        m: 'Should generate base property object without additional fields'
      },
      {
        names: ['property_1', 'property_2'],
        properties: { category: 'SomeCat', serviceName: 'SERVICE_NAME' },
        e: {
          keys: ['name', 'displayName', 'isVisible', 'isReconfigurable', 'category', 'serviceName']
        },
        m: 'Should generate base property object without additional fields'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).length).to.eql(test.names.length);
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).map(function(property) {
          return Em.keys(property);
        }).reduce(function(p, c) {
          return p.concat(c);
        }).uniq()).to.eql(test.e.keys);
      });
    });

  });

  describe('#generateConfigPropertiesByName', function() {
    var tests = [
      {
        names: ['property_1', 'property_2'],
        properties: undefined,
        e: {
          keys: ['name', 'displayName', 'isVisible', 'isReconfigurable']
        },
        m: 'Should generate base property object without additional fields'
      },
      {
        names: ['property_1', 'property_2'],
        properties: { category: 'SomeCat', serviceName: 'SERVICE_NAME' },
        e: {
          keys: ['name', 'displayName', 'isVisible', 'isReconfigurable', 'category', 'serviceName']
        },
        m: 'Should generate base property object without additional fields'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).length).to.eql(test.names.length);
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).map(function(property) {
          return Em.keys(property);
        }).reduce(function(p, c) {
          return p.concat(c);
        }).uniq()).to.eql(test.e.keys);
      });
    });

  });

  describe('#generateConfigPropertiesByName', function() {
    var tests = [
      {
        names: ['property_1', 'property_2'],
        properties: undefined,
        e: {
          keys: ['name', 'displayName', 'isVisible', 'isReconfigurable']
        },
        m: 'Should generate base property object without additional fields'
      },
      {
        names: ['property_1', 'property_2'],
        properties: { category: 'SomeCat', serviceName: 'SERVICE_NAME' },
        e: {
          keys: ['name', 'displayName', 'isVisible', 'isReconfigurable', 'category', 'serviceName']
        },
        m: 'Should generate base property object without additional fields'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).length).to.eql(test.names.length);
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).map(function(property) {
          return Em.keys(property);
        }).reduce(function(p, c) {
          return p.concat(c);
        }).uniq()).to.eql(test.e.keys);
      });
    });

  });

  describe('#isManagedMySQLForHiveAllowed', function () {

    var cases = [
      {
        osType: 'redhat5',
        expected: false
      },
      {
        osType: 'redhat6',
        expected: true
      },
      {
        osType: 'sles11',
        expected: false
      }
    ],
      title = 'should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osType), function () {
        expect(App.config.isManagedMySQLForHiveAllowed(item.osType)).to.equal(item.expected);
      });
    });

  });

});

});

;require.register("test/utils/configs/defaults_providers/hive_defaults_provider_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/defaults_providers/defaultsProvider');
require('utils/configs/defaults_providers/yarn_defaults_provider');

describe('HiveDefaultsProvider', function() {

  describe('#getDefaults', function() {
    var tests = Em.A([
      {
        localDB: {},
        m: 'Empty localDB',
        e: null
      },
      {
        localDB: {
          "masterComponentHosts": []
        },
        m: 'localDB without hosts',
        e: null
      },
      {
        localDB: {
          "hosts": {}
        },
        m: 'localDB without masterComponentHosts amd slaveComponentHosts',
        e: null
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'Without HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx2048m',
          'mapreduce.map.memory.mb': 2560,
          'mapreduce.reduce.java.opts': '-Xmx2048m',
          'mapreduce.reduce.memory.mb': 2560,
          'yarn.app.mapreduce.am.command-opts': '-Xmx2048m',
          'yarn.app.mapreduce.am.resource.mb': 2560,
          'yarn.nodemanager.resource.memory-mb': 20480,
          'yarn.scheduler.maximum-allocation-mb': 20480,
          'yarn.scheduler.minimum-allocation-mb': 2560,
          'mapreduce.task.io.sort.mb': 1024,
          'hive.tez.container.size': 2560,
          'hive.auto.convert.join.noconditionaltask.size': 894435328,
          'hive.tez.java.opts': '-server -Xmx2048m -Djava.net.preferIPv4Stack=true -XX:NewRatio=8 -XX:+UseNUMA -XX:+UseParallelGC'
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "12582912.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase (low memory - pick mapreduce.reduce.memory.mb)',
        e: {
          'mapreduce.map.java.opts': '-Xmx819m',
          'mapreduce.map.memory.mb': 1024,
          'mapreduce.reduce.java.opts': '-Xmx819m',
          'mapreduce.reduce.memory.mb': 1024,
          'yarn.app.mapreduce.am.command-opts': '-Xmx819m',
          'yarn.app.mapreduce.am.resource.mb': 1024,
          'yarn.nodemanager.resource.memory-mb': 8192,
          'yarn.scheduler.maximum-allocation-mb': 8192,
          'yarn.scheduler.minimum-allocation-mb': 1024,
          'mapreduce.task.io.sort.mb': 410,
          'hive.tez.container.size': 1024,
          'hive.auto.convert.join.noconditionaltask.size': 357564416,
          'hive.tez.java.opts': '-server -Xmx819m -Djava.net.preferIPv4Stack=true -XX:NewRatio=8 -XX:+UseNUMA -XX:+UseParallelGC'
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "100165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "100165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase (high memory - pick mapreduce.map.memory.mb)',
        e: {
          'mapreduce.map.java.opts': '-Xmx6963m',
          'mapreduce.map.memory.mb': 8704,
          'mapreduce.reduce.java.opts': '-Xmx6963m',
          'mapreduce.reduce.memory.mb': 8704,
          'yarn.app.mapreduce.am.command-opts': '-Xmx6963m',
          'yarn.app.mapreduce.am.resource.mb': 8704,
          'yarn.nodemanager.resource.memory-mb': 69632,
          'yarn.scheduler.maximum-allocation-mb': 69632,
          'yarn.scheduler.minimum-allocation-mb': 8704,
          'mapreduce.task.io.sort.mb': 1024,
          'hive.tez.container.size': 8704,
          'hive.auto.convert.join.noconditionaltask.size': 3041918976,
          'hive.tez.java.opts': '-server -Xmx6963m -Djava.net.preferIPv4Stack=true -XX:NewRatio=8 -XX:+UseNUMA -XX:+UseParallelGC'
        }
      }
    ]);
    tests.forEach(function(test) {
      describe(test.m, function() {
        var defaultsProvider = App.HiveDefaultsProvider.create();
        defaultsProvider.set('clusterData', null);
        var configs = defaultsProvider.getDefaults(test.localDB);
        Em.keys(configs).forEach(function(config) {
          it(config, function() {
            if (test.e) {
              expect(configs[config]).to.equal(test.e[config]);
            }
            else {
              expect(configs[config] == 0 || configs[config] == null).to.equal(true);
            }
          })
        });
      });
    });
  });

});

});

;require.register("test/utils/configs/defaults_providers/tez_defaults_provider_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/defaults_providers/defaultsProvider');
require('utils/configs/defaults_providers/yarn_defaults_provider');

describe('TezDefaultsProvider', function() {

  describe('#getDefaults', function() {
    var tests = [
      {
        localDB: {},
        m: 'Empty localDB',
        e: null
      },
      {
        localDB: {
          "masterComponentHosts": []
        },
        m: 'localDB without hosts',
        e: null
      },
      {
        localDB: {
          "hosts": {}
        },
        m: 'localDB without masterComponentHosts amd slaveComponentHosts',
        e: null
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'Without HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx2048m',
          'mapreduce.map.memory.mb': 2560,
          'mapreduce.reduce.java.opts': '-Xmx2048m',
          'mapreduce.reduce.memory.mb': 2560,
          'yarn.app.mapreduce.am.command-opts': '-Xmx2048m',
          'yarn.app.mapreduce.am.resource.mb': 2560,
          'yarn.nodemanager.resource.memory-mb': 20480,
          'yarn.scheduler.maximum-allocation-mb': 20480,
          'yarn.scheduler.minimum-allocation-mb': 2560,
          'mapreduce.task.io.sort.mb': 1024,
          'tez.am.resource.memory.mb': 2560,
          'tez.am.java.opts': '-server -Xmx2048m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC'
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "12582912.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx819m',
          'mapreduce.map.memory.mb': 1024,
          'mapreduce.reduce.java.opts': '-Xmx819m',
          'mapreduce.reduce.memory.mb': 1024,
          'yarn.app.mapreduce.am.command-opts': '-Xmx819m',
          'yarn.app.mapreduce.am.resource.mb': 1024,
          'yarn.nodemanager.resource.memory-mb': 8192,
          'yarn.scheduler.maximum-allocation-mb': 8192,
          'yarn.scheduler.minimum-allocation-mb': 1024,
          'mapreduce.task.io.sort.mb': 410,
          'tez.am.resource.memory.mb': 1024,
          'tez.am.java.opts': '-server -Xmx819m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC'
        }
      }
    ];
    tests.forEach(function(test) {
      describe(test.m, function() {
        var defaultsProvider = App.TezDefaultsProvider.create();
        defaultsProvider.set('clusterData', null);
        var configs = defaultsProvider.getDefaults(test.localDB);
        Em.keys(configs).forEach(function(config) {
          it(config, function() {
            if (test.e) {
              expect(configs[config]).to.equal(test.e[config]);
            } else {
              expect(configs[config] == 0 || configs[config] == null).to.equal(true);
            }
          });
        });
      });
    });
  });

});

});

;require.register("test/utils/configs/defaults_providers/yarn_defaults_provider_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/defaults_providers/defaultsProvider');
require('utils/configs/defaults_providers/yarn_defaults_provider');

var yarnDefaultProvider;

describe('YARNDefaultsProvider', function() {

  beforeEach(function() {
    yarnDefaultProvider = App.YARNDefaultsProvider.create();
  });

  afterEach(function() {
    yarnDefaultProvider.set('clusterData', null);
    yarnDefaultProvider.set('reservedRam', null);
    yarnDefaultProvider.set('hBaseRam', null);
    yarnDefaultProvider.set('containers', null);
    yarnDefaultProvider.set('recommendedMinimumContainerSize', null);
    yarnDefaultProvider.set('ramPerContainer', null);
    yarnDefaultProvider.set('mapMemory', null);
    yarnDefaultProvider.set('reduceMemory', null);
    yarnDefaultProvider.set('amMemory', null);
  });

  describe('#clusterDataIsValid', function() {
    var tests = Em.A([
      {clusterData: {disk: 12,ram: 48,cpu: 12,hBaseInstalled: false},e: true},
      {clusterData: {disk: null,ram: 48,cpu: 12,hBaseInstalled: false},e: false},
      {clusterData: {disk: 12,ram: null,cpu: 12,hBaseInstalled: false},e: false},
      {clusterData: {disk: 12,ram: 48,cpu: null,hBaseInstalled: false},e: false},
      {clusterData: {disk: 12,ram: 48,cpu: 12,hBaseInstalled: null},e: false},
      {clusterData: {disk: 12,ram: 48,cpu: 12},e: false},
      {clusterData: {disk: 12,ram: 48,hBaseInstalled: true},e: false},
      {clusterData: {disk: 12,cpu: 12,hBaseInstalled: true},e: false},
      {clusterData: {ram: 48,cpu: 12,hBaseInstalled: false},e: false}
    ]);
    tests.forEach(function(test) {
      it((test.e?'valid':'invalid') + ' clusterData', function() {
        yarnDefaultProvider.set('clusterData', test.clusterData);
        expect(yarnDefaultProvider.clusterDataIsValid()).to.equal(test.e);
      });
    });
  });

  describe('#reservedMemoryRecommendations', function() {
    var tests = Em.A([
      {ram: null, e: {os: 1, hbase: 1}},
      {ram: 2, e: {os: 1, hbase: 1}},
      {ram: 4, e: {os: 1, hbase: 1}},
      {ram: 6, e: {os: 2, hbase: 1}},
      {ram: 8, e: {os: 2, hbase: 1}},
      {ram: 12, e: {os: 2, hbase: 2}},
      {ram: 16, e: {os: 2, hbase: 2}},
      {ram: 20, e: {os: 4, hbase: 4}},
      {ram: 24, e: {os: 4, hbase: 4}},
      {ram: 36, e: {os: 6, hbase: 8}},
      {ram: 48, e: {os: 6, hbase: 8}},
      {ram: 56, e: {os: 8, hbase: 8}},
      {ram: 64, e: {os: 8, hbase: 8}},
      {ram: 68, e: {os: 8, hbase: 8}},
      {ram: 72, e: {os: 8, hbase: 8}},
      {ram: 84, e: {os: 12, hbase: 16}},
      {ram: 96, e: {os: 12, hbase: 16}},
      {ram: 112, e: {os: 24, hbase: 24}},
      {ram: 128, e: {os: 24, hbase: 24}},
      {ram: 196, e: {os: 32, hbase: 32}},
      {ram: 256, e: {os: 32, hbase: 32}},
      {ram: 384, e: {os: 64, hbase: 64}},
      {ram: 512, e: {os: 64, hbase: 64}},
      {ram: 756, e: {os: 64, hbase: 64}}
    ]);
    tests.forEach(function(test) {
      it('ram: ' + test.ram + ' GB', function() {
        sinon.spy(yarnDefaultProvider, 'reservedMemoryRecommendations');
        yarnDefaultProvider.set('clusterData', {
          disk: 12,
          ram: test.ram,
          cpu: 12,
          hBaseInstalled: false
        });
        expect(yarnDefaultProvider.get('reservedRam')).to.equal(test.e.os);
        expect(yarnDefaultProvider.get('hBaseRam')).to.equal(test.e.hbase);
        expect(yarnDefaultProvider.reservedMemoryRecommendations.calledOnce).to.equal(true);
        yarnDefaultProvider.reservedMemoryRecommendations.restore();
      });
    });
  });

  describe('#recommendedMinimumContainerSize', function() {
    it('No clusterData', function() {
      yarnDefaultProvider.set('clusterData', null);
      expect(yarnDefaultProvider.get('recommendedMinimumContainerSize')).to.equal(null);
    });
    it('No clusterData.ram', function() {
      yarnDefaultProvider.set('clusterData', {});
      expect(yarnDefaultProvider.get('recommendedMinimumContainerSize')).to.equal(null);
    });

    var tests = Em.A([
      {ram: 3, e: 256},
      {ram: 4, e: 256},
      {ram: 6, e: 512},
      {ram: 8, e: 512},
      {ram: 12, e: 1024},
      {ram: 24, e: 1024}
    ]);

    tests.forEach(function(test) {
      it('ram: ' + test.ram + ' GB', function() {
       yarnDefaultProvider.set('clusterData', {
          disk: 12,
          ram: test.ram,
          cpu: 12,
          hBaseInstalled: false
        });
        expect(yarnDefaultProvider.get('recommendedMinimumContainerSize')).to.equal(test.e);
      });
    });

  });

  describe('#containers', function() {
    it('No clusterData', function() {
      yarnDefaultProvider.set('clusterData', null);
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
    });
    it('Some clusterData metric is null', function() {
      yarnDefaultProvider.set('clusterData', {disk: null, cpu: 1, ram: 1});
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
      yarnDefaultProvider.set('clusterData', {disk: 1, cpu: null, ram: 1});
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
      yarnDefaultProvider.set('clusterData', {disk:1, cpu: 1, ram: null});
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
    });

    var tests = Em.A([
      {
        clusterData: {
          disk: 12,
          ram: 48,
          cpu: 12,
          hBaseInstalled: false
        },
        e: 21
      },
      {
        clusterData: {
          disk: 6,
          ram: 48,
          cpu: 6,
          hBaseInstalled: true
        },
        e: 11
      }
    ]);

    tests.forEach(function(test) {
      it((test.hBaseInstalled?'With':'Without') + ' hBase', function() {
        yarnDefaultProvider.set('clusterData', test.clusterData);
        expect(yarnDefaultProvider.get('containers')).to.equal(test.e);
      });
    });

  });

  describe('#ramPerContainer', function() {
    it('No clusterData', function() {
      yarnDefaultProvider.set('clusterData', null);
      expect(yarnDefaultProvider.get('ramPerContainer')).to.equal(null);
    });
    var tests = Em.A([
      {
        clusterData: {
          disk: 12,
          ram: 48,
          cpu: 12,
          hBaseInstalled: false
        },
        e: 2048
      },
      {
        clusterData: {
          disk: 12,
          ram: 16,
          cpu: 12,
          hBaseInstalled: true
        },
        e: 1024
      }
    ]);

    tests.forEach(function(test) {
      it((test.hBaseInstalled?'With':'Without') + ' hBase', function() {
        yarnDefaultProvider.set('clusterData', test.clusterData);
        expect(yarnDefaultProvider.get('ramPerContainer')).to.equal(test.e);
      });
    });
  });

  describe('#getDefaults', function() {
    var tests = Em.A([
      {
        localDB: {},
        m: 'Empty localDB',
        e: null
      },
      {
        localDB: {
          "masterComponentHosts": []
        },
        m: 'localDB without hosts',
        e: null
      },
      {
        localDB: {
          "hosts": {}
        },
        m: 'localDB without masterComponentHosts amd slaveComponentHosts',
        e: null
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'Without HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx2048m',
          'mapreduce.map.memory.mb': 2560,
          'mapreduce.reduce.java.opts': '-Xmx2048m',
          'mapreduce.reduce.memory.mb': 2560,
          'yarn.app.mapreduce.am.command-opts': '-Xmx2048m',
          'yarn.app.mapreduce.am.resource.mb': 2560,
          'yarn.nodemanager.resource.memory-mb': 20480,
          'yarn.scheduler.maximum-allocation-mb': 20480,
          'yarn.scheduler.minimum-allocation-mb': 2560,
          'mapreduce.task.io.sort.mb': 1024
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "12582912.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx819m',
          'mapreduce.map.memory.mb': 1024,
          'mapreduce.reduce.java.opts': '-Xmx819m',
          'mapreduce.reduce.memory.mb': 1024,
          'yarn.app.mapreduce.am.command-opts': '-Xmx819m',
          'yarn.app.mapreduce.am.resource.mb': 1024,
          'yarn.nodemanager.resource.memory-mb': 8192,
          'yarn.scheduler.maximum-allocation-mb': 8192,
          'yarn.scheduler.minimum-allocation-mb': 1024,
          'mapreduce.task.io.sort.mb': 410
        }
      }
    ]);
    tests.forEach(function(test) {
      yarnDefaultProvider = App.YARNDefaultsProvider.create();
      describe(test.m, function() {
        yarnDefaultProvider.set('clusterData', null);
        var configs = yarnDefaultProvider.getDefaults(test.localDB);

        Em.keys(configs).forEach(function(config) {
          it(config, function() {
            if (test.e) {
              expect(configs[config]).to.equal(test.e[config]);
            }
            else {
              expect(configs[config] == 0 || configs[config] == null).to.equal(true);
            }
          });
        });
      });
    });
  });

});

});

;require.register("test/utils/configs/validators/service_configs_validator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/validators/service_configs_validator');

describe('App.ServiceConfigsValidator', function() {

  describe('#validateConfig', function() {
    it('No config validator', function() {
      var v = App.ServiceConfigsValidator.create({});
      expect(v.validateConfig(Em.Object.create({name:'name'}))).to.equal(null);
    });
  });

  describe('#validatorLessThenDefaultValue', function() {
    var tests = Em.A([
      {
        recommendedDefaults: {
          'property1': 100500
        },
        config: Em.Object.create({
          value: 100000,
          name: 'property1'
        }),
        m: 'Numeric value',
        e: 'string'
      },
      {
        recommendedDefaults: {
          'property1': 'xx100500x'
        },
        config: Em.Object.create({
          value: 'xx100000x',
          name: 'property1'
        }),
        m: 'String value',
        e: 'string'
      },
      {
        recommendedDefaults: {
          'property1': null
        },
        config: Em.Object.create({
          value: 100000,
          name: 'property1'
        }),
        m: 'No default value for property',
        e: null
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        var v = App.ServiceConfigsValidator.create({});
        v.set('recommendedDefaults', test.recommendedDefaults);
        var r = v.validatorLessThenDefaultValue(test.config);
        if (test.e) {
          expect(r).to.be.a(test.e);
        }
        else {
          expect(r).to.equal(null)
        }
      });
    });
  });

  describe('#_checkXmxValueFormat', function() {
    var tests = Em.A([
      {value: '',e: false},
      {value: '-',e: false},
      {value: '100',e: false},
      {value: '-Xmx',e: false},
      {value: '-XMX1',e: false},
      {value: '-Xmxb',e: false},
      {value: '-Xmxk',e: false},
      {value: '-Xmxm',e: false},
      {value: '-Xmxg',e: false},
      {value: '-Xmxp',e: false},
      {value: '-Xmxt',e: false},
      {value: '-XmxB',e: false},
      {value: '-XmxK',e: false},
      {value: '-XmxM',e: false},
      {value: '-XmxG',e: false},
      {value: '-XmxP',e: false},
      {value: '-XmxT',e: false},
      {value: '-Xmx1',e: true},
      {value: '-Xmx1b',e: true},
      {value: '-Xmx1k',e: true},
      {value: '-Xmx1m',e: true},
      {value: '-Xmx1g',e: true},
      {value: '-Xmx1t',e: true},
      {value: '-Xmx1p',e: true},
      {value: '-Xmx1B',e: true},
      {value: '-Xmx1K',e: true},
      {value: '-Xmx1M',e: true},
      {value: '-Xmx1G',e: true},
      {value: '-Xmx1T',e: true},
      {value: '-Xmx1P',e: true},
      {value: '-Xmx100',e: true},
      {value: '-Xmx100b',e: true},
      {value: '-Xmx100k',e: true},
      {value: '-Xmx100m',e: true},
      {value: '-Xmx100g',e: true},
      {value: '-Xmx100t',e: true},
      {value: '-Xmx100p',e: true},
      {value: '-Xmx100B',e: true},
      {value: '-Xmx100K',e: true},
      {value: '-Xmx100M',e: true},
      {value: '-Xmx100G',e: true},
      {value: '-Xmx100T',e: true},
      {value: '-Xmx100P',e: true},
      {value: '-Xmx100Psome',e: false},
      {value: '-Xmx100P-Xmx',e: false},
      {value: '-Xmx100P -Xmx',e: false},
      {value: '-Xmx100P -XMX',e: false},
      {value: '-server -Xmx1024m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: true},
      {value: '-server -Xmx1024 -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: true},
      {value: '-server -Xmx1024', e: true},
      {value: '-Xmx1024 -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: true},
      {value: '-server -Xmx1024m-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server -Xmx1024-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024 -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024m-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-Xmx1024-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024', e: false},
      {value: '-server    -Xmx1024m   -Da=b',e: true},
      {value: '-server -Xmx1024m -Da=b',e: true},
      {value: '-server -XMx1024m -Da=b',e: false},
      {value: '-server -Xmx1024M -Da=b',e: true},
      {value: '-server -Xmx1 -Da=b',e: true},
      {value: '-server -Xmx1100MBPS -Da=b',e: false},
      {value: '-server -Xmx1100M -Xmx200 -Da=b',e: false},
      {value: '-server --Xmx1100M -Da=b',e: false},
      {value: '-Xmx1024m -server -Da=b',e: true},
      {value: ' -server -Da=b -Xmx1024m',e: true}
    ]);
    tests.forEach(function(test) {
      it(test.value, function() {
        var v = App.ServiceConfigsValidator.create({});
        expect(v._checkXmxValueFormat(test.value)).to.equal(test.e);
      });
    });
  });

  describe('#_getXmxSize', function() {
    var tests = Em.A([
      {value: '-Xmx1', e: '1'},
      {value: '-Xmx1b', e: '1b'},
      {value: '-Xmx1k', e: '1k'},
      {value: '-Xmx1m', e: '1m'},
      {value: '-Xmx1g', e: '1g'},
      {value: '-Xmx1t', e: '1t'},
      {value: '-Xmx1p', e: '1p'},
      {value: '-Xmx1B', e: '1b'},
      {value: '-Xmx1K', e: '1k'},
      {value: '-Xmx1M', e: '1m'},
      {value: '-Xmx1G', e: '1g'},
      {value: '-Xmx1T', e: '1t'},
      {value: '-Xmx1P', e: '1p'},
      {value: '-Xmx100b', e: '100b'},
      {value: '-Xmx100k', e: '100k'},
      {value: '-Xmx100m', e: '100m'},
      {value: '-Xmx100g', e: '100g'},
      {value: '-Xmx100t', e: '100t'},
      {value: '-Xmx100p', e: '100p'},
      {value: '-Xmx100B', e: '100b'},
      {value: '-Xmx100K', e: '100k'},
      {value: '-Xmx100M', e: '100m'},
      {value: '-Xmx100G', e: '100g'},
      {value: '-Xmx100T', e: '100t'},
      {value: '-Xmx100P', e: '100p'}
    ]);
    tests.forEach(function(test) {
      it(test.value, function() {
        var v = App.ServiceConfigsValidator.create({});
        expect(v._getXmxSize(test.value)).to.equal(test.e);
      });
    });
  });

  describe('#_formatXmxSizeToBytes', function() {
    var tests = Em.A([
      {value: '1', e: 1},
      {value: '1 ', e: 1},
      {value: '100', e: 100},
      {value: '100 ', e: 100},
      {value: '100b', e: 100},
      {value: '100B', e: 100},
      {value: '100k', e: 100 * 1024},
      {value: '100K', e: 100 * 1024},
      {value: '100m', e: 100 * 1024 * 1024},
      {value: '100M', e: 100 * 1024 * 1024},
      {value: '100g', e: 100 * 1024 * 1024 * 1024},
      {value: '100G', e: 100 * 1024 * 1024 * 1024},
      {value: '100t', e: 100 * 1024 * 1024 * 1024 * 1024},
      {value: '100T', e: 100 * 1024 * 1024 * 1024 * 1024},
      {value: '100p', e: 100 * 1024 * 1024 * 1024 * 1024 * 1024},
      {value: '100P', e: 100 * 1024 * 1024 * 1024 * 1024 * 1024}
    ]);
    tests.forEach(function(test) {
      it(test.value, function() {
        var v = App.ServiceConfigsValidator.create({});
        expect(v._formatXmxSizeToBytes(test.value)).to.equal(test.e);
      });
    });
  });

  describe('#validateXmxValue', function() {
    var tests = Em.A([
      {
        recommendedDefaults: {
          'property1': '-Xmx1024m'
        },
        config: Em.Object.create({
          value: '-Xmx2g',
          name: 'property1'
        }),
        e: null
      },
      {
        recommendedDefaults: {
          'property1': '-Xmx12'
        },
        config: Em.Object.create({
          value: '-Xmx24',
          name: 'property1'
        }),
        e: null
      },
      {
        recommendedDefaults: {
          'property1': '-Xmx333k'
        },
        config: Em.Object.create({
          value: '-Xmx134k',
          name: 'property1'
        }),
        e: 'string'
      },
      {
        recommendedDefaults: {
          'property1': '-Xmx333k'
        },
        config: Em.Object.create({
          value: '-Xmx534',
          name: 'property1'
        }),
        e: 'string'
      },
      {
        recommendedDefaults: {},
        config: Em.Object.create({
          defaultValue: '-Xmx123',
          value: '-Xmx123',
          name: 'name'
        }),
        e: null
      },
      {
        recommendedDefaults: {},
        config: Em.Object.create({
          defaultValue: '-Xmx124',
          value: '-Xmx123',
          name: 'name'
        }),
        e: 'string'
      }
    ]);
    tests.forEach(function(test) {
      it(test.config.get('value'), function() {
        var v = App.ServiceConfigsValidator.create({});
        v.set('recommendedDefaults', test.recommendedDefaults);
        var r = v.validateXmxValue(test.config);
        if (test.e) {
          expect(r).to.be.a(test.e);
        }
        else {
          expect(r).to.equal(null)
        }
      });
    });

    it('Error should be thrown', function() {
      var v = App.ServiceConfigsValidator.create({});
      v.set('recommendedDefaults', {});
      expect(function() {v.validateXmxValue(Em.Object.create({value:''}));}).to.throw(Error);
    });

  });

});

});

;require.register("test/utils/date_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

var validator = require('utils/validator');
var date = require('utils/date');

describe('date', function () {

  var correct_tests = Em.A([
    {t: 1349752195000, e: 'Tue, Oct 09, 2012 03:09', e2: 'Tue Oct 09 2012'},
    {t: 1367752195000, e: 'Sun, May 05, 2013 11:09', e2: 'Sun May 05 2013'},
    {t: 1369952195000, e: 'Thu, May 30, 2013 22:16', e2: 'Thu May 30 2013'}
  ]);

  var incorrect_tests = Em.A([
    {t: null},
    {t: ''},
    {t: false},
    {t: []},
    {t: {}},
    {t: undefined},
    {t: function(){}}
  ]);

  describe('#dateFormatZeroFirst()', function() {
    var tests = [
      {
        t: 2,
        e: '02',
        m: 'should convert to `02`'
      },
      {
        t: 10,
        e: '10',
        m: 'should convert to `10`'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(date.dateFormatZeroFirst(test.t)).to.eql(test.e);
      });
    });
  });

  describe('#startTime()', function() {
    var today = new Date();
    var testDate = new Date(1349752195000);
    var tests = [
      { t: 1349752195000, e: testDate.toDateString() + ' {0}:{1}'.format(date.dateFormatZeroFirst(testDate.getHours()), date.dateFormatZeroFirst(testDate.getMinutes())) },
      { t: -10000000, e: 'Not started' },
      { t: today.getTime(), e: 'Today {0}:{1}'.format(date.dateFormatZeroFirst(today.getHours()), date.dateFormatZeroFirst(today.getMinutes())) },
      { t: today, e: ''}
    ];
    tests.forEach(function(test) {
      var testMessage = 'should convert {0} to {1}'.format(test.t, test.e);
      it(testMessage, function() {
        expect(date.startTime(test.t)).to.be.eql(test.e);
      });
    });
  });

  describe('#timingFormat', function() {
    var tests = Em.A([
      {i: '30', e:'30 ms'},
      {i: '300', e:'300 ms'},
      {i: '999', e:'999 ms'},
      {i: '1000', e:'1.00 secs'},
      {i: '3000', e:'3.00 secs'},
      {i: '35000', e:'35.00 secs'},
      {i: '350000', e:'350.00 secs'},
      {i: '999999', e:'1000.00 secs'},
      {i: '1000000', e:'16.67 mins'},
      {i: '3500000', e:'58.33 mins'},
      {i: '35000000', e:'9.72 hours'},
      {i: '350000000', e:'4.05 days'},
      {i: '3500000000', e:'40.51 days'},
      {i: '35000000000', e:'405.09 days'}
    ]);

    describe('Correct data', function(){
      tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.timingFormat(test.i)).to.equal(test.e);
        });
      });
    });

    describe('Incorrect data', function(){
      incorrect_tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.timingFormat(test.t)).to.equal(null);
        });
      });
    });

  });

  describe('#duration', function() {
    var tests = Em.A([
      {startTime: 1, endTime: 2, e: 1},
      {startTime: 0, endTime: 2000, e: 0},
      {startTime: 200, endTime: 0, e: 19800}
    ]);

    beforeEach(function() {
      sinon.stub(App, 'dateTime', function () { return 20000; });
    });

    tests.forEach(function(test) {
      it(test.startTime + ' ' + test.endTime, function() {
        expect(date.duration(test.startTime, test.endTime)).to.equal(test.e);
      });
    });

    afterEach(function() {
      App.dateTime.restore();
    });
  });

  describe('#durationSummary()', function() {
    var tests = [
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1349752199000,
        e: '4.00 secs'
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1367752195000,
        e: '208.33 days'
      },
      {
        startTimestamp: -10000000,
        endTimestamp: 1367752195000,
        e: Em.I18n.t('common.na')
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: -1,
        stubbed: true,
        e: '0 secs'
      },
      {
        startTimestamp: 100000000,
        endTimestamp: -1,
        stubbed: true,
        e: '19.00 secs'
      }
    ];

    beforeEach(function() {
      sinon.stub(App, 'dateTime', function () { return 100019000; });
    });

    tests.forEach(function(test) {
      var testMessage = 'duration between {0} and {1} is {2}'.format(test.startTimestamp, test.endTimestamp, test.e) + (test.stubbed ? " App.dateTime() is stubbed" : "");
      it(testMessage, function() {
        expect(date.durationSummary(test.startTimestamp, test.endTimestamp)).to.be.eql(test.e);
      });
    });

    afterEach(function() {
      App.dateTime.restore();
    });
  });

});
});

;require.register("test/utils/form_field_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/form');


/*
 * formField.isValid property doesn't update correctly, so I have to work with errorMessage property
 */
describe('App.FormField', function () {

  describe('#validate()', function () {
    /*NUMBER TYPE END*/
    /*REQUIRE*/
    it('Required field shouldn\'t be empty', function () {
      var formField = App.FormField.create();
      formField.set('displayType', 'string');
      formField.set('value', '');
      formField.set('isRequired', true);
      formField.validate();
      expect(formField.get('errorMessage') === '').to.equal(false);
    });
    /*REQUIRE END*/

  });
});
});

;require.register("test/utils/helper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var App = require('app');
require('utils/helper');

describe('utils/helper', function() {
  describe('String helpers', function() {
    describe('#trim()', function(){
      it('should replace first space', function() {
        expect(' as d f'.trim()).to.eql('as d f');
      });
    });
    describe('#endsWith()', function() {
      it('`abcd` ends with `d`', function(){
        expect('abcd'.endsWith('d')).to.eql(true);
      });
      it('`abcd` doesn\'t end with `f`', function(){
        expect('abcd'.endsWith('f')).to.eql(false);
      });
    });
    describe('#contains()', function() {
      it('`abc` contains b', function(){
        expect('abc'.contains('b')).to.eql(true);
      });
      it('`abc` doesn\'t contain d', function() {
        expect('abc'.contains('d')).to.eql(false);
      });
    });
    describe('#capitalize()',function() {
      it('`abc d` should start with `A`', function() {
        expect('abc d'.capitalize()).to.eql('Abc d');
      });
    });
    describe('#findIn()', function(){
      var obj = {
        a: {
          a1: 'AVal1'
        },
        b: 'BVal',
        c: {
          c1: {
            c2: 'Cval2'
          },
          b: 'BVal'
        }
      };
      var testValue = function(key, value) {
        it('key `' + key + '` should have `' + JSON.stringify(value) + '` value', function() {
          expect(key.findIn(obj)).to.eql(value);
        });
      };
      it('expect return `null` on non-object input', function(){
        expect('a'.findIn('b')).to.null;
      });
      testValue('a', obj.a);
      testValue('c2', obj.c.c1.c2);
      testValue('b', obj.b);
      testValue('d', null);
    });
    describe('#format()', function(){
      it('should replace string correctly', function(){
        expect("{0} world{1}".format("Hello","!")).to.eql("Hello world!");
      });
    });
    describe('#highlight()', function() {
      var str = "Hello world! I want to highlight this word!";
      it('should highlight `word` with default template', function() {
        var result = str.highlight(['word']);
        expect(result).to.eql("Hello world! I want to highlight this <b>word</b>!");
      });
      it('should highlight `world` and `word` with template `<span class="yellow">{0}</span>`', function() {
        var result = str.highlight(["world", "word"], '<span class="yellow">{0}</span>');
        expect(result).to.eql('Hello <span class="yellow">world</span>! I want to highlight this <span class="yellow">word</span>!')
      });
      var str2 = "First word, second word";
      it('should highlight `word` multiply times with default template', function() {
        var result = str2.highlight(["word"]);
        expect(result).to.eql("First <b>word</b>, second <b>word</b>");
      });
    });
  });
  describe('Number helpers', function(){
    describe('#toDaysHoursMinutes()', function(){
      var time = 1000000000;
      var minute = 1000*60;
      var hour = 60*minute;
      var day = 24*hour;
      var result = time.toDaysHoursMinutes();
      var testDays = Math.floor(time/day);
      it('should correct convert days', function(){
        expect(testDays).to.eql(result.d);
      });
      it('should correct convert hours', function(){
        expect(Math.floor((time - testDays * day)/hour)).to.eql(result.h);
      });
      it('should correct convert minutes', function(){
        expect(((time - Math.floor((time - testDays*day)/hour)*hour - testDays*day)/minute).toFixed(2)).to.eql(result.m);
      });
    });
  });
  describe('Array helpers', function(){
    describe('#sortPropertyLight()', function(){
      var testable = [
        { a: 2 },
        { a: 1 },
        { a: 6},
        { a: 64},
        { a: 3},
        { a: 3}
      ];
      var result = testable.sortPropertyLight('a');
      it('should return array with same length', function(){
        expect(testable.length).to.eql(result.length);
      });
      it('should sort array', function() {
        result.forEach(function(resultObj, index, resultArr) {
          if (index > resultArr.length - 1)
            expect(resultObj.a < resultArr[index + 1].a).to.eql(false);
        });
      });
      it('should try to sort without throwing exception', function(){
        expect(testable.sortPropertyLight(['a'])).to.ok;
      });
    });
  });
  describe('App helpers', function(){
    var appendDiv = function() {
      $('body').append('<div id="tooltip-test"></div>');
    };
    var removeDiv = function() {
      $('body').remove('#tooltip-test');
    };
    describe('#isEmptyObject', function(){
      it('should return true on empty object', function() {
        expect(App.isEmptyObject({})).to.eql(true);
      });
      it('should return false on non-empty object', function() {
        expect(App.isEmptyObject({ a: 1 })).to.eql(false);
      });
    });
    describe('#parseJSON()', function(){
      var testable = '{"hello": "world"}';
      expect(App.parseJSON(testable).hello).to.eql('world');
    });
    describe('#tooltip()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add tooltip', function() {
        var tooltip = App.tooltip($('#tooltip-test'));
        expect($('#tooltip-test').data('tooltip').enabled).to.eql(true);
      });
    });
    describe('#popover()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add popover', function() {
        var tooltip = App.popover($('#tooltip-test'));
        expect($('#tooltip-test').data('popover').enabled).to.eql(true);
      });
    });
    describe('#App.format', function(){
      describe('#commandDetail()', function() {
        var command = "GANGLIA_MONITOR STOP";
        var ignored = "DECOMMISSION, NAMENODE";
        var removeString = "SERVICE/HDFS STOP";
        var nagiosState = "nagios_update_ignore ACTIONEXECUTE";
        it('should convert command to readable info', function() {
          expect(App.format.commandDetail(command)).to.eql(' Ganglia Monitor Stop');
        });
        it('should ignore decommission command', function(){
          expect(App.format.commandDetail(ignored)).to.eql('  NameNode');
        });
        it('should remove SERVICE string from command', function(){
          expect(App.format.commandDetail(removeString)).to.eql(' HDFS Stop');
        });
        it('should return maintenance message', function() {
          expect(App.format.commandDetail(nagiosState)).to.eql(' Toggle Maintenance Mode');
        });
      });
      describe('#taskStatus()', function(){
        var testable = [
          { status: 'PENDING', expectable: 'pending'},
          { status: 'QUEUED', expectable: 'queued'},
          { status: 'COMPLETED', expectable: 'completed'}
        ];
        testable.forEach(function(testObj){
          it('should convert `' + testObj.status + '` to `' + testObj.expectable + '`', function(){
            expect(App.format.taskStatus(testObj.status)).to.eql(testObj.expectable);
          });
        });
      });
      describe('#normalizeName()', function() {
        var testMessage = '`{0}` should be converted to `{1}`';
        var tests = {
          'APP_TIMELINE_SERVER': 'App Timeline Server',
          'DATANODE': 'DataNode',
          'DECOMMISSION_DATANODE': 'Update Exclude File',
          'DRPC_SERVER': 'DRPC Server',
          'FALCON': 'Falcon',
          'FALCON_CLIENT': 'Falcon Client',
          'FALCON_SERVER': 'Falcon Server',
          'FALCON_SERVICE_CHECK': 'Falcon Service Check',
          'FLUME_HANDLER': 'Flume',
          'FLUME_SERVICE_CHECK': 'Flume Service Check',
          'GANGLIA_MONITOR': 'Ganglia Monitor',
          'GANGLIA_SERVER': 'Ganglia Server',
          'GLUSTERFS_CLIENT': 'GLUSTERFS Client',
          'GLUSTERFS_SERVICE_CHECK': 'GLUSTERFS Service Check',
          'GMETAD_SERVICE_CHECK': 'Gmetad Service Check',
          'GMOND_SERVICE_CHECK': 'Gmond Service Check',
          'HADOOP_CLIENT': 'Hadoop Client',
          'HBASE_CLIENT': 'HBase Client',
          'HBASE_MASTER': 'HBase Master',
          'HBASE_REGIONSERVER': 'RegionServer',
          'HBASE_SERVICE_CHECK': 'HBase Service Check',
          'HCAT': 'HCat Client',
          'HDFS': 'HDFS',
          'HDFS_CLIENT': 'HDFS Client',
          'HDFS_SERVICE_CHECK': 'HDFS Service Check',
          'HISTORYSERVER': 'History Server',
          'HIVE_CLIENT': 'Hive Client',
          'HIVE_METASTORE': 'Hive Metastore',
          'HIVE_SERVER': 'HiveServer2',
          'HIVE_SERVICE_CHECK': 'Hive Service Check',
          'HUE_SERVER': 'Hue Server',
          'JAVA_JCE': 'Java JCE',
          'JOBTRACKER': 'JobTracker',
          'JOBTRACKER_SERVICE_CHECK': 'JobTracker Service Check',
          'JOURNALNODE': 'JournalNode',
          'KERBEROS_ADMIN_CLIENT': 'Kerberos Admin Client',
          'KERBEROS_CLIENT': 'Kerberos Client',
          'KERBEROS_SERVER': 'Kerberos Server',
          'MAPREDUCE2_CLIENT': 'MapReduce2 Client',
          'MAPREDUCE2_SERVICE_CHECK': 'MapReduce2 Service Check',
          'MAPREDUCE_CLIENT': 'MapReduce Client',
          'MAPREDUCE_SERVICE_CHECK': 'MapReduce Service Check',
          'MYSQL_SERVER': 'MySQL Server',
          'NAGIOS_SERVER': 'Nagios Server',
          'NAMENODE': 'NameNode',
          'NAMENODE_SERVICE_CHECK': 'NameNode Service Check',
          'NIMBUS': 'Nimbus',
          'NODEMANAGER': 'NodeManager',
          'OOZIE_CLIENT': 'Oozie Client',
          'OOZIE_SERVER': 'Oozie Server',
          'OOZIE_SERVICE_CHECK': 'Oozie Service Check',
          'PIG': 'Pig',
          'PIG_SERVICE_CHECK': 'Pig Service Check',
          'RESOURCEMANAGER': 'ResourceManager',
          'SECONDARY_NAMENODE': 'SNameNode',
          'SQOOP': 'Sqoop',
          'SQOOP_SERVICE_CHECK': 'Sqoop Service Check',
          'STORM_REST_API': 'Storm REST API Server',
          'STORM_SERVICE_CHECK': 'Storm Service Check',
          'STORM_UI_SERVER': 'Storm UI Server',
          'SUPERVISOR': 'Supervisor',
          'TASKTRACKER': 'TaskTracker',
          'TEZ_CLIENT': 'Tez Client',
          'WEBHCAT_SERVER': 'WebHCat Server',
          'YARN_CLIENT': 'YARN Client',
          'YARN_SERVICE_CHECK': 'YARN Service Check',
          'ZKFC': 'ZKFailoverController',
          'ZOOKEEPER_CLIENT': 'ZooKeeper Client',
          'ZOOKEEPER_QUORUM_SERVICE_CHECK': 'ZK Quorum Service Check',
          'ZOOKEEPER_SERVER': 'ZooKeeper Server',
          'ZOOKEEPER_SERVICE_CHECK': 'ZooKeeper Service Check',
          'CLIENT': 'Client'
        };
        for (var inputName in tests) {
          (function(name) {
            it(testMessage.format(name, tests[name]), function() {
              expect(App.format.normalizeName(name)).to.eql(tests[name]);
            });
          })(inputName)
        }
      });
    });
  });
  describe('#App.permit()', function() {
    var obj = {
      a1: 'v1',
      a2: 'v2',
      a3: 'v3'
    }

    var tests = [
      {
        keys: 'a1',
        e: {
          a1: 'v1'
        }
      },
      {
        keys: ['a2','a3','a4'],
        e: {
          a2: 'v2',
          a3: 'v3'
        }
      }
    ];

    tests.forEach(function(test) {
      it('should return object `{0}` permitted keys `{1}`'.format(JSON.stringify(test.e), JSON.stringify(test.keys)), function() {
        expect(App.permit(obj, test.keys)).to.deep.eql(test.e);
      });
    });
  });

  describe('#App.keysUnderscoreToCamelCase()', function() {
    var tests = [
      {
        object: {
          'key_upper': '2'
        },
        expected: {
          keyUpper: '2'
        },
        m: 'One level object, key should be camelCased'
      },
      {
        object: {
          'key_upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key_upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key_upper': '2',
          'key_upone_uptwo_upthree': '4',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          keyUponeUptwoUpthree: '4',
          key: '1'
        },
        m: 'One level object, two keys should be camelCased, few dots notation.'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.keysUnderscoreToCamelCase(test.object)).to.deep.equal(test.expected);
      });
    });
  });

  describe('#App.keysDottedToCamelCase()', function() {
    var tests = [
      {
        object: {
          'key.upper': '2'
        },
        expected: {
          keyUpper: '2'
        },
        m: 'One level object, key should be camelCased'
      },
      {
        object: {
          'key.upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key.upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key.upper': '2',
          'key.upone.uptwo.upthree': '4',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          keyUponeUptwoUpthree: '4',
          key: '1'
        },
        m: 'One level object, two keys should be camelCased, few dots notation.'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.keysDottedToCamelCase(test.object)).to.deep.equal(test.expected);
      });
    });
  });
});

});

;require.register("test/utils/host_progress_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/helper');
require('utils/host_progress_popup');

describe('App.HostPopup', function () {

  var services = [
    {
      displayName: "Start service WebHCat",
      hosts: [
        {
          logTasks: [
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-12-123-90.ec2.internal",
                role: "WEBHCAT_SERVER",
                status: "QUEUED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/23/tasks/94"
            }
          ],
          name: "ip-10-12-123-90.ec2.internal",
          publicName: "ip-10-12-123-90.ec2.internal",
          serviceName: "Start service WebHCat"
        }
      ],
      isRunning: false
    },
    {
      displayName: "Start service Hive/HCat",
      hosts: [
        {
          logTasks: [
            {
              Tasks: {
                command: "INSTALL",
                host_name: "ip-10-12-123-90.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/76"
            }
          ],
          name: "ip-10-12-123-90.ec2.internal",
          publicName: "ip-10-12-123-90.ec2.internal",
          serviceName: "Start service Hive/HCat"
        },
        {
          logTasks: [
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-33-7-23.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/78"
            },
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-33-7-23.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/79"
            }
          ],
          name: "ip-10-33-7-23.ec2.internal",
          publicName: "ip-10-33-7-23.ec2.internal",
          serviceName: "Start service Hive/HCat"
        }
      ],
      isRunning: false
    }
  ];

  var test_tasks = [
    {
      t: [
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'All COMPLETED',
      r: 'SUCCESS',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'FAILED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
        ,
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'One FAILED',
      r: 'FAILED',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'ABORTED',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One ABORTED',
      r: 'ABORTED',
      p: 100,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'TIMEDOUT',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'One TIMEDOUT',
      r: 'TIMEDOUT',
      p: 100,
      ids: [1,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'IN_PROGRESS',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One IN_PROGRESS',
      r: 'IN_PROGRESS',
      p: 68,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'QUEUED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'Something else',
      r: 'PENDING',
      p: 55,
      ids: [2,3]
    }
  ];

  var statusCases = [
    {
      status: 'FAILED',
      result: false
    },
    {
      status: 'ABORTED',
      result: false
    },
    {
      status: 'TIMEDOUT',
      result: false
    },
    {
      status: 'IN_PROGRESS',
      result: true
    },
    {
      status: 'COMPLETED',
      result: false
    },
    {
      status: 'PENDING',
      result: true
    }
  ];

  describe('#setSelectCount', function () {
    var itemsForStatusTest = [
      {
        title: 'Empty',
        data: [],
        result: [0, 0, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Pending',
        data: [
          {status: 'pending'},
          {status: 'queued'}
        ],
        result: [2, 2, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Completed',
        data: [
          {status: 'success'},
          {status: 'completed'}
        ],
        result: [2, 0, 0, 0, 2, 0, 0]
      },
      {
        title: 'All Failed',
        data: [
          {status: 'failed'},
          {status: 'failed'}
        ],
        result: [2, 0, 0, 2, 0, 0, 0]
      },
      {
        title: 'All InProgress',
        data: [
          {status: 'in_progress'},
          {status: 'in_progress'}
        ],
        result: [2, 0, 2, 0, 0, 0, 0]
      },
      {
        title: 'All Aborted',
        data: [
          {status: 'aborted'},
          {status: 'aborted'}
        ],
        result: [2, 0, 0, 0, 0, 2, 0]
      },
      {
        title: 'All Timedout',
        data: [
          {status: 'timedout'},
          {status: 'timedout'}
        ],
        result: [2, 0, 0, 0, 0, 0, 2]
      },
      {
        title: 'Every Category',
        data: [
          {status: 'pending'},
          {status: 'queued'},
          {status: 'success'},
          {status: 'completed'},
          {status: 'failed'},
          {status: 'in_progress'},
          {status: 'aborted'},
          {status: 'timedout'}
        ],
        result: [8, 2, 1, 1, 2, 1, 1]
      }
    ];
    var categories = [
      Ember.Object.create({value: 'all'}),
      Ember.Object.create({value: 'pending'}),
      Ember.Object.create({value: 'in_progress'}),
      Ember.Object.create({value: 'failed'}),
      Ember.Object.create({value: 'completed'}),
      Ember.Object.create({value: 'aborted'}),
      Ember.Object.create({value: 'timedout'})
    ];
    itemsForStatusTest.forEach(function(statusTest) {
      it(statusTest.title, function() {
        App.HostPopup.setSelectCount(statusTest.data, categories);
        expect(categories.mapProperty('count')).to.deep.equal(statusTest.result);
      });
    });
  });

  describe('#getStatus', function() {
    test_tasks.forEach(function(test_task) {
      it(test_task.m, function() {
        expect(App.HostPopup.getStatus(test_task.t)[0]).to.equal(test_task.r);
      });
    });
  });

  describe('#getProgress', function() {
    test_tasks.forEach(function(test_task) {
      it(test_task.m, function() {
        expect(App.HostPopup.getProgress(test_task.t)).to.equal(test_task.p);
      });
    });
  });

  describe('#isAbortableByStatus', function () {
    statusCases.forEach(function (item) {
      it('should return ' + item.result + ' for ' + item.status, function () {
        expect(App.HostPopup.isAbortableByStatus(item.status)).to.equal(item.result);
      });
    });
  });

  describe('#abortRequest', function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });
    afterEach(function () {
      App.ajax.send.restore();
      App.showConfirmationPopup.restore();
    });
    it('should show confirmation popup', function () {
      App.HostPopup.abortRequest(Em.Object.create({
        name: 'name'
      }));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#abortRequestSuccessCallback', function () {
    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it('should open popup', function () {
      App.HostPopup.abortRequestSuccessCallback(null, null, {
        requestName: 'name',
        serviceInfo: Em.Object.create()
      });
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#abortRequestErrorCallback', function () {
    var popup = App.HostPopup;
    beforeEach(function () {
      sinon.stub(App.ajax, 'get', function(k) {
        if (k === 'modalPopup') return null;
        return Em.get(App, k);
      });
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      App.ajax.get.restore();
    });
    it('should open popup', function () {
      popup.abortRequestErrorCallback({
        responseText: {
          message: 'message'
        },
        status: 404
      }, 'status', 'error', {
        url: 'url'
      }, {
        requestId: 0,
        serviceInfo: Em.Object.create()
      });
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
    statusCases.forEach(function (item) {
      it('should set serviceInfo.isAbortable to' + item.result + ' if status is ' + item.status, function () {
        popup.abortRequestErrorCallback({
          responseText: {
            message: 'message'
          },
          status: 404
        }, 'status', 'error', {
          url: 'url'
        }, {
          requestId: 0,
          serviceInfo: Em.Object.create({
            status: item.status
          })
        });
        expect(App.HostPopup.isAbortableByStatus(item.status)).to.equal(item.result);
      });
    });
  });

});

});

;require.register("test/utils/lazy_loading_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var lazyLoading = require('utils/lazy_loading');

describe('lazy_loading', function () {

  describe('#run()', function () {
    var context = Em.Object.create({isLoaded: false});
    var options = {
      destination: [],
      source: [{'test':'test'}],
      context: context
    };
    it('load one item', function () {
      lazyLoading.run(options);
      expect(options.destination[0]).to.eql(options.source[0]);
      expect(context.get('isLoaded')).to.equal(true);
    });

    var testsInfo = [
      {
        title: 'load 11 item with initSize - 11',
        result: true,
        initSize: 11,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {
        title: 'load 11 item with initSize - 12',
        result: true,
        initSize: 12,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {//items will be completely loaded on next iteration of pushing chunk
        title: 'load 11 item with initSize - 10',
        result: false,
        initSize: 10,
        destinationLength: 10,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create({isLoaded: false})
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        lazyLoading.run(test);
        expect(test.destinationLength).to.equal(test.destination.length);
        expect(test.context.get('isLoaded')).to.equal(test.result);
      });
    });
  });

  describe('#divideIntoChunks()', function () {
    var testsInfo = [
      {
        title: 'load 11 item with chunkSize - 3',
        chunkSize: 3,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}], [{i:4}, {i:5}, {i:6}], [{i:7}, {i:8}, {i:9}], [{i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 0',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 1',
        chunkSize: 1,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}], [{i:2}], [{i:3}], [{i:4}], [{i:5}], [{i:6}], [{i:7}], [{i:8}], [{i:9}], [{i:10}], [{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 11',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        var chunks = lazyLoading.divideIntoChunks(test.source, test.chunkSize);
        expect(chunks).to.eql(test.chunks);
      });
    });
  });

  describe("#pushChunk()", function() {
    beforeEach(function () {
      this.clock = sinon.useFakeTimers();
      sinon.spy(lazyLoading, 'pushChunk');
    });
    afterEach(function () {
      this.clock.restore();
      lazyLoading.pushChunk.restore();
    });
    it("last chunk", function() {
      this.clock = sinon.useFakeTimers();

      var destination = [],
          chunks = [[1]],
          context = Em.Object.create(),
          instance = {
            context: context,
            timeoutRef: null,
            terminate: Em.K
          };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      this.clock.tick(10);
      expect(destination[0]).to.equal(1);
      expect(context.get('isLoaded')).to.be.true;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
    it("two chunks", function() {
      this.clock = sinon.useFakeTimers();
      var destination = [],
        chunks = [[1], [2]],
        context = Em.Object.create(),
        instance = {
          context: context,
          timeoutRef: null,
          terminate: Em.K
        };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      this.clock.tick(20);
      expect(destination.length).to.equal(2);
      expect(context.get('isLoaded')).to.be.true;
      expect(lazyLoading.pushChunk.calledTwice).to.be.true;
    });
    it("terminated chunks", function() {
      this.clock = sinon.useFakeTimers();
      var destination = [],
        chunks = [[1]],
        context = Em.Object.create({isLoaded: false}),
        instance = {
          context: context,
          timeoutRef: null,
          terminate: Em.K
        };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      clearTimeout(instance.timeoutRef);
      this.clock.tick(10);
      expect(destination.length).to.empty;
      expect(context.get('isLoaded')).to.be.false;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
  });

  describe("#terminate()", function() {
    before(function () {
      sinon.spy(lazyLoading, 'pushChunk');
      this.clock = sinon.useFakeTimers();
    });
    after(function () {
      lazyLoading.pushChunk.restore();
      this.clock.restore();
    });
    it("loading terminated", function() {
      var context = Em.Object.create({isLoaded: false});
      var options = {
        destination: [],
        source: [1, 2],
        delay: 10,
        chunkSize: 1,
        initSize: 1,
        context: context
      };

      var ll = lazyLoading.run(options);
      lazyLoading.terminate(ll);
      this.clock.tick(10);
      expect(options.destination.length).to.equal(1);
      expect(context.get('isLoaded')).to.be.false;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
  });
});

});

;require.register("test/utils/misc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var misc = require('utils/misc');

describe('misc', function () {

  describe('#formatBandwidth', function () {
    var tests = Em.A([
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to <1KB',i:'0',e:'<1KB'},
      {m:'1000 to <1KB',i:'1000',e:'<1KB'},
      {m:'1024 to 1.0KB',i:'1024',e:'1.0KB'},
      {m:'2048 to 2.0KB',i:'2048',e:'2.0KB'},
      {m:'1048576 to 1.0MB',i:'1048576',e:'1.0MB'},
      {m:'1782579 to 1.7MB',i:'1782579',e:'1.7MB'},
      {m:'1546188226 to 1.44GB',i:'1546188226',e:'1.44GB'}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.formatBandwidth(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN' + ' ', function () {
      expect(isNaN(misc.formatBandwidth(NaN))).to.equal(true);
    });
  });

  describe('#ipToInt', function () {
    var tests = Em.A([
      {m:'0.0.0.0 to 0',i:'0.0.0.0',e:0},
      {m:'255.255.255.255 to 4294967295',i:'255.255.255.255',e:4294967295},
      {m:'"" to false',i:'',e:false},
      {m:'255.255.255.256 to false',i:'255.255.255.256',e:false},
      {m:'255.255.255 to false',i:'255.255.255',e:false}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.ipToInt(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#sortByOrder', function() {
    var tests = Em.A([
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, Em.Object.create({id:'c'})],
        e: [{id:'b'}, Em.Object.create({id:'c'}), {id:'a'}],
        m: 'Array with Ember and native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, {id:'c'}],
        e: [{id:'b'}, {id:'c'}, {id:'a'}],
        m: 'Array with native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [Em.Object.create({id:'a'}), Em.Object.create({id:'b'}), Em.Object.create({id:'c'})],
        e: [Em.Object.create({id:'b'}), Em.Object.create({id:'c'}), Em.Object.create({id:'a'})],
        m: 'Array with Ember objects'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(misc.sortByOrder(test.sortOrder, test.array)).to.eql(test.e);
      });
    });
  });

  describe('#xmlToObject()', function(){
    var xml = '<!-- Edited by XMLSpy -->'+
      '<stacks name="HDP-2.1">'+
      '<service>'+
      '<name>NAGIOS</name>'+
      '<name>OOZIE</name>'+
      '<name>HDFS</name>'+
      '<component>NAGIOS_SERVER</component>'+
      '</service>'+
      '</stacks>';
    xml = new DOMParser().parseFromString(xml,"text/xml");
    var converted = misc.xmlToObject(xml);
    it('should be an object', function(){
      expect(converted).to.a('object');
    });
    it('`attribute` name should be present', function(){
      expect(converted.stacks).to.ok;
    });
    it('`stacks.service.name` should be an array', function() {
      expect(converted.stacks.service.name).to.a('array');
    });
  });

});

});

;require.register("test/utils/number_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var numberUtils = require('utils/number_utils');

describe('utils/number_utils', function() {

  describe('#bytesToSize', function() {

    describe('check bytes', function() {
      var tests = Em.A([
        {
          bytes: null,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is null'
        },
        {
          bytes: undefined,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is undefined'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: null,
          e: '0 Bytes',
          m: '0 if multiply is `null`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: undefined,
          e: '200 Bytes',
          m: '"200 Bytes" if `multiplyBy` and `parseType` are `undefined`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: 1,
          e: '200 Bytes',
          m: '`200 Bytes` if `parsetype` is `undefined`'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy)).to.equal(test.e);
        });
      });
    });

    describe('check sizes', function() {
      var tests = Em.A([
        {
          bytes: 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'Bytes',
          m: 'Bytes'
        },
        {
          bytes: 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'KB',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'MB',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'GB',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'TB',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'PB',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).endsWith(test.e)).to.equal(true);
        });
      });
    });

    describe('check calculated result', function() {
      var tests = Em.A([
        {
          bytes: 42,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '42',
          m: 'Bytes'
        },
        {
          bytes: 1024 * 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '12',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 * 23,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '23',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 34,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '34',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 45,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '45',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 * 56,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '56',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).startsWith(test.e)).to.equal(true);
        });
      });
    });

  });
  describe('#validateInteger()', function() {
    var tests = [
      {
        str: null,
        min: null,
        max: null,
        m: 'all params null to' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.empty')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1abc",
        min: null,
        max: null,
        m: 'try to validate `1abc` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1",
        min: null,
        max: null,
        m: 'try to validate `1` should return ' + Em.I18n.t('number.validate.moreThanMaximum').format(null),
        e: Em.I18n.t('number.validate.moreThanMaximum').format(null)
      },
      {
        str: "1",
        min: 2,
        max: 0,
        m: 'try to validate `1` with max = 0 and min = 2 should return ' + Em.I18n.t('number.validate.lessThanMinumum').format(2),
        e: Em.I18n.t('number.validate.lessThanMinumum').format(2)
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function(){
        expect(numberUtils.validateInteger(test.str, test.min, test.max)).to.eql(test.e);
      });
    });
  });

  describe('#getCardinalityValue()', function() {
    var generateTestObject = function(cardinality, isMax, expected) {
      return {
        cardinality: cardinality,
        isMax: isMax,
        e: expected
      }
    };
    var tests = [
      generateTestObject(null, true, 0),
      generateTestObject(undefined, true, 0),
      generateTestObject('1', true, 1),
      generateTestObject('1', false, 1),
      generateTestObject('0+', true, Infinity),
      generateTestObject('0+', false, 0),
      generateTestObject('1+', true, Infinity),
      generateTestObject('1-2', false, 1),
      generateTestObject('1-2', true, 2),
      generateTestObject('ALL', true, Infinity),
      generateTestObject('ALL', false, Infinity)
    ];
    var message = 'cardinality `{0}`. {1} value should be {2}';
    tests.forEach(function(test) {
      it(message.format('' + test.cardinality, (test.isMax ? 'maximum' : 'minimum'), test.e), function() {
        expect(numberUtils.getCardinalityValue(test.cardinality, test.isMax)).to.be.eql(test.e);
      });
    })
  });
});
});

;require.register("test/utils/object_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var objectUtils = require('utils/object_utils');

describe('utils/object_utils', function() {
  describe('#recursiveTree()', function() {
    var testObj = {
      a1: {
        a2: 'v1',
        a3: {
          a4: {
            a5: {
              a6: 'v2',
              a7: 'v3'
            }
          }
        }
      }
    };
    it('should return correct tree of childs', function(){
      var result = objectUtils.recursiveTree(testObj);
      expect(result).to.eql('a2 (/a1)<br/>a5 (/a1/a3/a4)<br/>');
    });

    it('should return `null` if type missed', function() {
      var result = objectUtils.recursiveTree('{ a1: "v1"}');
      expect(result).to.be.null;
    });
  });
  describe('#recursiveKeysCount()', function() {
    var tests = [
      {
        m: 'should return 1 child',
        e: 3,
        obj: {
          a1: {
            a2: 'v1',
            a3: 'v2',
            a4: {
              a5: 'v3'
            }
          }
        }
      },
      {
        m: 'should return 1 childs',
        e: 1,
        obj: {
          a1: 'c1'
        }
      },
      {
        m: 'should return `null`',
        e: null,
        obj: 'a1'
      }
    ];
    tests.forEach(function(test){
      it(test.m, function() {
        expect(objectUtils.recursiveKeysCount(test.obj)).to.be.eql(test.e);
      });
    });
  });
});

});

;require.register("test/utils/string_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var string_utils = require('utils/string_utils');
require('utils/helper');

describe('string_utils', function () {

  describe('#underScoreToCamelCase', function () {
    var tests = [
      {m:'a_b_c to aBC',i:'a_b_c',e:'aBC'},
      {m:'a_bc to aBc',i:'a_bc',e:'aBc'},
      {m:'ab_c to abC',i:'ab_c',e:'abC'},
      {m:'_b_c to BC',i:'_b_c',e:'BC'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.underScoreToCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#pad', function () {
    var tests = [
      {m: '"name" to "    name"', i: 'name', l: 8, a: 1, f: ' ', e: '    name'},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 2, f: ' ', e: 'name    '},
      {m: '"name" to "  name  "', i: 'name', l: 8, a: 3, f: ' ', e: '  name  '},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 0, f: ' ', e: 'name    '},
      {m: '"name" to "name    "', i: 'name', l: 8, a:-1, f: ' ', e: 'name    '},
      {m: '"name" to "name"', i: 'name', l: 4, a: 1, f: ' ', e: 'name'},
      {m: '"name" to "||||||||name"', i: 'name', l: 8, a:1, f: '||', e: '||||||||name'},
      {m: '"name" to "||||name||||"', i: 'name', l: 8, a:3, f: '||', e: '||||name||||'},
      {m: '"name" to "name||||||||"', i: 'name', l: 8, a:2, f: '||', e: 'name||||||||'},
      {m: '"name" to "name" `str` param passed only', i: 'name', e: 'name'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.pad(test.i, test.l, test.f, test.a)).to.equal(test.e);
      });
    });
  });

  describe('#compareVersions', function () {
    var tests = [
      {m: '1.2 equal to 1.2', v1:'1.2', v2:'1.2', e: 0},
      {m: '1.2 lower than 1.3', v1:'1.2', v2:'1.3', e: -1},
      {m: '1.3 higher than 1.2', v1:'1.3', v2:'1.2', e: 1},
      {m: '1.2.1 higher than 1.2', v1:'1.2.1', v2:'1.2', e: 1},
      {m: '11.2 higher than 2.2', v1:'11.2', v2:'2.2', e: 1},
      {m: '0.9 higher than 0.8', v1:'0.9', v2:'0.8', e: 1},
      {m: 'return false if no string passed', v1: '0.9', e: -1}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.compareVersions(test.v1, test.v2)).to.equal(test.e);
      });
    });
  });

  describe('#isSingleLine', function () {
    var tests = [
      {m: 'is single line text', t: 'a b', e: true},
      {m: 'is single line text', t: 'a b\n', e: true},
      {m: 'is single line text', t: '\na b', e: true},
      {m: 'is not single line text', t: 'a\nb', e: false}
    ];
    tests.forEach(function(test) {
      it(test.t + ' ' + test.m + ' ', function () {
        expect(string_utils.isSingleLine(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#arrayToCSV', function() {
    var test = [{a: 1, b:2, c:3}, {a: 1, b:2, c:3}, {a: 1, b:2, c:3}];
    it('array of object to csv-string', function () {
      expect(string_utils.arrayToCSV(test)).to.equal("1,2,3\n1,2,3\n1,2,3\n");
    });
  });

  describe('#getFileFromPath', function() {
    var tests = [
      {t: undefined, e: ''},
      {t: {}, e: ''},
      {t: [], e: ''},
      {t: '', e: ''},
      {t: function(){}, e: ''},
      {t: '/path/to/file.ext', e: 'file.ext'},
      {t: 'file.ext', e: 'file.ext'},
      {t: 'file', e: 'file'},
      {t: '/path/to/file', e: 'file'}
    ];
    tests.forEach(function(test) {
      it('Check ' + typeof test.t, function () {
        expect(string_utils.getFileFromPath(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#getPath', function() {
      var tests = [
        {t: undefined, e: ''},
        {t: {}, e: ''},
        {t: [], e: ''},
        {t: '', e: ''},
        {t: function(){}, e: ''},
        {t: '/path/to/filename', e: '/path/to'},
        {t: '/path/to/', e: '/path/to'},
        {t: '/filename', e: '/'},
        {t: 'filename', e: ''},
        {t: '/path/', e: '/path'},
        {t: 'filename/', e: ''}
      ];
      tests.forEach(function(test) {
          it('Check ' + typeof test.t, function () {
            expect(string_utils.getPath(test.t)).to.equal(test.e);
          });
      });
  });

  describe('#getCamelCase', function () {
    var tests = [
      {i:'a',e:'A'},
      {i:'aB',e:'Ab'},
      {i:'a b',e:'A B'},
      {i:'a.b',e:'A.B'},
      {i:'a,b',e:'A,B'},
      {i:'a;b',e:'A;B'},
      {i:'a. b',e:'A. B'},
      {i:'a   b',e:'A   B'},
      {i:'aaa. bbb',e:'Aaa. Bbb'},
      {i:'aAA. bBB',e:'Aaa. Bbb'},
      {i:'STARTING',e:'Starting'},
      {i:'starting',e:'Starting'},
      {i:'starting,ending',e:'Starting,Ending'},
      {i: null, e: null},
      {i: undefined, e: undefined}
    ];
    tests.forEach(function(test) {
      it(test.i + ' to ' + test.e + ' ', function () {
        expect(string_utils.getCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#findIn', function () {
    var tests = [
      {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 1,
        e: null
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: '12'
          }
        },
        key: 'a',
        index: 1,
        e: '11'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 2,
        e: '22'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'g',
        index: 0,
        e: null
      }
    ];
    tests.forEach(function(test) {
      it(test.key + ' @ ' + test.index + ' = ' + test.e, function () {
        expect(test.key.findIn(test.obj, test.index)).to.equal(test.e);
      });
    });
  });
});

});

;require.register("test/utils/ui_effects_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ui_utils = require('utils/ui_effects');
var App = require('app');

describe('utils/ui_effects', function(){
  describe('#pulsate()', function(){
    beforeEach(function(){
      $('body').append('<div id="pulsate-test-dom"></div>');
      this.clock = sinon.useFakeTimers();
    });

    it('opacity should be 0.2 on 5-th iteration', function() {
      var domEl = $('#pulsate-test-dom');
      ui_utils.pulsate(domEl, 1000);
      this.clock.tick(300);
      expect(parseFloat(domEl.css('opacity')).toFixed(1)).to.eql('0.2');
    });
    it('should call callback at the end', function() {
      var domEl = $('#pulsate-test-dom');
      var stub = sinon.stub();
      ui_utils.pulsate(domEl, 1000, stub);
      this.clock.tick(2000);
      expect(stub.calledOnce).to.be.ok;
    });

    afterEach(function(){
      $('#pulsate-test-dom').remove();
      this.clock.restore();
    });
  });
});

});

;require.register("test/utils/updater_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/updater');
describe('utils/updater', function() {
  describe('#App.updater', function() {
    beforeEach(function() {
      this.clock = sinon.useFakeTimers();
    });

    var tests = {
      t1: {
        obj: Em.Object.create({
          method: sinon.spy(),
          isWorking: true
        }),
        m: 'method called once with default interval in 15 000 ms'
      },
      t2: {
        obj: Em.Object.create({
          method: function() {}
        }),
        m: 'should return false if key name is invalid or absent'
      },
      t3: {
        obj: Em.Object.create({
          method2: sinon.spy(),
          isWorking: true
        }),
        m: 'method should be called immediately'
      },
      t4: {
        obj: Em.Object.create({
          method3: sinon.spy(),
          isWorking: true
        }),
        m: 'method call should be ignored if `isWorking` set to false'
      }
    };

    it(tests.t1.m, function() {
      App.updater.run(tests.t1.obj, 'method', 'isWorking');
      this.clock.tick(15000);
      expect(tests.t1.obj.method.called).to.be.ok;
    });

    it(tests.t2.m, function() {
      var methodCall = App.updater.run(tests.t2.obj, 'method', 'isWorking');
      expect(methodCall).to.be.false;
    });

    it(tests.t3.m, function() {
      App.updater.run(tests.t3.obj, 'method2', 'isWorking');
      App.updater.immediateRun('method2');
      expect(tests.t3.obj.method2.called).to.be.ok;
    });

    it(tests.t4.m, function() {
      App.updater.run(tests.t4.obj, 'method3', 'isWorking');
      this.clock.tick(10000);
      tests.t4.obj.set('isWorking', false);
      this.clock.tick(5000);
      expect(tests.t4.obj.method3.called).to.be.false;
    });


    afterEach(function() {
      this.clock.restore();
    });
  });
});

});

;require.register("test/utils/validator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var validator = require('utils/validator');

describe('validator', function () {

  describe('#isValidEmail(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidEmail(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidEmail('')).to.equal(false);
    });
    it('should return false if value is "a.com"', function () {
      expect(validator.isValidEmail('a.com')).to.equal(false);
    });
    it('should return false if value is "@a.com"', function () {
      expect(validator.isValidEmail('@a.com')).to.equal(false);
    });
    it('should return false if value is "a@.com"', function () {
      expect(validator.isValidEmail('a@.com')).to.equal(false);
    });
    it('should return true if value is "a@a.com"', function () {
      expect(validator.isValidEmail('a@a.com')).to.equal(true);
    });
    it('should return true if value is "user@a.b.com"', function () {
      expect(validator.isValidEmail('user@a.b.com')).to.equal(true);
    })
  });

  describe('#isValidInt(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidInt(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidInt('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidInt('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidInt('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidInt(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidInt('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidInt('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidInt('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidInt('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    })
  });

  describe('#isValidFloat(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidFloat(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidFloat('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidFloat('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidFloat('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidFloat(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidFloat('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidFloat('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidFloat('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidFloat('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is "0.0"', function () {
      expect(validator.isValidFloat("0.0")).to.equal(true);
    });
    it('should return true if value is "10.123"', function () {
      expect(validator.isValidFloat("10.123")).to.equal(true);
    });
    it('should return true if value is "-10.123"', function () {
      expect(validator.isValidFloat("-10.123")).to.equal(true);
    });
    it('should return true if value is 10.123', function () {
      expect(validator.isValidFloat(10.123)).to.equal(true);
    });
    it('should return true if value is -10.123', function () {
      expect(validator.isValidFloat(-10.123)).to.equal(true);
    })

  });
  describe('#isIpAddress(value)', function () {
    it('"127.0.0.1" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.1')).to.equal(true);
    })
    it('"227.3.67.196" - valid IP', function () {
      expect(validator.isIpAddress('227.3.67.196')).to.equal(true);
    })
    it('"327.0.0.0" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0')).to.equal(false);
    })
    it('"127.0.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.0.')).to.equal(false);
    })
    it('"127.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.')).to.equal(false);
    })
    it('"127" - invalid IP', function () {
      expect(validator.isIpAddress('127')).to.equal(false);
    })
    it('"127.333.0.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.333.0.1')).to.equal(false);
    })
    it('"127.0.333.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.333.1')).to.equal(false);
    })
    it('"127.0.1.333" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.1.333')).to.equal(false);
    })
    it('"127.0.0.0:45555" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.0:45555')).to.equal(true);
    })
    it('"327.0.0.0:45555" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0:45555')).to.equal(false);
    })
  });

  describe('#isDomainName(value)', function () {
    it('"google.com" - valid Domain Name', function () {
      expect(validator.isDomainName('google.com')).to.equal(true);
    });
    it('"google" - invalid Domain Name', function () {
      expect(validator.isDomainName('google')).to.equal(false);
    });
    it('"123.123" - invalid Domain Name', function () {
      expect(validator.isDomainName('123.123')).to.equal(false);
    });
    it('"4goog.le" - valid Domain Name', function () {
      expect(validator.isDomainName('4goog.le')).to.equal(true);
    });
    it('"55454" - invalid Domain Name', function () {
      expect(validator.isDomainName('55454')).to.equal(false);
    })
  });

  describe('#hasSpaces()', function(){
    var testable = [
      { str: ' hello', detect: true },
      { str: 'hello world', detect: true },
      { str: 'hello ', detect: true },
      { str: 'hello', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detects spaces in `' + value.str + '`', function(){
        expect(validator.hasSpaces(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#isNotTrimmed', function(){
    var testable = [
      { str: ' hello world', detect: true },
      { str: ' hello world ', detect: true },
      { str: 'hello world ', detect: true },
      { str: 'hello world', detect: false },
      { str: 'hello world !', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + 'trimmed string', function() {
        expect(validator.isNotTrimmed(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#empty()', function(){
    var testable = [
      { obj: "", detect: true },
      { obj: 0, detect: true },
      { obj: "0", detect: true },
      { obj: null, detect: true },
      { obj: undefined, detect: true },
      { obj: 'hello', detect: false },
      { obj: {}, detect: false },
      { obj: [], detect: false },
      { obj: ['a'], detect: false },
      { obj: 1, detect: false },
      { obj: true, detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detect empty value in `' + new String(value.obj) + '`', function(){
        expect(validator.empty(value.obj)).to.eql(value.detect);
      });
    });
  });
  describe('#isValidUserName(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"root$" - invalid',i:'root$',e:false},
      {m:'"rootU" - invalid',i:'rootU',e:false},
      {m:'"rUoot" - invalid',i:'rUoot',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUserName(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidUNIXUser(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"abc_" - valid',i:'abc_',e:true},
      {m:'"_abc" - valid',i:'_abc',e:true},
      {m:'"abc_abc" - valid',i:'_abc',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUNIXUser(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidDataNodeDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true},
      {m:'"[ssd]/1a2b3c" - valid',i:'[ssd]/1a2b3c',e:true},
      {m:'"[DISK]/1a2b3c" - valid',i:'[DISK]/1a2b3c',e:true},
      {m:'"[] /1a2b3c" - invalid',i:'[] /1a2b3c',e:false},
      {m:'"[ssd] /1a2b3c" - invalid',i:'[ssd] /1a2b3c',e:false},
      {m:'"[/1a2b3c]" - invalid',i:'[/1a2b3c]',e:false},
      {m:'"[s]ss /sd" - invalid',i:'[s]ss /sd',e:false}


    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDataNodeDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isAllowedDir(value)', function() {
    var tests = [
      {m:'"/home" - not allowed',i:'/home',e:false},
      {m:'"/homes" - not allowed',i:'/homes',e:false},
      {m:'"/home/" - not allowed',i:'/home/',e:false},
      {m:'"/homes/" - not allowed',i:'/homes/',e:false},
      {m:'"/dir" - allowed',i:'/dir',e:true},
      {m:'"/dir/home" - allowed',i:'/dir/home',e:true},
      {m:'"/dir/homes" - allowed',i:'/dir/homes',e:true},
      {m:'"/dir/home/" - allowed',i:'/dir/home/',e:true},
      {m:'"/dir/homes/" - allowed',i:'/dir/homes/',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isAllowedDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidConfigKey(value)', function() {
    var tests = [
      {m:'"123" - valid',i:'123',e:true},
      {m:'"abc" - valid',i:'abc',e:true},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'".abc." - valid',i:'.abc.',e:true},
      {m:'"_abc_" - valid',i:'_abc_',e:true},
      {m:'"-abc-" - valid',i:'-abc-',e:true},
      {m:'"abc 123" - invalid',i:'abc 123',e:false},
      {m:'"a"b" - invalid',i:'a"b',e:false},
      {m:'"a\'b" - invalid',i:'a\'b',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidConfigKey(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidMatchesRegexp()', function() {
    var message = '`{0}` should be {1}',
      tests = [
        { value: '.*', expected: true },
        { value: '..', expected: true },
        { value: '.a1', expected: true },
        { value: '.*a1', expected: true },
        { value: '.*a1.*', expected: true },
        { value: '.*a1.a2', expected: true },
        { value: '.*a1.*.a2', expected: true },
        { value: '.*a1.*.a2.*.a3.a4.*.*', expected: true },
        { value: '*', expected: false },
        { value: '1>1', expected: false },
        //{ value: '.*a1,*', expected: false },
        { value: '?a1[1]asd[1]', expected: false },
        { value: 'a1[1]asd[1]', expected: true },
        { value: 'a1[1]asd[1][', expected: false },
        { value: 'a1[1|1]asd[1]', expected: true },
        { value: 'a1-2!', expected: true },
        { value: '|a1-2', expected: false },
        { value: '[a1', expected: false },
        { value: 'a{1}', expected: true },
        { value: 'a{1,2}', expected: true },
        { value: 'a{1,2}{', expected: false }
      ];
    tests.forEach(function(test) {
      it(message.format(test.value, (test.expected) ? 'valid' : 'not valid'), function() {
        expect(validator.isValidMatchesRegexp(test.value)).to.equal(test.expected);
      })
    });
  });
});

});

;require.register("test/views/application_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/application');

var view,
  modals = [],
  removed = false,
  events = [
      {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      key: 'Esc',
      html: '<div id="modal"><div class="modal-footer"><span class="close"></span></div></div>',
      particle: 'not ',
      length: 1
    }
  ];

describe.skip('App.ApplicationView', function () {

  before(function () {
    if($('#modal').length) {
      removed = true;
    }
    while($('#modal').length) {
      modals.push({
        modal: $('#modal'),
        parent: $('modal').parent()
      });
      $('#modal').remove();
    }
  });

  beforeEach(function () {
    view = App.ApplicationView.create({
      template: null
    });
  });

  afterEach(function () {
    $('#modal').remove();
  });

  after(function () {
    if (removed) {
      modals.forEach(function (item) {
        item.parent.append(item.modal);
      });
    }
  });

  describe('#didInsertElement', function () {
    events.forEach(function (item) {
      it('should ' + item.particle + 'close modal window on ' + item.key + ' press', function () {
        $('body').append(item.html);
        $('span').click(function () {
          $('#modal').remove();
        });
        view.didInsertElement();
        var e = $.Event(item.event);
        e.which = item.which;
        e.keyCode = item.keyCode;
        $(document).trigger(e);
        expect($('#modal')).to.have.length(item.length);
      });
    });
  });

});

});

;require.register("test/views/common/chart/linear_time_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/linear_time');

describe('App.ChartLinearTimeView', function () {

  var chartLinearTimeView = App.ChartLinearTimeView.create({});

  describe('#transformData ([[1, 2], [2, 3], [3, 4]], "abc")', function () {

    var data = [[1, 2], [2, 3], [3, 4]];
    var name = 'abc';
    var result = chartLinearTimeView.transformData(data, name);
    it('"name" should be "abc" ', function () {
      expect(result.name).to.equal('abc');
    });
    it('data size should be 3 ', function () {
      expect(result.data.length).to.equal(3);
    });
    it('data[0].x should be 2 ', function () {
      expect(result.data[0].x).to.equal(2);
    });
    it('data[0].y should be 1 ', function () {
      expect(result.data[0].y).to.equal(1);
    })
  }),
  describe('#yAxisFormatter', function() {
    var tests = [
      {m:'undefined to 0',i:undefined,e:0},
      {m:'NaN to 0',i:NaN,e:0},
      {m:'0 to 0',i:'0',e:'0'},
      {m:'1000 to 1K',i:'1000',e:'1K'},
      {m:'1000000 to 1M',i:'1000000',e:'1M'},
      {m:'1000000000 to 1B',i:'1000000000',e:'1B'},
      {m:'1000000000000 to 1T',i:'1000000000000',e:'1T'},
      {m:'1048576 to 1.049M',i:'1048576',e:'1.049M'},
      {m:'1073741824 to 1.074B',i:'1073741824',e:'1.074B'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.yAxisFormatter(test.i)).to.equal(test.e);
      });
    });
  }),
  describe('#checkSeries', function() {
    var tests = [
      {m:'undefined - false',i:undefined,e:false},
      {m:'NaN - false',i:NaN,e:false},
      {m:'object without data property - false',i:[{}],e:false},
      {m:'object with empty data property - false',i:[{data:[]}],e:false},
      {m:'object with invalid data property - false',i:[{data:[1]}],e:false},
      {m:'object with valid data property - true',i:[{data:[{x:1,y:1},{x:2,y:2}]}],e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.checkSeries(test.i)).to.equal(test.e);
      });
    });
  }),
  describe('#BytesFormatter', function() {
    var tests = [
      {m:'undefined to "0 B"',i:undefined,e:'0 B'},
      {m:'NaN to "0 B"',i:NaN,e:'0 B'},
      {m:'0 to "0 B"',i:0,e:'0 B'},
      {m:'124 to "124 B"',i:124,e:'124 B'},
      {m:'1024 to "1 KB"',i:1024,e:'1 KB'},
      {m:'1536 to "1 KB"',i:1536,e:'1.5 KB'},
      {m:'1048576 to "1 MB"',i:1048576,e:'1 MB'},
      {m:'1073741824 to "1 GB"',i:1073741824,e:'1 GB'},
      {m:'1610612736 to "1.5 GB"',i:1610612736,e:'1.5 GB'}
    ];

    tests.forEach(function(test) {
      it(test.m + ' ', function () {

        expect(App.ChartLinearTimeView.BytesFormatter(test.i)).to.equal(test.e);
      });
    });
  }),
  describe('#PercentageFormatter', function() {
    var tests = [
      {m:'undefined to "0 %"',i:undefined,e:'0 %'},
      {m:'NaN to "0 %"',i:NaN,e:'0 %'},
      {m:'0 to "0 %"',i:0,e:'0 %'},
      {m:'1 to "1%"',i:1,e:'1%'},
      {m:'1.12341234 to "1.123%"',i:1.12341234,e:'1.123%'},
      {m:'-11 to "-11%"',i:-11,e:'-11%'},
      {m:'-11.12341234 to "-11.123%"',i:-11.12341234,e:'-11.123%'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.PercentageFormatter(test.i)).to.equal(test.e);
      });
    });
  });
  describe('#TimeElapsedFormatter', function() {
    var tests = [
      {m:'undefined to "0 ms"',i:undefined,e:'0 ms'},
      {m:'NaN to "0 ms"',i:NaN,e:'0 ms'},
      {m:'0 to "0 ms"',i:0,e:'0 ms'},
      {m:'1000 to "1000 ms"',i:1000,e:'1000 ms'},
      {m:'120000 to "2 m"',i:120000,e:'2 m'},
      {m:'3600000 to "60 m"',i:3600000,e:'60 m'},
      {m:'5000000 to "1 hr"',i:5000000,e:'1 hr'},
      {m:'7200000 to "2 hr"',i:7200000,e:'2 hr'},
      {m:'90000000 to "1 d"',i:90000000,e:'1 d'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.TimeElapsedFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe("#getDataForAjaxRequest()", function() {
    var services = {
      yarnService: [],
      hdfsService: [],
      mapreduceService: []
    };
    beforeEach(function(){
      sinon.stub(App.HDFSService, 'find', function(){return services.hdfsService});
      sinon.stub(App.YARNService, 'find', function(){return services.yarnService});
      sinon.stub(App.MapReduceService, 'find', function(){return services.mapreduceService});
      sinon.stub(App, 'dateTime').returns(1000);
      chartLinearTimeView.set('timeUnitSeconds', 1);
      chartLinearTimeView.set('content', null);
    });
    afterEach(function(){
      App.HDFSService.find.restore();
      App.YARNService.find.restore();
      App.MapReduceService.find.restore();
      App.dateTime.restore();
    });

    it("content has hostName", function() {
      chartLinearTimeView.set('content', Em.Object.create({
        hostName: 'host1'
      }));
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: 0,
        stepSeconds: 15,
        hostName: 'host1',
        nameNodeName: '',
        jobTrackerNode: '',
        resourceManager: ''
      });
    });
    it("get Namenode host", function() {
      services.hdfsService = [
        Em.Object.create({
          nameNode: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: 0,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: 'host1',
        jobTrackerNode: '',
        resourceManager: ''
      });
      services.hdfsService = [];
    });
    it("get Namenode host HA", function() {
      services.hdfsService = [
        Em.Object.create({
          activeNameNode: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: 0,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: 'host1',
        jobTrackerNode: '',
        resourceManager: ''
      });
      services.hdfsService = [];
    });
    it("get jobTracker host", function() {
      services.mapreduceService = [
        Em.Object.create({
          jobTracker: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: 0,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: '',
        jobTrackerNode: 'host1',
        resourceManager: ''
      });
      services.mapreduceService = [];
    });
    it("get resourceManager host", function() {
      services.yarnService = [
        Em.Object.create({
          resourceManager: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: 0,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: '',
        jobTrackerNode: '',
        resourceManager: 'host1'
      });
      services.yarnService = [];
    });
  });
});

});

;require.register("test/views/common/configs/config_history_flow_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/config_history_flow');


describe.skip('App.ConfigHistoryFlowView', function () {

  var view = App.ConfigHistoryFlowView.create({
    controller: Em.Object.create({
      loadSelectedVersion: Em.K,
      onConfigGroupChange: Em.K,
      loadStep: Em.K
    }),
    displayedServiceVersion: Em.Object.create(),
    serviceVersions: []
  });

  describe('#isSaveDisabled', function () {
    var testCases = [
      {
        params: {
          isSubmitDisabled: false,
          versionLoaded: true
        },
        result: false
      },
      {
        params: {
          isSubmitDisabled: true,
          versionLoaded: true
        },
        result: true
      },
      {
        params: {
          isSubmitDisabled: false,
          versionLoaded: false
        },
        result: true
      },
      {
        params: {
          isSubmitDisabled: true,
          versionLoaded: false
        },
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it('isSubmitDisabled - ' + test.params.isSubmitDisabled + ', versionLoaded - ' + test.params.versionLoaded, function () {
        view.set('controller.isSubmitDisabled', test.params.isSubmitDisabled);
        view.set('controller.versionLoaded', test.params.versionLoaded);
        expect(view.get('isSaveDisabled')).to.equal(test.result);
      });
    });
  });

  describe('#showMoreLink', function () {
    var testCases = [
      {
        params: {
          count: 0
        },
        result: false
      },
      {
        params: {
          count: 100
        },
        result: false
      },
      {
        params: {
          count: 101
        },
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it('notes length - ' + test.params.count, function () {
        view.set('displayedServiceVersion', Em.Object.create({
          notes: new Array(test.params.count)
        }));
        expect(view.get('showMoreLink')).to.equal(test.result);
      });
    });
  });

  describe('#shortNotes', function () {
    it('notes length more than 100', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        notes: '12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123'
      }));
      expect(view.get('shortNotes')).to.equal('1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890...');
    });
    it('notes length less than 100', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        notes: 'notes'
      }));
      expect(view.get('shortNotes')).to.equal('notes');
    });
  });

  describe('#visibleServiceVersion', function () {
    var testCases = [
      {
        params: {
          startIndex: 0,
          serviceVersions: []
        },
        result: []
      },
      {
        params: {
          startIndex: 0,
          serviceVersions: [1, 2, 3]
        },
        result: [1, 2, 3]
      },
      {
        params: {
          startIndex: 0,
          serviceVersions: [1, 2, 3, 4, 5, 6, 7]
        },
        result: [1, 2, 3, 4, 5]
      },
      {
        params: {
          startIndex: 3,
          serviceVersions: [1, 2, 3, 4, 5, 6, 7]
        },
        result: [4, 5, 6, 7]
      }
    ];
    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.set('startIndex', test.params.startIndex);
        view.propertyDidChange('visibleServiceVersion');
        expect(view.get('visibleServiceVersion')).to.eql(test.result);
      });
    });
  });

  describe('#versionActionsDisabled', function () {
    it('versionLoaded is false', function () {
      view.set('controller.versionLoaded', false);
      expect(view.get('versionActionsDisabled')).to.be.true;
    });
    it('versionLoaded is true', function () {
      view.set('controller.versionLoaded', true);
      expect(view.get('versionActionsDisabled')).to.be.false;
    });
  });

  describe('#dropDownList', function () {
    var displayedServiceVersion = {version: 1};

    it('Only one service version is present', function () {
      view.set('serviceVersions', [displayedServiceVersion]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.be.empty;
    });
    it('Three service version', function () {
      view.set('serviceVersions', [displayedServiceVersion, {version: 2}, {version: 3}]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([{version: 3}, {version: 2}]);
    });
    it('Seven service version, showFullList is false', function () {
      view.set('serviceVersions', [
        displayedServiceVersion,
        {version: 2},
        {version: 3},
        {version: 4},
        {version: 5},
        {version: 6},
        {version: 7},
        {version: 8}
      ]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.set('showFullList', false);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([
        {version: 8},
        {version: 7},
        {version: 6},
        {version: 5},
        {version: 4},
        {version: 3}
      ]);
    });
    it('Seven service version, showFullList is true', function () {
      view.set('serviceVersions', [
        displayedServiceVersion,
        {version: 2},
        {version: 3},
        {version: 4},
        {version: 5},
        {version: 6},
        {version: 7},
        {version: 8}
      ]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.set('showFullList', true);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([
        {version: 8},
        {version: 7},
        {version: 6},
        {version: 5},
        {version: 4},
        {version: 3},
        {version: 2}
      ]);
    });
  });

  describe('#openFullList()', function () {
    it('', function () {
      var event = {
        stopPropagation: Em.K
      };
      sinon.spy(event, 'stopPropagation');
      view.openFullList(event);
      expect(event.stopPropagation.calledOnce).to.be.true;
      expect(view.get('showFullList')).to.be.true;
      event.stopPropagation.restore();
    });
  });

  describe('#hideFullList()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: new Array(0)
        },
        result: true
      },
      {
        params: {
          serviceVersions: new Array(6)
        },
        result: true
      },
      {
        params: {
          serviceVersions: new Array(7)
        },
        result: false
      }
    ];
    testCases.forEach(function (test) {
      it('notes length - ' + test.params.count, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.hideFullList();
        expect(view.get('showFullList')).to.equal(test.result);
      });
    });
  });

  describe('#didInsertElement()', function () {
    it('', function () {
      sinon.stub(App, 'tooltip');
      view.didInsertElement();
      expect(App.tooltip.calledOnce).to.be.true;
      App.tooltip.restore();
    });
  });

  describe('#willInsertElement()', function () {
    beforeEach(function () {
      sinon.stub(view, 'adjustFlowView', Em.K);
      sinon.stub(view, 'keepInfoBarAtTop', Em.K);
    });
    afterEach(function () {
      view.adjustFlowView.restore();
      view.keepInfoBarAtTop.restore();
    });
    it('Only current version is present', function () {
      view.set('serviceVersions', [Em.Object.create({isCurrent: true})]);

      view.willInsertElement();
      expect(view.adjustFlowView.calledOnce).to.be.true;
      expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      expect(view.get('startIndex')).to.equal(0);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true]);
    });
    it('Five service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({isCurrent: true}),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create()
      ]);

      view.willInsertElement();
      expect(view.adjustFlowView.calledOnce).to.be.true;
      expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      expect(view.get('startIndex')).to.equal(0);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true, false, false, false, false]);
    });
    it('Six service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({isCurrent: true}),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create()
      ]);

      view.willInsertElement();
      expect(view.adjustFlowView.calledOnce).to.be.true;
      expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      expect(view.get('startIndex')).to.equal(1);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true, false, false, false, false, false]);
    });
  });

  describe('#setInfoBarPosition()', function () {
    var testCases = [
      {
        params: {
          scrollTop: 0,
          defaultTop: 0
        },
        result: 'auto'
      },
      {
        params: {
          scrollTop: 1,
          defaultTop: 11
        },
        result: '10px'
      },
      {
        params: {
          scrollTop: 1,
          defaultTop: 0
        },
        result: '10px'
      }
    ];
    var infoBar = {
      css: Em.K
    };
    testCases.forEach(function (test) {
      it('scroll top - ' + test.params.scrollTop + ', default top - ' + test.params.defaultTop, function () {
        sinon.spy(infoBar, 'css');
        view.setInfoBarPosition(infoBar, test.params.defaultTop, test.params.scrollTop);
        expect(infoBar.css.calledWith('top', test.result)).to.be.true;
        infoBar.css.restore();
      });
    });
  });

  describe('#adjustFlowView()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: [Em.Object.create()],
          startIndex: 0
        },
        result: {
          first: [true],
          showLeftArrow: false,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 0
        },
        result: {
          first: [true, false, false, false, false],
          showLeftArrow: false,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 0
        },
        result: {
          first: [true, false, false, false, false, false],
          showLeftArrow: false,
          showRightArrow: true
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 1
        },
        result: {
          first: [false, true, false, false, false, false],
          showLeftArrow: true,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 1
        },
        result: {
          first: [false, true, false, false, false, false, false],
          showLeftArrow: true,
          showRightArrow: true
        }
      }
    ];

    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length, function () {
        view.set('startIndex', test.params.startIndex);
        view.set('serviceVersions', test.params.serviceVersions);

        view.adjustFlowView();
        expect(view.get('serviceVersions').mapProperty('first')).to.eql(test.result.first);
        expect(view.get('showLeftArrow')).to.eql(test.result.showLeftArrow);
        expect(view.get('showRightArrow')).to.eql(test.result.showRightArrow);
      });
    });
  });

  describe('#switchVersion()', function () {
    var event = {
      context: Em.Object.create({
        version: 2
      })
    };
    beforeEach(function(){
      sinon.stub(view, 'shiftFlowOnSwitch', Em.K);
      sinon.spy(view.get('controller'), 'loadSelectedVersion');
    });
    afterEach(function(){
      view.shiftFlowOnSwitch.restore();
      view.get('controller').loadSelectedVersion.restore();
    });
    it('Only one service version is present', function () {
      view.set('serviceVersions', [Em.Object.create({version: 2})]);
      view.switchVersion(event);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true]);
      expect(view.get('controller').loadSelectedVersion.calledWith(2)).to.be.true;
      expect(view.shiftFlowOnSwitch.calledWith(0)).to.be.true;
    });
    it('Two service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({version: 1}),
        Em.Object.create({version: 2})
      ]);
      view.switchVersion(event);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([false, true]);
      expect(view.get('controller').loadSelectedVersion.calledWith(2)).to.be.true;
      expect(view.shiftFlowOnSwitch.calledWith(1)).to.be.true;
    });
  });

  describe('#compare()', function () {
    it('should set compareServiceVersion', function () {
      sinon.spy(view.get('controller'), 'onConfigGroupChange');
      view.compare({context: Em.Object.create({version: 1})});

      expect(view.get('controller.compareServiceVersion')).to.eql(Em.Object.create({version: 1}));
      expect(view.get('controller').onConfigGroupChange.calledOnce).to.be.true;
      view.get('controller').onConfigGroupChange.restore();
    });
  });

  describe('#revert()', function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function (options) {
        options.onPrimary.call(Em.Object.create({
          serviceConfigNote: 'note',
          hide: Em.K
        }));
      });
      sinon.stub(view, 'sendRevertCall', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      view.sendRevertCall.restore();
    });
    it('context passed', function () {
      view.revert({context: Em.Object.create({
        version: 1,
        serviceName: 'S1'
      })});

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(view.sendRevertCall.calledWith(Em.Object.create({
        version: 1,
        serviceName: 'S1',
        serviceConfigNote: 'note'
      }))).to.be.true;
    });
    it('context is not passed', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        version: 1,
        serviceName: 'S1'
      }));
      view.revert({});

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(view.sendRevertCall.calledWith(Em.Object.create({
        version: 1,
        serviceName: 'S1',
        serviceConfigNote: 'note',
        notes: ''
      }))).to.be.true;
    });
  });

  describe('#sendRevertCall()', function () {
    it('', function () {
      sinon.stub(App.ajax, 'send', Em.K);
      view.sendRevertCall(Em.Object.create());

      expect(App.ajax.send.calledOnce).to.be.true;
      App.ajax.send.restore();
    });
  });

  describe('#sendRevertCallSuccess()', function () {
    it('', function () {
      sinon.spy(view.get('controller'), 'loadStep');
      view.sendRevertCallSuccess();

      expect(view.get('controller').loadStep.calledOnce).to.be.true;
      view.get('controller').loadStep.restore();
    });
  });

  describe('#save()', function () {
    it('', function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      view.save();

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      App.ModalPopup.show.restore();
    });
  });

  describe('#shiftBack()', function () {
    it('', function () {
      sinon.stub(view, 'decrementProperty', Em.K);
      sinon.stub(view, 'adjustFlowView', Em.K);
      view.shiftBack();

      expect(view.decrementProperty.calledWith('startIndex')).to.be.true;
      expect(view.adjustFlowView.calledOnce).to.be.true;
      view.adjustFlowView.restore();
      view.decrementProperty.restore();
    });
  });

  describe('#shiftForward()', function () {
    it('', function () {
      sinon.stub(view, 'incrementProperty', Em.K);
      sinon.stub(view, 'adjustFlowView', Em.K);
      view.shiftForward();

      expect(view.incrementProperty.calledWith('startIndex')).to.be.true;
      expect(view.adjustFlowView.calledOnce).to.be.true;
      view.adjustFlowView.restore();
      view.incrementProperty.restore();
    });
  });

  describe('#adjustFlowView()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: [],
          startIndex: 0,
          versionIndex: 1
        },
        result: {
          startIndex: 0,
          adjustFlowViewCall: false
        }
      },
      {
        params: {
          serviceVersions: new Array(6),
          startIndex: 7,
          versionIndex: 6
        },
        result: {
          startIndex: 1,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(12),
          startIndex: 7,
          versionIndex: 6
        },
        result: {
          startIndex: 6,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(12),
          startIndex: 0,
          versionIndex: 6
        },
        result: {
          startIndex: 6,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(6),
          startIndex: 0,
          versionIndex: 6
        },
        result: {
          startIndex: 1,
          adjustFlowViewCall: true
        }
      }
    ];

    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length + ', versionIndex - ' + test.params.versionIndex, function () {
        sinon.stub(view, 'adjustFlowView', Em.K);
        view.set('serviceVersions', test.params.serviceVersions);
        view.set('startIndex', test.params.startIndex);
        view.shiftFlowOnSwitch(test.params.versionIndex);

        expect(view.get('startIndex')).to.eql(test.result.startIndex);
        expect(view.adjustFlowView.calledOnce).to.eql(test.result.adjustFlowViewCall);
        view.adjustFlowView.restore();
      });
    });
  });
});

});

;require.register("test/views/common/configs/overriddenProperty_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/overriddenProperty_view');

describe('App.ServiceConfigView.SCPOverriddenRowsView', function () {

  var view = App.ServiceConfigView.SCPOverriddenRowsView.create();

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.spy(view, 'setSwitchText');
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      view.setSwitchText.restore();
      App.tooltip.restore();
    });

    it('setSwitchLinks method should be executed', function () {
      view.didInsertElement();
      expect(view.setSwitchText.calledOnce).to.be.true;
    });

  });

  describe('#setSwitchText', function () {

    var view = App.ServiceConfigView.SCPOverriddenRowsView.create({
      serviceConfigProperty: {
        overrides: [
          Em.Object.create({
            group: Em.Object.create({
              displayName: 'hcg',
              switchGroupTextShort: 'short',
              switchGroupTextFull: 'full'
            })
          })
        ]
      }
    });

    beforeEach(function () {
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      App.tooltip.restore();
    });

    it('should not modify overrides', function () {
      view.set('isDefaultGroupSelected', false);
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextShort')).to.equal('short');
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextFull')).to.equal('full');
    });

    it('should set switchGroupTextShort and switchGroupTextFull', function () {
      view.set('isDefaultGroupSelected', true);
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextShort')).to.equal(Em.I18n.t('services.service.config_groups.switchGroupTextShort').format('hcg'));
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextFull')).to.equal(Em.I18n.t('services.service.config_groups.switchGroupTextFull').format('hcg'));
    });

  });

});

});

;require.register("test/views/common/configs/services_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');


describe('App.ServiceConfigView', function () {
  var controller = App.WizardStep7Controller.create({
    selectedServiceObserver: function(){},
    switchConfigGroupConfigs: function(){}
  });
  var view = App.ServiceConfigView.create({
    controller: controller
  });
  var testCases = [
    {
      title: 'selectedConfigGroup is null',
      result: {
        'category1': false,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: null,
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: false}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'xml', canAddProperty: false})
        ]
      }
    },
    {
      title: 'selectedConfigGroup is default group',
      result: {
        'category1': true,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: {isDefault: true},
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'xml', canAddProperty: false})
        ]
      }
    }
  ];
  describe('#checkCanEdit', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('selectedService', test.selectedService);
        controller.set('selectedConfigGroup', test.selectedConfigGroup);
        view.checkCanEdit();
        controller.get('selectedService.configCategories').forEach(function (category) {
          expect(category.get('canAddProperty')).to.equal(test.result[category.get('name')]);
        });
      });
    });
  });
});

describe('App.ServiceConfigsByCategoryView', function () {

  var view = App.ServiceConfigsByCategoryView.create({
    serviceConfigs: []
  });

  var result = [1, 2, 3, 4];

  var testData = [
    {
      title: 'four configs in correct order',
      configs: [
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4})
      ]
    },
    {
      title: 'four configs in reverse order',
      configs: [
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'four configs in random order',
      configs: [
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2})
      ]
    },
    {
      title: 'four configs with no index',
      configs: [
        Em.Object.create({resultId: 1}),
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4})
      ]
    },
    {
      title: 'four configs but one with index',
      configs: [
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'index is null or not number',
      configs: [
        Em.Object.create({index: null, resultId: 3}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 'a', resultId: 4})
      ]
    },
    {
      title: 'four configs when indexes skipped',
      configs: [
        Em.Object.create({index: 88, resultId: 3}),
        Em.Object.create({index: 67, resultId: 2}),
        Em.Object.create({index: 111, resultId: 4}),
        Em.Object.create({index: 3, resultId: 1})
      ]
    }
  ];

  describe('#sortByIndex', function () {
    testData.forEach(function(_test){
      it(_test.title, function () {
        expect(view.sortByIndex(_test.configs).mapProperty('resultId')).to.deep.equal(result);
      })
    })
  });

  describe('#updateReadOnlyFlags', function () {
    it('if canEdit is true then isEditable flag of configs shouldn\'t be changed', function () {
      view.set('canEdit', true);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config1',
          isEditable: true
        }),
        Em.Object.create({
          name: 'config2',
          isEditable: false
        })
      ]);
      view.updateReadOnlyFlags();
      expect(view.get('serviceConfigs').findProperty('name', 'config1').get('isEditable')).to.equal(true);
      expect(view.get('serviceConfigs').findProperty('name', 'config2').get('isEditable')).to.equal(false);
    });
    it('if canEdit is false then configs shouldn\'t be editable', function () {
      view.set('canEdit', false);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config1',
          isEditable: true
        }),
        Em.Object.create({
          name: 'config2',
          isEditable: false
        })
      ]);
      view.updateReadOnlyFlags();
      expect(view.get('serviceConfigs').findProperty('name', 'config1').get('isEditable')).to.equal(false);
      expect(view.get('serviceConfigs').findProperty('name', 'config2').get('isEditable')).to.equal(false);
    });
    it('if canEdit is false then config overrides shouldn\'t be editable', function () {
      view.set('canEdit', false);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config',
          isEditable: true,
          overrides: [
            Em.Object.create({
              name: 'override1',
              isEditable: true
            }),
            Em.Object.create({
              name: 'override2',
              isEditable: false
            })
          ]
        })
      ]);
      view.updateReadOnlyFlags();
      var overrides = view.get('serviceConfigs').findProperty('name', 'config').get('overrides');
      expect(overrides.findProperty('name', 'override1').get('isEditable')).to.equal(false);
      expect(overrides.findProperty('name', 'override2').get('isEditable')).to.equal(false);
    });
    it('if canEdit is true then isEditable flag of overrides shouldn\'t be changed', function () {
      view.set('canEdit', true);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config',
          isEditable: true,
          overrides: [
            Em.Object.create({
              name: 'override1',
              isEditable: true
            }),
            Em.Object.create({
              name: 'override2',
              isEditable: false
            })
          ]
        })
      ]);
      view.updateReadOnlyFlags();
      var overrides = view.get('serviceConfigs').findProperty('name', 'config').get('overrides');
      expect(overrides.findProperty('name', 'override1').get('isEditable')).to.equal(true);
      expect(overrides.findProperty('name', 'override2').get('isEditable')).to.equal(false);
    })
  })
});

describe('App.ServiceConfigContainerView', function () {
  var view,
    selectedService = {
      configCategories: []
    };
  beforeEach(function () {
    view = App.ServiceConfigContainerView.create();
  });
  describe('#pushView', function () {
    it('shouldn\'t be launched before selectedService is set', function () {
      view.set('controller', {});
      view.pushView();
      expect(view.get('childViews')).to.be.empty;
    });
  });
  describe('#selectedServiceObserver', function () {
    it('should add a child view', function () {
      view.set('controller', {
        selectedService: {
          configCategories: []
        }
      });
      expect(view.get('childViews')).to.have.length(1);
    });
    it('should set controller for the view', function () {
      view.set('controller', {
        name: 'controller',
        selectedService: {
          configCategories: []
        }
      });
      expect(view.get('childViews.firstObject.controller.name')).to.equal('controller');
    });
    it('should add config categories', function () {
      view.set('controller', {
        selectedService: {
          configCategories: [Em.Object.create(), Em.Object.create()]
        }
      });
      expect(view.get('childViews.firstObject.serviceConfigsByCategoryView.childViews')).to.have.length(2);
    });
    it('shouldn\'t add category with custom view if capacitySchedulerUi isn\'t active', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'supports.capacitySchedulerUi') return false;
        return Em.get(App, k);
      });
      view.set('controller', {
        selectedService: {
          configCategories: [Em.Object.create({
            isCustomView: true
          })]
        }
      });
      expect(view.get('childViews.firstObject.serviceConfigsByCategoryView.childViews')).to.be.empty;
      App.get.restore();
    });
  });
});

});

;require.register("test/views/common/filter_combo_cleanable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;
describe('App.FilterComboCleanableView', function() {

  beforeEach(function() {
    view = App.FilterComboCleanableView.create();
  });

  describe('#didInsertElement', function() {

    it('should clean filter when created', function() {
      sinon.stub(App, 'popover', Em.K);
      view.setProperties({
        filter: 'some value',
        popoverDescription: ['', '']
      });
      view.didInsertElement();
      App.popover.restore();
      expect(view.get('filter')).to.be.empty;
    });

  });

});
});

;require.register("test/views/common/filter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var filters = require('views/common/filter_view');

describe('filters.getFilterByType', function () {


  describe('ambari-bandwidth', function () {

    var filter = filters.getFilterByType('ambari-bandwidth');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1GB',
        result: true
      },
      {
        condition: '1g',
        value: '1GB',
        result: true
      },
      {
        condition: '=1g',
        value: '1GB',
        result: true
      },
      {
        condition: '<1g',
        value: '0.9GB',
        result: true
      },
      {
        condition: '>1g',
        value: '1.1GB',
        result: true
      },
      {
        condition: '=1k',
        value: '1KB',
        result: true
      },
      {
        condition: '<1k',
        value: '0.9KB',
        result: true
      },
      {
        condition: '>1k',
        value: '1.1KB',
        result: true
      },
      {
        condition: '=1m',
        value: '1MB',
        result: true
      },
      {
        condition: '<1m',
        value: '0.9MB',
        result: true
      },
      {
        condition: '>1m',
        value: '1.1MB',
        result: true
      },
      {
        condition: '=1024k',
        value: '1MB',
        result: true
      },
      {
        condition: '=1024m',
        value: '1GB',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('duration', function () {

    var filter = filters.getFilterByType('duration');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1000',
        result: true
      },
      {
        condition: '1s',
        value: '1000',
        result: true
      },
      {
        condition: '=1s',
        value: '1000',
        result: true
      },
      {
        condition: '>1s',
        value: '1001',
        result: true
      },
      {
        condition: '<1s',
        value: '999',
        result: true
      },
      {
        condition: '=1m',
        value: '60000',
        result: true
      },
      {
        condition: '>1m',
        value: '60001',
        result: true
      },
      {
        condition: '<1m',
        value: '59999',
        result: true
      },
      {
        condition: '=1h',
        value: '3600000',
        result: true
      },
      {
        condition: '>1h',
        value: '3600001',
        result: true
      },
      {
        condition: '<1h',
        value: '3599999',
        result: true
      }

    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('date', function () {

    var filter = filters.getFilterByType('date');
    var currentTime = new Date().getTime();
    var testData = [
      {
        condition: 'Past 1 Day',
        value: currentTime - 86300000,
        result: true
      },
      {
        condition: 'Past 2 Days',
        value: currentTime - 172700000,
        result: true
      },
      {
        condition: 'Past 7 Days',
        value: currentTime - 604700000,
        result: true
      },
      {
        condition: 'Past 14 Days',
        value: currentTime - 1209500000,
        result: true
      },
      {
        condition: 'Past 30 Days',
        value: currentTime - 2591900000,
        result: true
      },
      {
        condition: 'Any',
        value: 'any value',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('number', function () {

    var filter = filters.getFilterByType('number');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1',
        result: true
      },
      {
        condition: '=1',
        value: '1',
        result: true
      },
      {
        condition: '<1',
        value: '0',
        result: true
      },
      {
        condition: '>1',
        value: '2',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('multiple', function () {

    var filter = filters.getFilterByType('multiple');
    var commonValue = [
      {componentName: 'DATANODE'},
      {componentName: 'NAMENODE'},
      {componentName: 'JOBTRACKER'}
    ];
    var testData = [
      {
        condition: 'DATANODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE,JOBTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'JOBTRACKER,TASKTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'TASKTRACKER',
        value: commonValue,
        result: false
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ((item.result) ? ' - match ' : ' - doesn\'t match ' + 'value: ') +
        item.value.mapProperty('componentName').join(" "), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('string', function () {

    var filter = filters.getFilterByType('string');

    var testData = [
      {
        condition: '',
        value: '',
        result: true
      },
      {
        condition: '',
        value: 'hello',
        result: true
      },
      {
        condition: 'hello',
        value: 'hello',
        result: true
      },
      {
        condition: 'HeLLo',
        value: 'hello',
        result: true
      },
      {
        condition: 'he',
        value: 'hello',
        result: true
      },
      {
        condition: 'lo',
        value: 'hello',
        result: true
      },
      {
        condition: 'lol',
        value: 'hello',
        result: false
      },
      {
        condition: 'hello',
        value: '',
        result: false
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ((item.result) ? ' - match ' : ' - doesn\'t match ' + 'value: ') + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });
});

});

;require.register("test/views/common/quick_link_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');

describe('App.QuickViewLinks', function () {

  var quickViewLinks = App.QuickViewLinks.create({});

  describe('#setProtocol', function() {
    var tests = [
      { serviceName: "GANGLIA", ambariProperties: { 'ganglia.https': true }, m: "https for ganglia", result: "https" },
      { serviceName: "GANGLIA", ambariProperties: { 'ganglia.https': false }, m: "http for ganglia 1", result: "http" },
      { serviceName: "GANGLIA", m: "http for ganglia 2", result: "http" },
      { serviceName: "NAGIOS", ambariProperties: { 'nagios.https': true }, m: "https for nagios", result: "https" },
      { serviceName: "NAGIOS", ambariProperties: { 'nagios.https': false }, m: "http for nagios", result: "http" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTPS_ONLY' }},
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': null }}
      ], m: "https for yarn", result: "https" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTP_ONLY' }},
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': null }}
      ], m: "http for yarn", result: "http" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTP_ONLY' }},
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': true }}
      ], m: "http for yarn (overrides hadoop.ssl.enabled)", result: "http" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTPS_ONLY' }},
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': false }}
      ], m: "https for yarn (overrides hadoop.ssl.enabled)", result: "https" },
      { serviceName: "YARN", configProperties: [
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': true }}
      ], m: "https for yarn by hadoop.ssl.enabled", result: "https" },
      { serviceName: "MAPREDUCE2", configProperties: [
        { type: 'mapred-site', properties: { 'mapreduce.jobhistory.http.policy': 'HTTPS_ONLY' }},
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': null }}
      ], m: "https for mapreduce2", result: "https" },
      { serviceName: "MAPREDUCE2", configProperties: [
        { type: 'mapred-site', properties: { 'mapreduce.jobhistory.http.policy': 'HTTP_ONLY' }},
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': null }}
      ], m: "http for mapreduce2", result: "http" },
      { serviceName: "MAPREDUCE2", configProperties: [
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': true }}
      ], m: "https for mapreduce2 by hadoop.ssl.enabled", result: "https" },
      { serviceName: "ANYSERVICE", configProperties: [
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': true }}
      ], m: "http for anyservice hadoop.ssl.enabled is true but doesn't support security", servicesSupportsHttps: [], result: "http" },
      { serviceName: "ANYSERVICE", configProperties: [
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': false }}
      ], m: "http for anyservice hadoop.ssl.enabled is false", servicesSupportsHttps: ["ANYSERVICE"], result: "http" },
      { serviceName: "ANYSERVICE", configProperties: [
        { type: 'core-site', properties: { 'hadoop.ssl.enabled': true }}
      ], m: "https for anyservice", servicesSupportsHttps: ["ANYSERVICE"], result: "https" }
    ];

    tests.forEach(function(t) {
      it(t.m, function() {
        quickViewLinks.set('servicesSupportsHttps', t.servicesSupportsHttps);
        expect(quickViewLinks.setProtocol(t.serviceName, t.configProperties, t.ambariProperties)).to.equal(t.result);
      });
    });
  });

  describe('#setPort', function () {
    var testData = [
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'http',
        'result': '8088',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'result': '8090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'result': '8090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      })
    ];

    testData.forEach(function(item) {
      it(item.service_id + ' ' + item.protocol, function () {
        expect(quickViewLinks.setPort(item, item.protocol, item.version)).to.equal(item.result);
      })
    },this);
  });

  describe('#setHost', function () {

    var quickViewLinks = App.QuickViewLinks.create({
        content: Em.Object.create()
      }),
      cases = [
        {
          singleNodeInstall: true,
          hosts: ['host0'],
          title: 'single node install'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'JOBTRACKER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host1'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HISTORYSERVER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host2'
                }
              }
            ]
          },
          serviceName: 'MAPREDUCE',
          hosts: ['host1', 'host2']
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'STORM_UI_SERVER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host3'
                }
              }
            ]
          },
          serviceName: 'STORM',
          hosts: ['host3']
        },
        {
          serviceName: 'PIG',
          hosts: [],
          title: 'client only service'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'ZOOKEEPER_SERVER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host4'
                }
              }
            ]
          },
          serviceName: 'ZOOKEEPER',
          hosts: ['host4'],
          setup: function () {
            quickViewLinks.set('content', {
              hostComponents: [
                Em.Object.create({
                  componentName: 'ZOOKEEPER_SERVER',
                  isMaster: true
                })
              ]
            });
          },
          title: 'service with master component, except HDFS, HBase, MapReduce, YARN and Storm'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host5'
                }
              }
            ]
          },
          serviceName: 'HDFS',
          hosts: ['host5'],
          setup: function () {
            quickViewLinks.set('content', {
              snameNode: true
            });
          },
          title: 'HDFS, HA disabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host6',
                  public_host_name: 'host6'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host7',
                  public_host_name: 'host7'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host8',
                  public_host_name: 'host8'
                }
              }
            ]
          },
          serviceName: 'HDFS',
          multipleMasters: true,
          hosts: ['host6', 'host7', 'host8'],
          setup: function () {
            quickViewLinks.set('content', {
              hostComponents: [
                Em.Object.create({
                  componentName: 'NAMENODE',
                  hostName: 'host6'
                }),
                Em.Object.create({
                  componentName: 'NAMENODE',
                  hostName: 'host7'
                }),
                Em.Object.create({
                  componentName: 'NAMENODE',
                  hostName: 'host8'
                })
              ],
              activeNameNode: {
                hostName: 'host6'
              },
              standbyNameNode: {
                hostName: 'host7'
              },
              standbyNameNode2: {
                hostName: 'host8'
              }
            });
          },
          title: 'HDFS, HA enabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host9'
                }
              }
            ]
          },
          serviceName: 'YARN',
          hosts: ['host9'],
          title: 'YARN, HA disabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host10',
                  public_host_name: 'host10'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host11',
                  public_host_name: 'host11'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host12',
                  public_host_name: 'host12'
                }
              }
            ]
          },
          serviceName: 'YARN',
          multipleMasters: true,
          hosts: ['host10', 'host11', 'host12'],
          setup: function () {
            quickViewLinks.set('content', {
              hostComponents: [
                Em.Object.create({
                  componentName: 'RESOURCEMANAGER',
                  hostName: 'host10'
                }),
                Em.Object.create({
                  componentName: 'RESOURCEMANAGER',
                  hostName: 'host11'
                }),
                Em.Object.create({
                  componentName: 'RESOURCEMANAGER',
                  hostName: 'host12'
                })
              ]
            });
          },
          title: 'YARN, HA enabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host13'
                }
              }
            ]
          },
          serviceName: 'HBASE',
          hosts: ['host13'],
          title: 'HBASE, single master component'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    },
                    metrics: {
                      hbase: {
                        master: {
                          IsActiveMaster: true
                        }
                      }
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host14',
                  public_host_name: 'host14'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    },
                    metrics: {
                      hbase: {
                        master: {
                          IsActiveMaster: false
                        }
                      }
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host15',
                  public_host_name: 'host15'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host16',
                  public_host_name: 'host16'
                }
              }
            ]
          },
          serviceName: 'HBASE',
          hosts: ['host14', 'host15', 'host16'],
          multipleMasters: true,
          title: 'HBASE, multiple master components'
        }
      ];

    before(function () {
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 'ZOOKEEPER',
            hasMaster: true
          }),
          Em.Object.create({
            serviceName: 'PIG',
            hasMaster: false
          })
        ];
      })
    });

    after(function () {
      App.StackService.find.restore();
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title || item.serviceName, function () {
        if (item.setup) {
          item.setup();
        }
        sinon.stub(App, 'get').withArgs('singleNodeInstall').returns(item.singleNodeInstall).
          withArgs('singleNodeAlias').returns('host0').
          withArgs('isRMHaEnabled').returns(item.multipleMasters).
          withArgs('supports.multipleHBaseMasters').returns(item.multipleMasters);
        if (item.multipleMasters) {
          expect(quickViewLinks.setHost(item.response, item.serviceName).mapProperty('publicHostName')).to.eql(item.hosts);
        } else {
          expect(quickViewLinks.setHost(item.response, item.serviceName)).to.eql(item.hosts);
        }
      });
    });

  });

});

});

;require.register("test/views/common/rolling_restart_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/rolling_restart_view');

describe('App.RollingRestartView', function () {

  var view = App.RollingRestartView.create({
    restartHostComponents: []
  });

  describe('#initialize', function () {
    var testCases = [
      {
        restartHostComponents: [],
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        restartHostComponents: new Array(10),
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        restartHostComponents: new Array(11),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      },
      {
        restartHostComponents: new Array(20),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.restartHostComponents.length + ' components to restart', function () {
        view.set('batchSize', -1);
        view.set('interBatchWaitTimeSeconds', -1);
        view.set('tolerateSize', -1);
        view.set('restartHostComponents', test.restartHostComponents);
        view.initialize();
        expect(view.get('batchSize')).to.equal(test.result.batchSize);
        expect(view.get('tolerateSize')).to.equal(test.result.tolerateSize);
      })
    }, this);
  });
});

});

;require.register("test/views/common/table_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/db');
require('views/common/filter_view');
require('views/common/sort_view');
require('mixins');
require('mixins/common/userPref');
require('views/common/table_view');

describe('App.TableView', function () {

  var view;

  beforeEach(function() {
    App.db.cleanUp();
  });

  afterEach(function() {
    App.db.cleanUp();
  });

  describe('#updatePaging', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should set "startIndex" to 0 if "filteredContent" is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('startIndex')).to.equal(0);
    });

    it('should set "startIndex" to 1 if "filteredContent" is not empty', function() {
      view.set('filteredContent', d3.range(1, 10));
      expect(view.get('startIndex')).to.equal(1);
    });

  });

  describe('#endIndex', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('endIndex')).to.equal(11);
    });

    it('should be recalculated if "displayLength" was changed', function() {
      view.set('displayLength', 5);
      expect(view.get('endIndex')).to.equal(5);
    });

    it('should be recalculated (but not changed) if "filteredContent" was changed (and "filterContent.length" is more than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('endIndex')).to.equal(endIndexBefore);
    });

    it('should be recalculated (and changed) if "filteredContent" was changed (and "filterContent.length" is less than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      var indx = 4;
      view.set('filteredContent', d3.range(1,indx));
      expect(view.get('endIndex')).to.not.equal(endIndexBefore);
      expect(view.get('endIndex')).to.equal(indx - 1);
    });

  });

  describe('#pageContent', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('pageContent').length).to.equal(9);
    });

    it('should be recalculated if "endIndex" was changed', function() {
      view.set('endIndex', 5);
      expect(view.get('pageContent').length).to.equal(5);
    });

    it('should be recalculated if "filteredContent" was changed', function() {
      var pageContentBefore = view.get('pageContent');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('pageContent').length).to.equal(pageContentBefore.length);
      expect(view.get('pageContent')).to.not.eql(pageContentBefore);
    });

  });

  describe('#clearFilters', function() {

    it('should set "filterConditions" to empty array', function() {
      view.clearFilters();
      expect(view.get('filterConditions')).to.eql([]);
    });

  });

  describe('#filtersUsedCalc', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "filtersUsed" to false if "filterConditions" is empty array', function() {
      view.set('filterConditions', []);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to false if each value in "filterConditions" is empty', function() {
      view.set('filterConditions', [{value:''}, {value:''}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to true if one or more values in "filterConditions" are not empty', function() {
      view.set('filterConditions', [{value:''}, {value:'lol'}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(true);
    });

  });

  describe('#nextPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "startIndex" if "filteredContent.length is greater than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex + displayLength);
    });

    it('should not set "startIndex" if "filteredContent.length is equal to "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 99;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

    it('should not set "startIndex" if "filteredContent.length is less than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 100;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

  });

  describe('#previousPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 50,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 60,
        filter: function() {}
      });
    });

    it('should set "startIndex" to 1', function() {
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(1);
    });

    it('should not set "startIndex" to 40', function() {
      view.set('startIndex', 50);
      var displayLength = 10;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(40);
    });

  });

});

});

;require.register("test/views/experimental_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/experimental');

var view,
  transition,
  supports = {},
  transitionStubbed = false,
  viewSupports = [
    Em.Object.create({
      name: 'sup0',
      selected: true
    }),
    Em.Object.create({
      name: 'sup1',
      selected: false
    })
  ],
  saveObject = {};

describe('App.ExperimentalView', function () {

  before(function () {
    viewSupports.forEach(function(item) {
      supports[item.get('name')] = item.get('selected');
    });
    sinon.stub(App, 'get', function(k) {
      if (k === 'supports') return supports;
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    view = App.ExperimentalView.create();
  });

  after(function () {
    App.get.restore();
  });

  describe('#supports', function () {
    it('should take data from App.supports', function () {
      expect(view.get('supports')).to.eql(viewSupports);
    });
  });

  describe('#doSave', function () {

    before(function () {
      sinon.stub(Ember, 'set', function (p, v) {
        if (p.indexOf('App.supports.' != -1)) {
          p = p.replace('App.supports.', '');
          saveObject[p] = v;
          return;
        }
        return Ember.set(p, v);
      });
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    after(function () {
      Em.set.restore();
      App.router.transitionTo.restore();
    });

    it('should pass data to App.supports', function () {
      view.set('supports', viewSupports);
      view.doSave();
      expect(saveObject).to.eql(supports);
    });

  });

});

});

;require.register("test/views/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/installer');

var view,
  stepsCount = 11,
  isStepDisabled = [],
  properties = [];

for (var i = 0; i < stepsCount; i++ ) {
  isStepDisabled.push(Em.Object.create({
    step: i,
    value: Boolean(Math.floor(Math.random() * 2))
  }));
  properties.push('isStep' + i + 'Disabled');
}

describe('App.InstallerView', function () {

  beforeEach(function () {
    view = App.InstallerView.create({
      controller: {
        isStepDisabled: isStepDisabled
      }
    });
  });

  properties.forEach(function (item, index) {
    describe(item, function () {
      it('should take value from isStepDisabled', function () {
        expect(view.get(item)).to.equal(isStepDisabled.findProperty('step', index).get('value'));
      });
    });
  });

});

});

;require.register("test/views/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/login');

var view,
  controller,
  pass;

describe('App.LoginView', function () {

  before(function () {
    sinon.stub(App, 'get', function(k) {
      if (k === 'router') return {
        login: Em.K
      };
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    view = App.LoginView.create();
    pass = view.passTextField.create({
      controller: App.LoginController.create()
    });
  });

  after(function () {
    App.get.restore();
  });

  describe('#passTextField', function () {
    it('should change error message', function () {
      pass.insertNewline();
      expect(pass.get('controller.errorMessage')).to.be.empty;
    });
  });

});

});

;require.register("test/views/main/charts/heatmap/heatmap_host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_host');

describe('App.MainChartsHeatmapHostView', function() {

  var view = App.MainChartsHeatmapHostView.create({
    templateName: '',
    controller: Em.Object.create(),
    content: {}
  });

  describe('#hostTemperatureStyle', function () {
    var testCases = [
      {
        title: 'if hostToSlotMap is null then hostTemperatureStyle should be empty',
        hostName: 'host',
        controller: Em.Object.create({
          hostToSlotMap: null,
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if hostName is null then hostTemperatureStyle should be empty',
        hostName: '',
        controller: Em.Object.create({
          hostToSlotMap: {},
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slot less than 0 then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": -1
          },
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions is null then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: null
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions length not more than slot number then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [{}]
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions correct then hostTemperatureStyle should be "style1"',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [
              Em.Object.create({cssStyle: 'style0'}),
              Em.Object.create({cssStyle: 'style1'})
            ]
          }
        }),
        result: 'style1'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content.hostName', test.hostName);
        view.set('controller', test.controller);
        expect(view.get('hostTemperatureStyle')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/views/main/charts/heatmap/heatmap_rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_rack');

describe('App.MainChartsHeatmapRackView', function() {

  var view = App.MainChartsHeatmapRackView.create({
    templateName: ''
  });

  describe('#hostCssStyle', function () {
    var testCases = [
      {
        title: 'if hosts haven\'t been loaded yet then hostCssStyle should be have width 100%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: false
        }),
        result: "width:100%;float:left;"
      },
      {
        title: 'if hosts number is zero then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      },
      {
        title: 'if hosts number is one then hostCssStyle should be have width 99.5%',
        rack: Em.Object.create({
          hosts: new Array(1),
          isLoaded: true
        }),
        result: "width:99.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 9.5%',
        rack: Em.Object.create({
          hosts: new Array(10),
          isLoaded: true
        }),
        result: "width:9.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(11),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('rack', test.rack);
        expect(view.get('hostCssStyle')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/config_history_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/config_history_view');

describe('App.MainConfigHistoryView', function() {
  var view = App.MainConfigHistoryView.create({
    controller: Em.Object.create({
      name: 'mainConfigHistoryController',
      paginationProps: [
        {
          name: 'displayLength'
        },
        {
          name: 'startIndex'
        }
      ],
      doPolling: Em.K,
      load: function () {
        return {done: Em.K};
      }
    }),
    filteredCount: 0
  });
  view.removeObserver('controller.resetStartIndex', view, 'resetStartIndex');

  describe('#pageContent', function() {
    beforeEach(function(){
      view.propertyDidChange('pageContent');
    });
    it('filtered content is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('pageContent')).to.be.empty;
    });
    it('filtered content contain one item', function() {
      view.set('filteredCount', 1);
      view.set('filteredContent', [Em.Object.create()]);

      expect(view.get('pageContent')).to.eql([Em.Object.create()]);
    });
    it('filtered content contain two unsorted items', function() {
      view.set('filteredCount', 2);
      view.set('filteredContent', [
        Em.Object.create({index:2}),
        Em.Object.create({index:1})
      ]);

      expect(view.get('pageContent')).to.eql([
        Em.Object.create({index:1}),
        Em.Object.create({index:2})
      ]);
    });
    it('filtered content contain three items, when two visible', function() {
      view.set('filteredCount', 2);
      view.set('filteredContent', [
        Em.Object.create({index:1}),
        Em.Object.create({index:2}),
        Em.Object.create({index:3})
      ]);

      expect(view.get('pageContent')).to.eql([
        Em.Object.create({index:1}),
        Em.Object.create({index:2})
      ]);
    });
  });
  describe('#updatePagination', function() {
    beforeEach(function () {
      sinon.stub(view, 'refresh', Em.K);
      sinon.stub(App.db, 'setDisplayLength', Em.K);
      sinon.stub(App.db, 'setStartIndex', Em.K);
    });
    afterEach(function () {
      view.refresh.restore();
      App.db.setStartIndex.restore();
      App.db.setDisplayLength.restore();
    });

    it('displayLength is correct', function() {
      view.set('displayLength', '50');
      view.set('startIndex', null);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.called).to.be.false;
      expect(App.db.setDisplayLength.calledWith('mainConfigHistoryController', '50')).to.be.true;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(0);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('50');
    });
    it('startIndex is correct', function() {
      view.set('displayLength', null);
      view.set('startIndex', 10);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.calledWith('mainConfigHistoryController', 10)).to.be.true;
      expect(App.db.setDisplayLength.called).to.be.false;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(10);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('50');
    });
    it('displayLength and startIndex are correct', function() {
      view.set('displayLength', '100');
      view.set('startIndex', 20);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.calledWith('mainConfigHistoryController', 20)).to.be.true;
      expect(App.db.setDisplayLength.calledWith('mainConfigHistoryController', '100')).to.be.true;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(20);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('100');
    });
    it('displayLength and startIndex are null', function() {
      view.set('displayLength', null);
      view.set('startIndex', null);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.called).to.be.false;
      expect(App.db.setDisplayLength.called).to.be.false;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(20);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('100');
    });
  });

  describe('#didInsertElement()', function() {
    it('', function() {
      sinon.stub(view, 'addObserver', Em.K);
      sinon.spy(view.get('controller'), 'doPolling');

      view.didInsertElement();
      expect(view.addObserver.calledTwice).to.be.true;
      expect(view.get('controller.isPolling')).to.be.true;
      expect(view.get('controller').doPolling.calledOnce).to.be.true;

      view.addObserver.restore();
      view.get('controller').doPolling.restore();
    });
  });

  describe('#willDestroyElement()', function() {
    it('', function() {
      view.willDestroyElement();
      expect(view.get('controller.isPolling')).to.be.false;
    });
  });

  describe('#updateFilter()', function() {
    beforeEach(function () {
      sinon.stub(view, 'saveFilterConditions', Em.K);
      sinon.stub(view, 'refresh', Em.K);
      sinon.spy(view, 'updateFilter');
    });
    afterEach(function () {
      view.saveFilterConditions.restore();
      view.updateFilter.restore();
      view.refresh.restore();
    });
    it('filteringComplete is false', function() {
      this.clock = sinon.useFakeTimers();

      view.set('filteringComplete', false);
      view.updateFilter(1, '', 'string');
      expect(view.get('controller.resetStartIndex')).to.be.false;
      expect(view.saveFilterConditions.calledWith(1, '', 'string', false)).to.be.true;
      view.set('filteringComplete', true);
      this.clock.tick(view.get('filterWaitingTime'));
      expect(view.updateFilter.calledWith(1, '', 'string')).to.be.true;
      this.clock.restore();
    });
    it('filteringComplete is true', function() {
      view.set('filteringComplete', true);

      view.updateFilter(1, '', 'string');
      expect(view.get('controller.resetStartIndex')).to.be.true;
      expect(view.refresh.calledOnce).to.be.true;
    });
  });

  describe('#refresh()', function() {
    it('', function() {
      sinon.spy(view.get('controller'), 'load');
      view.refresh();
      expect(view.get('filteringComplete')).to.be.false;
      expect(view.get('controller').load.calledOnce).to.be.true;
      view.get('controller').load.restore();
    });
  });

  describe('#resetStartIndex()', function() {
    it('resetStartIndex is false and filteredCount is 0', function() {
      view.set('filteredCount', 0);
      view.set('controller.resetStartIndex', false);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
    });
    it('resetStartIndex is true and filteredCount is 0', function() {
      view.set('filteredCount', 0);
      view.set('controller.resetStartIndex', true);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
    });
    it('resetStartIndex is false and filteredCount is 5', function() {
      view.set('filteredCount', 5);
      view.set('controller.resetStartIndex', false);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
    });
    it('resetStartIndex is true and filteredCount is 5', function() {
      view.set('controller.resetStartIndex', true);
      view.set('filteredCount', 5);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(1);
    });
  });

});

});

;require.register("test/views/main/dashboard/widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');

describe('App.DashboardWidgetView', function() {
  var dashboardWidgetView = App.DashboardWidgetView.create();

  describe('#viewID', function() {
    it('viewID is computed with id', function() {
      dashboardWidgetView.set('id', 5);
      expect(dashboardWidgetView.get('viewID')).to.equal('widget-5');
    });
  });

  describe('#hoverContentTopClass', function() {
    var tests = [
      {
        h: ['', ''],
        e: 'content-hidden-two-line',
        m: '2 lines'
      },
      {
        h: ['', '', ''],
        e: 'content-hidden-three-line',
        m: '3 lines'
      },
      {
        h: [''],
        e: '',
        m: '1 line'
      },
      {
        h: [],
        e: '',
        m: '0 lines'
      },
      {
        h: ['', '', '', '', ''],
        e: 'content-hidden-five-line',
        m: '5 lines'
      },
      {
        h: ['', '', '', ''],
        e: 'content-hidden-four-line',
        m: '4 lines'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        dashboardWidgetView.set('hiddenInfo', test.h);
        expect(dashboardWidgetView.get('hoverContentTopClass')).to.equal(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/datanode_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/datanode_live');

describe('App.DataNodeUpView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true
      }
    },
    {
      data: 0,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false
      }
    }
  ];

  tests.forEach(function(test) {
    describe('', function() {
      var dataNodeUpView = App.DataNodeUpView.create({model_type:null, data: test.data, content: test.data.toString()});
      it('isRed', function() {
        expect(dataNodeUpView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(dataNodeUpView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(dataNodeUpView.get('isGreen')).to.equal(test.e.isGreen);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_average_load_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_average_load');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseAverageLoadView', function() {

  var tests = [
    {
      model: {
        averageLoad: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        averageLoad: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        averageLoad: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        averageLoad: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable')
      }
    }
  ];

  tests.forEach(function(test) {
    describe('averageLoad - ' + test.model.averageLoad, function() {
      var hBaseAverageLoadView = App.HBaseAverageLoadView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseAverageLoadView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseAverageLoadView.get('data')).to.equal(test.model.averageLoad);
      });
      it('isRed', function() {
        expect(hBaseAverageLoadView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseAverageLoadView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseAverageLoadView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseAverageLoadView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_master_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_master_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseMasterUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        masterStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        masterStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        masterStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var hBaseMasterUptimeView = App.HBaseMasterUptimeView.create({model_type:null, model: test.model});
    hBaseMasterUptimeView.calc();
    describe('masterStartTime - ' + test.model.masterStartTime, function() {
      it('content', function() {
        expect(hBaseMasterUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseMasterUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(hBaseMasterUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseMasterUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseMasterUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseMasterUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_regions_in_transition_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widgets/hbase_regions_in_transition');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseRegionsInTransitionView', function() {

  var tests = [
    {
      model: {
        regionsInTransition: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        regionsInTransition: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        regionsInTransition: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        regionsInTransition: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: 'null'
      }
    }
  ];

  tests.forEach(function(test) {
    describe('regionsInTransition - ' + test.model.regionsInTransition, function() {
      var hBaseRegionsInTransitionView = App.HBaseRegionsInTransitionView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseRegionsInTransitionView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseRegionsInTransitionView.get('data')).to.equal(test.model.regionsInTransition);
      });
      it('isRed', function() {
        expect(hBaseRegionsInTransitionView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseRegionsInTransitionView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseRegionsInTransitionView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseRegionsInTransitionView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/jobtracker_rpc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/jobtracker_rpc');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.JobTrackerRpcView', function() {

  var tests = [
    {
      model: {
        jobTrackerRpc: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1.00 ms',
        data: '1.00'
      }
    },
    {
      model: {
        jobTrackerRpc: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10.00 ms',
        data: '10.00'
      }
    },
    {
      model: {
        jobTrackerRpc: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0 ms',
        data: 0
      }
    },
    {
      model: {
        jobTrackerRpc: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('jobTrackerRpc - ' + test.model.jobTrackerRpc, function() {
      var jobTrackerRpcView = App.JobTrackerRpcView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(jobTrackerRpcView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerRpcView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerRpcView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerRpcView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerRpcView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerRpcView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/jobtracker_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/jobtracker_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.JobTrackerUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        jobTrackerStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model: Em.Object.create({
        jobTrackerStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model: Em.Object.create({
        jobTrackerStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('jobTrackerStartTime - ' + test.model.jobTrackerStartTime, function() {
      var jobTrackerUptimeView = App.JobTrackerUptimeView.create({model_type:null, model: test.model});
      jobTrackerUptimeView.calc();
      it('content', function() {
        expect(jobTrackerUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/links_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host_component');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/links_widget');

describe('App.LinkDashboardWidgetView', function() {

  var model = Em.Object.create({
    field: Em.Object.create({
      publicHostName: 'host1'
    })
  });
  var linkDashboardWidgetView = App.LinkDashboardWidgetView.create({
    model_type: null,
    model: model,
    port: 1234,
    modelField: 'field'
  });
  linkDashboardWidgetView.calc();
  describe('#webUrl', function() {
    it('calc', function() {
      expect(linkDashboardWidgetView.get('webUrl')).to.equal('http://host1:1234');
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_cpu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('utils/helper');
require('views/common/chart/pie');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');
require('views/main/dashboard/widgets/namenode_cpu');

describe('App.NameNodeCpuPieChartView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var nameNodeCpuPieChartView = App.NameNodeCpuPieChartView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  nameNodeCpuPieChartView.calc();

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        cpuWio: 1,
        e: true,
        m: 'Exists'
      },
      {
        cpuWio: null,
        e: false,
        m: 'Not exists'
      },
      {
        cpuWio: undefined,
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('cpuWio', test.cpuWio);
        expect(nameNodeCpuPieChartView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function () {
    var tests = [
      {
        cpuWio: 0,
        e: ['0.0', '0.00'],
        m: 'Nothing is used'
      },
      {
        cpuWio: 100,
        e: ['100.0', '100.00'],
        m: 'All is used'
      },
      {
        cpuWio: 50,
        e: ['50.0', '50.00'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('cpuWio', test.cpuWio);
        expect(nameNodeCpuPieChartView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_rpc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_rpc');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeRpcView', function() {

  var tests = [
    {
      model: {
        nameNodeRpc: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1.00 ms',
        data: '1.00'
      }
    },
    {
      model: {
        nameNodeRpc: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10.00 ms',
        data: '10.00'
      }
    },
    {
      model: {
        nameNodeRpc: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0 ms',
        data: 0
      }
    },
    {
      model: {
        nameNodeRpc: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nameNodeRpc - ' + test.model.nameNodeRpc, function() {
      var jobTrackerRpcView = App.NameNodeRpcView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(jobTrackerRpcView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerRpcView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerRpcView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerRpcView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerRpcView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerRpcView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        nameNodeStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var nameNodeUptimeView = App.NameNodeUptimeView.create({model_type:null, model: test.model});
    nameNodeUptimeView.calc();
    describe('nameNodeStartTime - ' + test.model.nameNodeStartTime, function() {
      it('content', function() {
        expect(nameNodeUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nameNodeUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nameNodeUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nameNodeUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nameNodeUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nameNodeUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/node_managers_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/node_managers_live');

describe('App.NodeManagersLiveView', function() {

  var tests = [
    {
      model: {
        nodeManagersTotal: 3,
        nodeManagerLiveNodes: 2
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '2/3',
        data: 67
      }
    },
    {
      model: {
        nodeManagersTotal: 2,
        nodeManagerLiveNodes: 2
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '2/2',
        data: 100
      }
    },
    {
      model: {
        nodeManagersTotal: 2,
        nodeManagerLiveNodes: 0
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '0/2',
        data: 0.00
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nodeManagerNodes length - ' + test.model.nodeManagersTotal + ' | nodeManagerLiveNodes length - ' + test.model.nodeManagerLiveNodes, function() {
      var AppNodeManagersLiveView = App.NodeManagersLiveView.extend({nodeManagersLive: test.model.nodeManagerLiveNodes});
      var nodeManagersLiveView = AppNodeManagersLiveView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(nodeManagersLiveView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nodeManagersLiveView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nodeManagersLiveView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nodeManagersLiveView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nodeManagersLiveView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nodeManagersLiveView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/pie_chart_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/common/chart/pie');
require('utils/helper');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');

describe('App.PieChartDashboardWidgetView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var pieChartDashboardWidgetView = App.PieChartDashboardWidgetView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  pieChartDashboardWidgetView.calc();

  describe('#getUsed', function() {
    var tests = [
      {
        model: Em.Object.create({
          used: 1
        }),
        e: 1,
        m: '"Used" is set'
      },
      {
        model: Em.Object.create({
          used: null
        }),
        e: 0,
        m: '"Used" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Used" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getUsed()).to.equal(test.e);
      });
    });
  });

  describe('#getMax', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: 1,
        m: '"Max" is set'
      },
      {
        model: Em.Object.create({
          max: null
        }),
        e: 0,
        m: '"Max" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Max" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getMax()).to.equal(test.e);
      });
    });
  });

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: true,
        m: 'Exists'
      },
      {
        model: Em.Object.create({
          max: 0
        }),
        e: false,
        m: 'Not exists'
      },
      {
        model: Em.Object.create({}),
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 10,
          used: 0
        }),
        e: ['0', '0.0'],
        m: 'Nothing is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 10
        }),
        e: ['100', '100.0'],
        m: 'All is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 5
        }),
        e: ['50', '50.0'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/resource_manager_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/resource_manager_uptime');

describe('App.ResourceManagerUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        resourceManagerStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var resourceManagerUptimeView = App.ResourceManagerUptimeView.create({model_type:null, model: test.model});
    resourceManagerUptimeView.calc();
    describe('resourceManagerStartTime - ' + test.model.resourceManagerStartTime, function() {
      it('content', function() {
        expect(resourceManagerUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(resourceManagerUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(resourceManagerUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(resourceManagerUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(resourceManagerUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(resourceManagerUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/tasktracker_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/tasktracker_live');

describe('App.TaskTrackerUpView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true
      }
    },
    {
      data: 0,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false
      }
    }
  ];

  tests.forEach(function(test) {
    describe('', function() {
      var taskTrackerUpView = App.TaskTrackerUpView.create({model_type:null, data: test.data, content: test.data.toString()});
      it('isRed', function() {
        expect(taskTrackerUpView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(taskTrackerUpView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(taskTrackerUpView.get('isGreen')).to.equal(test.e.isGreen);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');

describe('App.TextDashboardWidgetView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false
      }
    },
    {
      data: 1,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false
      }
    },
    {
      data: null,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: true
      }
    }
  ];

  tests.forEach(function(test) {
    describe('data - ' + test.data + ' | thresh1 - 40 | thresh2 - 70', function() {
      var textDashboardWidgetView = App.TextDashboardWidgetView.create({thresh1:40, thresh2:70});
      textDashboardWidgetView.set('data', test.data);
      it('isRed', function() {
        expect(textDashboardWidgetView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(textDashboardWidgetView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(textDashboardWidgetView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(textDashboardWidgetView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/uptime_text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/uptime_text_widget');

describe('App.UptimeTextDashboardWidgetView', function() {

  describe('#timeConverter', function() {
    var ts1 = 1358245370553, ts2 = 0;
    var timestamps = [
      {
        t: ts1,
        e: {
          l: 2,
          f: new Date(ts1)
        }
      },
      {
        t: ts2,
        e: {
          l: 2,
          f: new Date(ts2)
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      var uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
      it('timestamp ' + timestamp.t, function() {
        var result = uptimeTextDashboardWidgetView.timeConverter(timestamp.t);
        expect(result.length).to.equal(timestamp.e.l);
        assert.include(timestamp.e.f.toString(), result[0].toString(), timestamp.e.f + ' contains string ' + result[0]);
      });
    });
  });

  describe('#uptimeProcessing', function() {
    var timestamps = [
      {
        diff: 10*1000,
        e: {
          timeUnit: 's'
        }
      },
      {
        diff: 3600*1000,
        e: {
          timeUnit: 'hr'
        }
      },
      {
        diff: 24*3600*1000,
        e: {
          timeUnit: 'd'
        }
      },
      {
        diff: 1800*1000,
        e: {
          timeUnit: 'min'
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      var uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
      it('timestamp ' + timestamp.t + '. timeUnit should be ' + '"' + timestamp.e.timeUnit + '"', function() {
        var result = uptimeTextDashboardWidgetView.uptimeProcessing(((new Date()).getTime() - timestamp.diff));
        expect(uptimeTextDashboardWidgetView.get('timeUnit')).to.equal(timestamp.e.timeUnit);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
var filters = require('views/common/filter_view');
require('mixins/common/userPref');
require('mixins/common/localStorage');
require('views/main/dashboard/widgets');
var mainDashboardWidgetsView;

describe('App.MainDashboardWidgetsView', function() {

  beforeEach(function() {
    mainDashboardWidgetsView = App.MainDashboardWidgetsView.create();
  });

  describe('#setInitPrefObject', function() {
    var hdfs_widgets_count = 7;
    var mapreduce_widgets_count = 7;
    var hbase_widgets_count = 4;
    var yarn_widgets_count = 4;
    var total_widgets_count = 27;
    var tests = Em.A([
      {
        models: {
          hdfs_model: null,
          mapreduce_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hdfs_widgets_count - mapreduce_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'All models are null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count  - mapreduce_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'mapreduce_model, hbase_model, yarn_model are null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: {},
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'hbase_model and yarn_model are null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: {},
          hbase_model: {},
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - yarn_widgets_count - 1,
          hiddenL: 1
        },
        m: 'yarn_model is null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: {},
          hbase_model: {},
          yarn_model: {}
        },
        e: {
          visibleL: total_widgets_count - 1,
          hiddenL: 1
        },
        m: 'All models are not null'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        mainDashboardWidgetsView.set('hdfs_model', test.models.hdfs_model);
        mainDashboardWidgetsView.set('mapreduce_model', test.models.mapreduce_model);
        mainDashboardWidgetsView.set('hbase_model', test.models.hbase_model);
        mainDashboardWidgetsView.set('yarn_model', test.models.yarn_model);
        mainDashboardWidgetsView.setInitPrefObject();
        expect(mainDashboardWidgetsView.get('initPrefObject.visible.length')).to.equal(test.e.visibleL);
        expect(mainDashboardWidgetsView.get('initPrefObject.hidden.length')).to.equal(test.e.hiddenL);
      });
    });
  });

  describe('#persistKey', function() {
    beforeEach(function() {
      sinon.stub(App.router, 'get', function(k) {
        if ('loginName' === k) return 'tdk';
        return Em.get(App.router, k);
      });
    });
    afterEach(function() {
      App.router.get.restore();
    });
    it('Check it', function() {
      expect(mainDashboardWidgetsView.get('persistKey')).to.equal('user-pref-tdk-dashboard');
    });
  });

});
});

;require.register("test/views/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
var filters = require('views/common/filter_view');
require('views/main/dashboard');
var mainDashboardView;
describe('App.MainDashboardView', function() {

   beforeEach(function() {
     mainDashboardView = App.MainDashboardView.create();
   });

});

});

;require.register("test/views/main/host/details/host_component_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');

var hostComponentView;

describe('App.HostComponentView', function() {

  beforeEach(function() {
    sinon.stub(App.router, 'get', function (k) {
      if (k === 'mainHostDetailsController.content') return Em.Object.create({
        hostComponents: [
          {
            componentName: 'component'
          }
        ]
      });
      return Em.get(App.router, k);
    });
    hostComponentView = App.HostComponentView.create({
      startBlinking: function(){},
      doBlinking: function(){},
      getDesiredAdminState: function(){return $.ajax({});},
      content: Em.Object.create({
        componentName: 'component'
      }),
      hostComponent: Em.Object.create()
    });
  });

  afterEach(function () {
    App.router.get.restore();
  });

  describe('#disabled', function() {

    var tests = Em.A([
      {
        parentView: {content: {healthClass: 'health-status-DEAD-YELLOW'}},
        e: 'disabled'
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        e: ''
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          parentView: test.parentView
        });
        expect(hostComponentView.get('disabled')).to.equal(test.e);
      });
    });

  });

  describe('#isUpgradeFailed', function() {

    var tests = ['UPGRADE_FAILED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isUpgradeFailed')).to.equal(e);
      });
    });

  });

  describe('#isInstallFailed', function() {

    var tests = ['INSTALL_FAILED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInstallFailed')).to.equal(e);
      });
    });

  });

  describe('#isStart', function() {

    var tests = ['STARTED','STARTING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isStart')).to.equal(e);
      });
    });

  });

  describe('#isStop', function() {

    var tests = ['INSTALLED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isStop')).to.equal(e);
      });
    });

  });

  describe('#isInstalling', function() {

    var tests = ['INSTALLING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInstalling')).to.equal(e);
      });
    });

  });

  describe('#isInit', function() {

    var tests = ['INIT'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInit')).to.equal(e);
      });
    });

  });

  describe('#noActionAvailable', function() {

    var tests = ['STARTING', 'STOPPING', 'UNKNOWN', 'DISABLED'];
    var testE = 'hidden';
    var defaultE = '';

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('noActionAvailable')).to.equal(e);
      });
    });

  });

  describe('#isActive', function() {

    var tests = Em.A([
      {passiveState: 'OFF', e: true},
      {passiveState: 'ON', e: false},
      {passiveState: 'IMPLIED', e: false}
    ]);

    tests.forEach(function(test) {
      it(test.workStatus, function() {
        hostComponentView.get('content').set('passiveState', test.passiveState);
        expect(hostComponentView.get('isActive')).to.equal(test.e);
      });
    });

  });

  describe('#isRestartComponentDisabled', function() {

    var tests = ['STARTED'];
    var testE = false;
    var defaultE = true;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isRestartComponentDisabled')).to.equal(e);
      });
    });

  });

  describe('#isDeleteComponentDisabled', function() {

    var tests = ['INSTALLED', 'UNKNOWN', 'INSTALL_FAILED', 'UPGRADE_FAILED', 'INIT'];
    var testE = false;
    var defaultE = true;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isDeleteComponentDisabled')).to.equal(e);
      });
    });

  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        componentTextStatus: 'status',
        hostComponent: null,
        e: 'status',
        m: 'get content status'
      },
      {
        componentTextStatus: 'status',
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          hostComponent: test.hostComponent,
          content: Em.Object.create()
        });
        hostComponentView.get('content').set('componentTextStatus', test.componentTextStatus);
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#workStatus', function() {

    var tests = Em.A([
      {
        workStatus: 'status',
        hostComponent: null,
        e: 'status',
        m: 'get content workStatus'
      },
      {
        workStatus: 'status',
        hostComponent: Em.Object.create({workStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent workStatus'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          hostComponent: test.hostComponent,
          content: Em.Object.create()
        });
        hostComponentView.get('content').set('workStatus', test.workStatus);
        expect(hostComponentView.get('workStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.install_failed,
        passiveState: 'OFF',
        e: 'health-status-color-red icon-cog'
      },
      {
        workStatus: App.HostComponentStatus.installing,
        passiveState: 'OFF',
        e: 'health-status-color-blue icon-cog'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'ON',
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'IMPLIED',
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        e: 'health-status-started'
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.passiveState, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: Em.Object.create(),
          hostComponent: Em.Object.create()
        });
        hostComponentView.get('hostComponent').set('workStatus',test.workStatus);
        hostComponentView.get('content').set('passiveState', test.passiveState);
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = ['STOPPING', 'STARTING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInProgress')).to.equal(e);
      });
    });

  });

  describe('#statusIconClass', function() {
    var tests = Em.A([
      {s: 'health-status-started', e: App.healthIconClassGreen},
      {s: 'health-status-starting', e: App.healthIconClassGreen},
      {s: 'health-status-installed', e: App.healthIconClassRed},
      {s: 'health-status-stopping', e: App.healthIconClassRed},
      {s: 'health-status-unknown', e: App.healthIconClassYellow},
      {s: 'health-status-DEAD-ORANGE', e: App.healthIconClassOrange},
      {s: 'other', e: ''}
    ]);

    tests.forEach(function(test) {
      it(test.s, function() {
        hostComponentView.reopen({statusClass: test.s});
        expect(hostComponentView.get('statusIconClass')).to.equal(test.e);
      })
    });
  });

  describe('#slaveCustomCommands', function() {

    var content = [
      {
        componentName: 'SLAVE_COMPONENT',
        hostName: '01'
      },
      {
        componentName: 'NOT_SLAVE_COMPONENT',
        hostName: '02'
      }
    ];
    before(function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          componentName: 'SLAVE_COMPONENT',
          isSlave: true,
          customCommands: ['CUSTOM']
        });
      });
    });

    it('Should get custom commands for slaves', function() {
      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(1);
    });

    after(function() {
      App.StackServiceComponent.find.restore();
    });
  });

});

});

;require.register("test/views/main/host/details/host_component_views/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');
require('mixins');
require('mixins/main/host/details/host_components/decommissionable');

var hostComponentView;

describe('App.Decommissionable', function() {

  beforeEach(function() {
    sinon.stub(App.router, 'get', function (k) {
      if (k === 'mainHostDetailsController.content') return Em.Object.create({
        hostComponents: [
          {
            componentName: 'component'
          }
        ]
      });
      return Em.get(App.router, k);
    });
  });

  afterEach(function () {
    App.router.get.restore();
  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: null,
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'status',
        m: 'get content status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: true,
        e: Em.I18n.t('hosts.host.decommissioning'),
        m: 'get decommissioning status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: false,
        e: Em.I18n.t('hosts.host.decommissioned'),
        m: 'get decommissioned status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable, {
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content,
          hostComponent: test.hostComponent,
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          isComponentDecommissioning: test.isComponentDecommissioning
        });
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.install_failed,
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-red icon-cog'
      },
      {
        workStatus: App.HostComponentStatus.installing,
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-blue icon-cog'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'ON',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'IMPLIED',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        workStatus: 'STARTING',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        workStatus: 'INSTALLED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      }

    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.passiveState + ' ' + test.isComponentRecommissionAvailable?'true':'false', function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          content: Em.Object.create()
        });
        hostComponentView.get('content').setProperties({
          workStatus: test.workStatus,
          passiveState: test.passiveState
        });
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.stopping,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: App.HostComponentStatus.starting,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: 'other_status',
        isDecommissioning: false,
        e: false
      },
      {
        workStatus: 'other_status',
        isDecommissioning: true,
        e: true
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.isDecommissioning?'true':'false', function() {

        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isDecommissioning: test.isDecommissioning,
          content: Em.Object.create({workStatus: test.workStatus})
        });

        expect(hostComponentView.get('isInProgress')).to.equal(test.e);
      });
    });

  });

});

});

;require.register("test/views/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details');

var view,
  activeCases = [
    {
      passiveState: 'ON',
      isActive: false,
      label: 'Off'
    },
    {
      passiveState: 'OFF',
      isActive: true,
      label: 'On'
    }
  ];

describe('App.MainHostDetailsView', function () {

  beforeEach(function () {
    view = App.MainHostDetailsView.create({
       content: Em.Object.create({
          hostComponents: []
       })
    });
  });

  describe('#content', function () {
    it('should take content from controller', function () {
      view.set('content', {
        property: 'value'
      });
      expect(view.get('content.property')).to.equal('value');
    });
  });

  describe('#clients', function () {
    it('should take clients from content', function () {
      view.set('content', {
        hostComponents: [
          {
            isClient: true
          },
          {
            isClient: false
          }
        ]
      });
      expect(view.get('clients')).to.have.length(1);
      view.get('content.hostComponents').pushObject({
        isClient: true
      });
      expect(view.get('clients')).to.have.length(2);
    });
  });

  describe('#isActive', function () {
    activeCases.forEach(function (item) {
      it('should be ' + item.isActive, function () {
        view.set('controller', {
          content: {
            passiveState: item.passiveState
          }
        });
        expect(view.get('isActive')).to.equal(item.isActive);
      });
    });
  });

  describe('#maintenance', function () {
    activeCases.forEach(function (item) {
      it('passive state label should contain ' + item.label, function () {
        view.set('controller', {
          content: {
            passiveState: item.passiveState
          }
        });
        expect(view.get('maintenance').findProperty('action', 'onOffPassiveModeForHost').label).to.contain(item.label);
      });
    });
  });

  describe('#clientsWithConfigs', function() {
    beforeEach(function () {
      view.set('content', {
        hostComponents: [
          Em.Object.create({
            isClient: true,
            service: Em.Object.create({
              serviceName: 'WITH_CONFIGS'
            })
          }),
          Em.Object.create({
            isClient: true,
            service: Em.Object.create({
              serviceName: 'WITHOUT_CONFIGS'
            })
          }),
          Em.Object.create({
            isClient: false,
            service: Em.Object.create({
              serviceName: 'SAMPLE_SERVICE'
            })
          })
        ]
      });

      App.set('services', {
        noConfigTypes: ['WITHOUT_CONFIGS', 'WITHOUT_CONFIGS_2']
      });
    });

    afterEach(function () {
      App.set('services', Em.K);
    });

    it('should get only clients with configs', function() {
      expect(view.get('clientsWithConfigs')).to.have.length(1);
      console.log(view.get('content.hostComponents'));
      view.get('content.hostComponents').pushObject(Em.Object.create({
        isClient: true,
        service: Em.Object.create({
          serviceName: 'WITHOUT_CONFIGS_2'
        })
      }));
      expect(view.get('clientsWithConfigs')).to.have.length(1);
      view.get('content.hostComponents').pushObject(Em.Object.create({
        isClient: true,
        service: Em.Object.create({
          serviceName: 'WITH_CONFIGS_2'
        })
      }));
      expect(view.get('clientsWithConfigs')).to.have.length(2);
    });
  });

  describe('#didInsertElement()', function () {
    it('isLoaded should be set as true', function () {
      view.didInsertElement();
      expect(view.get('isLoaded')).to.be.true;
    });
    it('router should reditect to main.hosts.index', function () {
      App.router.set('mainHostDetailsController.content', {
        isLoaded: false
      });
      view.didInsertElement();
      expect(App.router.get('currentState.name')).to.equal('index');
    });
  });
});

});

;require.register("test/views/main/host/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host');
require('models/service');
require('models/host_component');
require('mappers/server_data_mapper');
require('views/main/host/summary');

var mainHostSummaryView;
var extendedMainHostSummaryView = App.MainHostSummaryView.extend({content: {}, addToolTip: function(){}, installedServices: []});
var modelSetup = require('test/init_model_test');

describe('App.MainHostSummaryView', function() {

  beforeEach(function() {
    modelSetup.setupStackServiceComponent();
    mainHostSummaryView = extendedMainHostSummaryView.create({});
  });

  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#sortedComponents', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['A', 'C', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: ['A', 'C', 'D', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        test.content.get('hostComponents').forEach(function(component) {
          component.set('id', component.get('componentName'));
        });
        mainHostSummaryView.set('sortedComponents', []);
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.sortedComponentsFormatter();
        expect(mainHostSummaryView.get('sortedComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#clients', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: ['B', 'A', 'C', 'D']
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('clients').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#areClientWithStaleConfigs', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'Some clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: false}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'No clients with stale configs',
        e: false
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: true})
          ])
        }),
        m: 'All clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('areClientWithStaleConfigs')).to.equal(test.e);
      });
    });

  });

  describe('#isAddComponent', function() {

    var tests = Em.A([
      {content: {healthClass: 'health-status-DEAD-YELLOW', hostComponents: Em.A([])}, e: false},
      {content: {healthClass: 'OTHER_VALUE', hostComponents: Em.A([])}, e: true}
    ]);

    tests.forEach(function(test) {
      it(test.content.healthClass, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('isAddComponent')).to.equal(test.e);
      });
    });

  });

  describe('#addableComponents', function() {

    var tests = Em.A([
      {
        installableClientComponents: [{}, {}],
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'DATANODE'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['MAPREDUCE2_CLIENT', 'NODEMANAGER', 'YARN_CLIENT', 'CLIENTS'],
        m: 'some components are already installed'
      },
      {
        installableClientComponents: [],
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'YARN_CLIENT'
            }),
            Em.Object.create({
              componentName: 'MAPREDUCE2_CLIENT'
            }),
            Em.Object.create({
              componentName: 'NODEMANAGER'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['DATANODE'],
        m: 'all clients and some other components are already installed'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.reopen({installableClientComponents: test.installableClientComponents});
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.set('installedServices', test.services);
        expect(mainHostSummaryView.get('addableComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe("#clientsWithCustomCommands", function() {
    before(function() {
      sinon.stub(App.StackServiceComponent, 'find', function(component) {
        var customCommands = [];

        if (component == 'WITH_CUSTOM_COMMANDS') {
          customCommands = ['CUSTOMCOMMAND'];
        }

        var obj = Em.Object.create({
          customCommands: customCommands,
          filterProperty: function () {
            return {
              mapProperty: Em.K
            };
          }
        });
        return obj;
      });
    });

    after(function() {
      App.StackServiceComponent.find.restore();
    });
    var content = Em.Object.create({
      hostComponents: Em.A([
        Em.Object.create({
          componentName: 'WITH_CUSTOM_COMMANDS',
          displayName: 'WITH_CUSTOM_COMMANDS',
          hostName: 'c6401',
          service: Em.Object.create({
            serviceName: 'TESTSRV'
          })
        }),
        Em.Object.create({
          componentName: 'WITHOUT_CUSTOM_COMMANDS',
          displayName: 'WITHOUT_CUSTOM_COMMANDS',
          hostName: 'c6401',
          service: Em.Object.create({
            serviceName: 'TESTSRV'
          })
        })
      ])
    });

    it("Clients with custom commands only", function() {
      mainHostSummaryView.set('content', content);
      expect(mainHostSummaryView.get('clientsWithCustomCommands').length).to.eql(1);
      expect(mainHostSummaryView.get('clientsWithCustomCommands')).to.have.deep.property('[0].commands[0].command', 'CUSTOMCOMMAND');
    });
  });
});

});

;require.register("test/views/main/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/menu');

var mainMenuView = App.MainMenuView.create();
describe('App.MainMenuView', function () {

  describe('#content', function () {
    var supportsMirroring;
    beforeEach(function () {
      supportsMirroring = Em.get('App.supports.mirroring');
      Em.set('App.supports.mirroring', false);
      sinon.stub(App, 'get').returns(false);
      sinon.stub(App.router, 'get')
        .withArgs('clusterController.isLoaded').returns(true)
        .withArgs('loggedIn').returns(true);
    });
    afterEach(function () {
      Em.set('App.supports.mirroring', supportsMirroring);
      App.get.restore();
      App.router.get.restore();
    });

    it('menu should be populated if cluster installation is completed', function () {
      App.get.withArgs('router.clusterInstallCompleted').returns(true);
      App.router.notifyPropertyChange('clusterInstallCompleted');
      expect(mainMenuView.get('content').length > 0).to.be.true;
    });

    it('menu should not be populated if cluster installation is not completed', function () {
      App.get.withArgs('router.clusterInstallCompleted').returns(false);
      App.router.notifyPropertyChange('clusterInstallCompleted');
      expect(mainMenuView.get('content').length > 0).to.be.false;
    });

  });
});

});

;require.register("test/views/main/mirroring/edit_dataset_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/mirroring/edit_dataset_controller');
require('models/target_cluster');
require('views/main/mirroring/edit_dataset_view');

var mainMirroringEditDataSetView;
describe('App.MainMirroringEditDataSetView', function () {

  beforeEach(function () {
    mainMirroringEditDataSetView = App.MainMirroringEditDataSetView.create({
      controller: App.MainMirroringEditDataSetController.create(),
      isLoaded: true
    });
  });

  describe('targetClusterSelect.content', function () {
    var targetClusterSelect;
    beforeEach(function () {
      targetClusterSelect = mainMirroringEditDataSetView.get('targetClusterSelect').create({
        parentView: mainMirroringEditDataSetView
      });
    });

    it('should be empty if data is not loaded', function () {
      targetClusterSelect.set('parentView.isLoaded', false);
      expect(targetClusterSelect.get('content')).to.be.empty;
    });
    it('should contain list of clusters if data is loaded', function () {
      targetClusterSelect.set('parentView.isLoaded', true);
      targetClusterSelect.set('parentView.targetClusters', [
        {name: 'test1'},
        {name: 'test2'},
        {name: App.get('clusterName')}
      ]);
      expect(targetClusterSelect.get('content')).to.eql([
        'test1',
        'test2',
        Em.I18n.t('mirroring.dataset.addTargetCluster')
      ]);
    });
  });

  describe('targetClusterSelect.change', function () {
    var targetClusterSelect;
    beforeEach(function () {
      targetClusterSelect = mainMirroringEditDataSetView.get('targetClusterSelect').create({
        parentView: mainMirroringEditDataSetView,
        content: ['test1', 'test2', 'test3']
      });
      sinon.stub(targetClusterSelect.parentView, 'manageClusters', Em.K);
    });

    afterEach(function () {
      targetClusterSelect.parentView.manageClusters.restore();
    });

    it('should open manage cluster popup if appropriate option was selected', function () {
      targetClusterSelect.set('selection', Em.I18n.t('mirroring.dataset.addTargetCluster'));
      targetClusterSelect.change();
      expect(targetClusterSelect.get('selection')).to.equal('test1');
      expect(targetClusterSelect.parentView.manageClusters.calledOnce).to.be.true;
      expect(targetClusterSelect.get('parentView.controller.formFields.datasetTargetClusterName')).to.equal('test1');
    });
    it('should not open manage cluster popup if appropriate option was not selected', function () {
      targetClusterSelect.set('selection', 'test3');
      targetClusterSelect.change();
      expect(targetClusterSelect.get('selection')).to.equal('test3');
      expect(targetClusterSelect.parentView.manageClusters.calledOnce).to.be.false;
      expect(targetClusterSelect.get('parentView.controller.formFields.datasetTargetClusterName')).to.equal('test3');
    });
  });

  describe('onTargetClustersChange', function () {

    var testCases = [
      {
        isLoaded: true,
        targetClusters: [1, 2, 3],
        targetClusterName: 'test',
        hasTargetClusters: true
      },
      {
        isLoaded: false,
        targetClusters: [1, 2, 3],
        targetClusterName: null,
        hasTargetClusters: false
      },
      {
        isLoaded: true,
        targetClusters: [1],
        targetClusterName: null,
        hasTargetClusters: false
      }
    ];

    testCases.forEach(function (test) {
      it('should set hasTargetClusters property depending on cluster list', function () {
        mainMirroringEditDataSetView.set('isLoaded', test.isLoaded);
        mainMirroringEditDataSetView.set('targetClusters', test.targetClusters);
        mainMirroringEditDataSetView.set('controller.formFields.datasetTargetClusterName', 'test');
        mainMirroringEditDataSetView.onTargetClustersChange();
        expect(mainMirroringEditDataSetView.get('hasTargetClusters')).to.equal(test.hasTargetClusters);
        expect(mainMirroringEditDataSetView.get('controller.formFields.datasetTargetClusterName')).to.equal(test.targetClusterName);
      });
    });
  });

  describe('fillForm', function () {

    App.store.loadMany(App.Dataset, [
      {
        id: 'test1',
        name: 'test1',
        target_cluster_name: 'testCluster1',
        source_dir: '/testDir1',
        target_dir: '/testDir1',
        frequency: '5',
        frequency_unit: 'days',
        schedule_start_date: new Date('11/29/2014 01:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, ''),
        schedule_end_date: new Date('11/29/2014 02:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '')
      },
      {
        id: 'test2',
        name: 'test2',
        target_cluster_name: 'testCluster2',
        source_dir: '/testDir2',
        target_dir: '/testDir2',
        frequency: '10',
        frequency_unit: 'hours',
        schedule_start_date: new Date('11/20/2014 01:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, ''),
        schedule_end_date: new Date('11/21/2014 02:00 PM').toISOString().replace(/\:\d{2}\.\d{3}/, '')
      },
      {
        id: 'test3',
        name: 'test3',
        target_cluster_name: 'testCluster3',
        source_dir: '/testDir3',
        target_dir: '/testDir3',
        frequency: '1',
        frequency_unit: 'minutes',
        schedule_start_date: new Date('10/29/2014 01:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, ''),
        schedule_end_date: new Date('11/29/2015 02:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '')
      }
    ]);

    var testCases = [
      {
        datasetName: 'test1',
        datasetSourceDir: '/testDir1',
        datasetTargetDir: '/testDir1',
        datasetTargetClusterName: 'testCluster1',
        datasetFrequency: '5',
        repeatOptionSelected: 'days',
        datasetStartDate: '11/29/14',
        datasetEndDate: '11/29/14',
        hoursForStart: '01',
        hoursForEnd: '02',
        minutesForStart: '00',
        minutesForEnd: '00',
        middayPeriodForStart: 'AM',
        middayPeriodForEnd: 'AM'
      },
      {
        datasetName: 'test2',
        datasetSourceDir: '/testDir2',
        datasetTargetDir: '/testDir2',
        datasetTargetClusterName: 'testCluster2',
        datasetFrequency: '10',
        repeatOptionSelected: 'hours',
        datasetStartDate: '11/20/14',
        datasetEndDate: '11/21/14',
        hoursForStart: '01',
        hoursForEnd: '02',
        minutesForStart: '00',
        minutesForEnd: '00',
        middayPeriodForStart: 'AM',
        middayPeriodForEnd: 'PM'
      },
      {
        datasetName: 'test3',
        datasetSourceDir: '/testDir3',
        datasetTargetDir: '/testDir3',
        datasetTargetClusterName: 'testCluster3',
        datasetFrequency: '1',
        repeatOptionSelected: 'minutes',
        datasetStartDate: '10/29/14',
        datasetEndDate: '11/29/15',
        hoursForStart: '01',
        hoursForEnd: '02',
        minutesForStart: '00',
        minutesForEnd: '00',
        middayPeriodForStart: 'AM',
        middayPeriodForEnd: 'AM'
      }
    ];

    it('should not set form fields if isLoaded is false', function () {
      mainMirroringEditDataSetView.set('isLoaded', false);
      mainMirroringEditDataSetView.fillForm();
      Em.keys(mainMirroringEditDataSetView.get('controller.formFields')).forEach(function (field) {
        expect(mainMirroringEditDataSetView.get('controller.formFields.' + field)).to.be.null;
      });
    });

    it('should not set form fields if controller.isEdit is false', function () {
      mainMirroringEditDataSetView.set('controller.isEdit', false);
      mainMirroringEditDataSetView.fillForm();
      Em.keys(mainMirroringEditDataSetView.get('controller.formFields')).forEach(function (field) {
        expect(mainMirroringEditDataSetView.get('controller.formFields.' + field)).to.be.null;
      });
    });

    testCases.forEach(function (test) {
      it('set appropriate form fields from dataset model', function () {
        mainMirroringEditDataSetView.set('controller.datasetIdToEdit', test.datasetName);
        mainMirroringEditDataSetView.set('controller.isEdit', true);
        mainMirroringEditDataSetView.fillForm();
        Em.keys(mainMirroringEditDataSetView.get('controller.formFields')).forEach(function (field) {
          expect(mainMirroringEditDataSetView.get('controller.formFields.' + field)).to.equal(test[field]);
        });
      });
    });
  });
});

});

;require.register("test/views/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/configs');

describe('App.MainServiceInfoConfigsView', function() {

  var view = App.MainServiceInfoConfigsView.create({
    controller: Em.Object.create()
  });

  describe('#updateComponentInformation', function() {

    var testCases = [
      {
        title: 'if components absent then counters should be 0',
        content: {
          restartRequiredHostsAndComponents: {}
        },
        result: {
          componentsCount: 0,
          hostsCount: 0
        }
      },
      {
        title: 'if host doesn\'t have components then hostsCount should be 1 and componentsCount should be 0',
        content: {
          restartRequiredHostsAndComponents: {
            host1: []
          }
        },
        result: {
          componentsCount: 0,
          hostsCount: 1
        }
      },
      {
        title: 'if host has 1 component then hostsCount should be 1 and componentsCount should be 1',
        content: {
          restartRequiredHostsAndComponents: {
            host1: [{}]
          }
        },
        result: {
          componentsCount: 1,
          hostsCount: 1
        }
      }
    ];
    testCases.forEach(function(test) {
      it(test.title, function() {
        view.set('controller.content', test.content);
        view.updateComponentInformation();
        expect(view.get('componentsCount')).to.equal(test.result.componentsCount);
        expect(view.get('hostsCount')).to.equal(test.result.hostsCount);
      });
    });
  });
});

});

;require.register("test/views/main/service/info/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/summary');

describe('App.MainServiceInfoSummaryView', function() {

  var view = App.MainServiceInfoSummaryView.create({
    monitorsLiveTextView: Em.View.create(),
    controller: Em.Object.create({
      content: Em.Object.create({
        id: 'HDFS',
        serviceName: 'HDFS',
        hostComponents: []
      })
    }),
    alertsController: Em.Object.create()
  });

  describe('#servers', function () {
    it('services shuldn\'t have servers except FLUME and ZOOKEEPER', function () {
      expect(view.get('servers')).to.be.empty;
    });

    it('if one server exists then first server should have isComma and isAnd property false', function () {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(view.get('servers').objectAt(0).isComma).to.equal(false);
      expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
    });

    it('if more than one servers exist then first server should have isComma - true and isAnd - false', function () {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(view.get('servers').objectAt(0).isComma).to.equal(true);
      expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      expect(view.get('servers').objectAt(1).isComma).to.equal(false);
      expect(view.get('servers').objectAt(1).isAnd).to.equal(false);
    });

    it('if more than two servers exist then second server should have isComma - false and isAnd - true', function () {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(view.get('servers').objectAt(0).isComma).to.equal(true);
      expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      expect(view.get('servers').objectAt(1).isComma).to.equal(false);
      expect(view.get('servers').objectAt(1).isAnd).to.equal(true);
      expect(view.get('servers').objectAt(2).isComma).to.equal(false);
      expect(view.get('servers').objectAt(2).isAnd).to.equal(false);
    });

  });

  describe("#constructGraphObjects", function() {
    it("should return a single array with the items in the fom of '<name>.extend()' when the number of items is less than 4", function() {
      var graphs = ['HDFS_SpaceUtilization'];

      expect(view.constructGraphObjects(graphs).length).to.equal(1);
      expect(view.constructGraphObjects(graphs)[0].length).to.equal(1);
    });

    it("should return an array with arrays that are grouped into sizes of 4 or less when number of items is greater than 4", function() {
      var graphs = ['HDFS_SpaceUtilization', 'YARN_AllocatedMemory', 'MapReduce_JobsStatus', 
      'HBASE_ClusterRequests', 'Flume_ChannelSizeMMA'];

      expect(view.constructGraphObjects(graphs).length).to.equal(2);
      expect(view.constructGraphObjects(graphs)[0].length).to.equal(4);
      expect(view.constructGraphObjects(graphs)[1].length).to.equal(1);
    });

    it("should return an empty array if the graphs array provided is empty", function() {
      expect(view.constructGraphObjects([])).to.be.empty;
    });
  });

  describe("#observeAlerts()", function() {
    var mock = {state: 'inDOM'};
    it("No alerts loaded", function() {
      var alerts = [];
      view.set('alertsController.alerts', []);
      view.set('alerts', alerts);
      view.observeAlerts(mock);

      expect(alerts).to.be.empty;
      expect(view.get('alertsMap')).to.be.empty;
    });
    it("One alert loaded", function() {
      var alerts = [];
      view.set('alertsController.alerts', [{
        id: 1
      }]);
      view.set('alerts', alerts);
      view.observeAlerts(mock);

      expect(alerts[0]).to.be.eql({
        "id": 1
      });
      expect(alerts.length).to.be.equal(1);
      expect(view.get('alertsMap')).to.be.eql({"1": {
        "id": 1
      }});
    });
    it("No new alerts", function() {
      var alerts = [{id: 1}];
      view.set('alertsController.alerts', []);
      view.set('alerts', alerts);
      view.set('alertsMap', {'1': {id: '1'}});
      view.observeAlerts(mock);

      expect(alerts).to.be.empty;
      expect(view.get('alertsMap')).to.be.empty;
    });
    before(function () {
      sinon.stub(view, 'updateAlerts', Em.K);
    });
    after(function () {
      view.updateAlerts.restore();
    });
    it("Alerts already exist", function() {
      var alerts = [{id: 1}];
      view.set('alertsController.alerts', [{
        id: 1
      }]);
      view.set('alerts', alerts);
      view.set('alertsMap', {'1': {id: '1'}});
      view.observeAlerts(mock);

      expect(view.updateAlerts.calledWith(
        [{
          id: 1
        }],
        [{id: 1}]
      )).to.be.true;
    });
  });

  describe("#updateAlerts()", function() {
    var currentAlerts = [];
    var alertsMap = {};
    var newAlerts = [];
    it("Add new alert", function() {
      newAlerts.clear();
      currentAlerts.clear();
      alertsMap = {};

      newAlerts.pushObjects([
        Em.Object.create({
          id: '1',
          status: '1',
          isLoaded: true
        }),
        Em.Object.create({
          id: '2',
          status: '2',
          isLoaded: true
        })
      ]);
      var currentAlert = Em.Object.create({
          id: '1',
          status: '1',
          isLoaded: true
        });
      alertsMap['1'] = currentAlert;
      view.set('alertsMap', alertsMap);
      currentAlerts.pushObject(currentAlert);

      view.updateAlerts(newAlerts, currentAlerts);
      expect(currentAlerts.length).to.be.equal(2);
      expect(currentAlerts[1]).to.be.eql(Em.Object.create({
        id: '2',
        status: '2',
        isLoaded: true
      }));
      expect(alertsMap).to.be.eql({
        "1": Em.Object.create({
          id: '1',
          status: '1',
          isLoaded: true
        }),
        "2": Em.Object.create({
          id: '2',
          status: '2',
          isLoaded: true
        })
      });
    });
    it("Update properties of existing alert", function() {
      newAlerts.clear();
      currentAlerts.clear();
      alertsMap = {};

      newAlerts.pushObjects([
        Em.Object.create({
          id: '1',
          status: '2',
          isLoaded: true
        })
      ]);
      var currentAlert = Em.Object.create({
        id: '1',
        status: '1',
        isLoaded: true
      });
      alertsMap['1'] = currentAlert;
      view.set('alertsMap', alertsMap);
      currentAlerts.pushObject(currentAlert);

      view.updateAlerts(newAlerts, currentAlerts);
      expect(currentAlerts.length).to.be.equal(1);
      expect(currentAlerts[0]).to.be.eql(Em.Object.create({
        id: '1',
        status: '2',
        isLoaded: true
      }));
      expect(alertsMap).to.be.eql({
        "1": Em.Object.create({
          id: '1',
          status: '2',
          isLoaded: true
        })
      });
    });
    it("delete old alert", function() {
      newAlerts.clear();
      currentAlerts.clear();
      alertsMap = {};

      newAlerts.pushObjects([
        Em.Object.create({
          id: '1',
          status: '1',
          isLoaded: true
        })
      ]);
      var currentAlert1 = Em.Object.create({
        id: '1',
        status: '1',
        isLoaded: true
      });
      var currentAlert2 = Em.Object.create({
        id: '2',
        status: '2',
        isLoaded: true
      });
      alertsMap["1"] = currentAlert1;
      alertsMap["2"] = currentAlert2;
      view.set('alertsMap', alertsMap);
      currentAlerts.pushObjects([currentAlert1, currentAlert2]);

      view.updateAlerts(newAlerts, currentAlerts);

      expect(currentAlerts.length).to.be.equal(1);
      expect(currentAlerts[0]).to.be.eql(Em.Object.create({
        id: '1',
        status: '1',
        isLoaded: true
      }));
      expect(alertsMap).to.be.eql({
        "1": Em.Object.create({
          id: '1',
          status: '1',
          isLoaded: true
        })
      });
    });
  });
});
});

;require.register("test/views/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/service/item');

describe('App.MainServiceItemView', function() {

  var view = App.MainServiceItemView.create({
    controller: Em.Object.create({
      content:{
        hostComponents: []
      }
    })
  });

  describe('#mastersExcludedCommands', function() {

    var nonCustomAction = ['RESTART_ALL', 'RUN_SMOKE_TEST', 'REFRESH_CONFIGS', 'ROLLING_RESTART', 'TOGGLE_PASSIVE', 'TOGGLE_NN_HA', 'TOGGLE_RM_HA', 'MOVE_COMPONENT', 'DOWNLOAD_CLIENT_CONFIGS','MASTER_CUSTOM_COMMAND'];

    var keys = Object.keys(view.mastersExcludedCommands);
    var mastersExcludedCommands = [];
    for (var i = 0; i < keys.length; i++) {
      mastersExcludedCommands[i] = view.mastersExcludedCommands[keys[i]];
    }
    console.log("value of masterExcluded: " + mastersExcludedCommands);
    var allMastersExcludedCommands = mastersExcludedCommands.reduce(function(previous, current){
      console.log(previous);
      return previous.concat(current);
    });
    var actionMap = view.actionMap();

    var customActionsArray = [];
    for (var iter in actionMap) {
      customActionsArray.push(actionMap[iter]);
    }
    var customActions = customActionsArray.mapProperty('customCommand').filter(function(action){
      return !nonCustomAction.contains(action);
    }).uniq();

    // remove null and undefined from the list
    customActions = customActions.filter(function(value) { return value != null; });

    customActions.forEach(function(action){
      it(action + ' should be present in App.MainServiceItemView mastersExcludedCommands object', function() {
        expect(allMastersExcludedCommands).to.contain(action);
      });
    });
  });
});


});

;require.register("test/views/wizard/step0_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step0_view');

var view, controller = Em.Object.create({
  clusterNameError: '',
  loadStep: Em.K
});

describe('App.WizardStep0View', function () {

  beforeEach(function () {
    view = App.WizardStep0View.create({'controller': controller});
  });

  describe('#onError', function () {
    it('should be true if clusterNameError appears', function () {
      controller.set('clusterNameError', 'ERROR');
      expect(view.get('onError')).to.equal(true);
    });
    it('should be false if clusterNameError doesn\'t appears', function () {
      controller.set('clusterNameError', '');
      expect(view.get('onError')).to.equal(false);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      App.popover.restore();
      view.get('controller').loadStep.restore();
    });
    it('should call loadStep', function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

});

describe('App.WizardStep0ViewClusterNameInput', function () {

  beforeEach(function() {
    view = App.WizardStep0ViewClusterNameInput.create({
      parentView: Em.Object.create({
        controller: Em.Object.create({
          submit: Em.K
        })
      })
    });
  });

  describe('#keyPress', function() {
    it('should return true if pressed not Enter', function() {
      expect(view.keyPress({keyCode: 1})).to.equal(true);
    });
    it('should submit form if Enter pressed', function() {
      sinon.spy(view.get('parentView.controller'), 'submit');
      expect(view.keyPress({keyCode: 13})).to.equal(false);
      expect(view.get('parentView.controller').submit.calledOnce).to.equal(true);
      view.get('parentView.controller').submit.restore();
    });
  });

});
});

;require.register("test/views/wizard/step10_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step10_view');
var view;
describe('App.WizardStep10View', function() {
  beforeEach(function() {
    view = App.WizardStep10View.create({
      controller: App.WizardStep10Controller.create()
    });
  });
  describe('didInsertElement', function() {
    it('should call loadStep', function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });
});

});

;require.register("test/views/wizard/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step1_view');

var view;
var controller;

describe('App.WizardStep1View', function () {

  describe('#operatingSystems', function () {
    beforeEach(function () {
      sinon.stub(App.Stack, 'find', function () {
        return [
          Ember.Object.create({
            id: 'HDP-1.3',
            stackName: 'HDP',
            stackVersion: '1.3',
            active: true,
            operatingSystems: [
              Ember.Object.create({
                id: 'HDP-1.3-redhat5',
                osType: 'redhat5',
                isSelected: false,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat5-HDP-1.3',
                    isSelected: false
                  }),
                  Ember.Object.create({
                    id: 'redhat5-HDP-UTILS-1.1.0.19',
                    isSelected: false
                  })
                ]
              }),
              Ember.Object.create({
                id: 'HDP-1.3-redhat6',
                osType: 'redhat6',
                isSelected: false,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat6-HDP-1.3',
                    isSelected: false
                  }),
                  Ember.Object.create({
                    id: 'redhat6-HDP-UTILS-1.1.0.19',
                    isSelected: false
                  })
                ]
              })
            ],
            isSelected: false
          }),
          Ember.Object.create({
            id: 'HDP-2.1',
            stackName: 'HDP',
            stackVersion: '2.1',
            active: true,
            operatingSystems: [
              Ember.Object.create({
                id: 'HDP-2.1-redhat5',
                osType: 'redhat5',
                isSelected: true,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat5-HDP-2.1',
                    isSelected: true,
                    baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0",
                    latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0"
                  }),
                  Ember.Object.create({
                    id: 'redhat5-HDP-UTILS-1.1.0.19',
                    isSelected: true,
                    baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5",
                    latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5"
                  })
                ]
              }),
              Ember.Object.create({
                id: 'HDP-2.1-redhat6',
                osType: 'redhat6',
                isSelected: true,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat6-HDP-2.1',
                    isSelected: true,
                    baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0",
                    latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0"
                  }),
                  Ember.Object.create({
                    id: 'redhat6-HDP-UTILS-1.1.0.19',
                    isSelected: true,
                    baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6",
                    latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6"
                  })
                ]
              })
            ],
            repositories: [
              Ember.Object.create({
                id: 'redhat5-HDP-2.1',
                isSelected: true,
                baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0",
                latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0"
              }),
              Ember.Object.create({
                id: 'redhat5-HDP-UTILS-1.1.0.19',
                isSelected: true,
                baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5",
                latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5"
              }),
              Ember.Object.create({
                id: 'redhat6-HDP-2.1',
                isSelected: true,
                baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0",
                latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0"
              }),
              Ember.Object.create({
                id: 'redhat6-HDP-UTILS-1.1.0.19',
                isSelected: true,
                baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6",
                latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6"
              })
            ],
            isSelected: true
          })
        ];
      });
    });

    afterEach(function () {
      App.Stack.find.restore();
    });

    it('should create empty array if there is no stacks', function () {
      controller = App.WizardStep1Controller.create({
        content: {
          stacks: []
        },
        selectedStack: []
      });
      view = App.WizardStep1View.create();
      view.reopen({
        controller: controller
      });
      expect(view.get('allRepositories.length')).to.equal(0);
      expect(view.get('operatingSystems.length')).to.equal(0);
    });

    it('should create repo groups from repo list', function () {
      controller = App.WizardStep1Controller.create({
        content: {
          stacks: App.Stack.find()
        }
      });
      view = App.WizardStep1View.create({'controller': controller});
      view.set('$', function () {
        return Em.Object.create({hide: Em.K, toggle: Em.K});
      });
      var repositories = view.get('allRepositories');
      expect(view.get('operatingSystems.length')).to.equal(2);
      expect(view.get('operatingSystems')[0].get('osType')).to.equal('redhat5');
      expect(view.get('operatingSystems')[1].get('osType')).to.equal('redhat6');
      expect(view.get('operatingSystems')[0].get('isSelected')).to.be.true;
      expect(view.get('operatingSystems')[1].get('isSelected')).to.be.true;
      expect(view.get('operatingSystems')[0].get('repositories')).to.eql([repositories[0], repositories[1]]);
      expect(view.get('operatingSystems')[1].get('repositories')).to.eql([repositories[2], repositories[3]]);
    });
  });

  describe('#emptyRepoExist', function () {

    controller = App.WizardStep1Controller.create({
      content: {
        stacks: App.Stack.find()
      }
    });
    view = App.WizardStep1View.create();
    view.reopen({
      controller: controller
    });
    view.set('$', function () {
      return Em.Object.create({hide: Em.K, toggle: Em.K});
    });

    it(view.get('allRepositories').mapProperty('emptyError').join(', '), function () {
      expect(view.get('emptyRepoExist')).to.equal(false);
    });
  });

  describe('#isNoOsChecked', function () {
    view = App.WizardStep1View.create();

    var tests = Em.A([
      {
        operatingSystems: [
          {'isSelected': false},
          {'isSelected': false}
        ],
        e: true
      },
      {
        operatingSystems: [
          {'isSelected': true},
          {'isSelected': false}
        ],
        e: false
      },
      {
        operatingSystems: [
          {'isSelected': true},
          {'isSelected': true}
        ],
        e: false
      }
    ]);

    tests.forEach(function (test) {
      it(test.operatingSystems.mapProperty('isSelected').join(', '), function () {
        var operatingSystems = view.get('operatingSystems');
        Ember.set(operatingSystems[0], 'isSelected', test.operatingSystems[0].isSelected);
        Ember.set(operatingSystems[1], 'isSelected', test.operatingSystems[1].isSelected);
        expect(view.get('isNoOsChecked')).to.equal(test.e);
      });
    });
  });

  describe('#stacks', function () {

    var tests = Em.A([
      {
        m: 'Stack with 2 HDP',
        stacks: [
          Em.Object.create({isSelected: true, id: 'HDP-2.0.1'}),
          Em.Object.create({isSelected: false, id: 'HDP-1.3.3'})
        ],
        e: {
          names: ['HDP 2.0.1', 'HDP 1.3.3'],
          selected: [true, false]
        }
      },
      {
        m: 'No HDP',
        stacks: [],
        e: {
          names: [],
          selected: []
        }
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        view.set('controller.content.stacks', test.stacks);
        var stacks = view.get('stacks');
        expect(stacks.mapProperty('name')).to.eql(test.e.names);
        expect(stacks.mapProperty('isSelected')).to.eql(test.e.selected);
      });
    });

  });

  describe('#isSubmitDisabled', function () {

    var tests = Em.A([
      {
        emptyRepoExist: false,
        isNoOsChecked: false,
        invalidUrlExist: false,
        e: false
      },
      {
        emptyRepoExist: true,
        isNoOsChecked: false,
        invalidUrlExist: false,
        e: true
      },
      {
        emptyRepoExist: false,
        isNoOsChecked: true,
        invalidUrlExist: false,
        e: true
      },
      {
        emptyRepoExist: false,
        isNoOsChecked: false,
        invalidUrlExist: true,
        e: true
      },
      {
        emptyRepoExist: true,
        isNoOsChecked: false,
        invalidUrlExist: true,
        e: true
      },
      {
        emptyRepoExist: true,
        isNoOsChecked: true,
        invalidUrlExist: false,
        e: true
      },
      {
        emptyRepoExist: false,
        isNoOsChecked: true,
        invalidUrlExist: true,
        e: true
      },
      {
        emptyRepoExist: true,
        isNoOsChecked: true,
        invalidUrlExist: true,
        e: true
      }
    ]);

    tests.forEach(function (test) {
      it(test.emptyRepoExist.toString() + ' ' + test.isNoOsChecked.toString() + ' ' + test.invalidUrlExist.toString(), function () {
        view = App.WizardStep1View.create();
        view.reopen({
          emptyRepoExist: test.emptyRepoExist,
          isNoOsChecked: test.isNoOsChecked,
          invalidUrlExist: test.invalidUrlExist
        });
        expect(view.get('isSubmitDisabled')).to.equal(test.e);
      });
    });
  });

  describe('#invalidUrlExist', function () {
    var tests = Em.A([
      {
        allRepositories: [Em.Object.create({validation: 'icon-exclamation-sign'})],
        m: 'invalidCnt: 1, validation: icon-exclamation-sign',
        e: true
      },
      {
        allRepositories: [Em.Object.create({validation: ''})],
        m: 'invalidCnt: 1, validation: ""',
        e: false
      },
      {
        allRepositories: [Em.Object.create({validation: ''})],
        m: 'invalidCnt: 0, validation: ""',
        e: false
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view = App.WizardStep1View.create();
        view.reopen({
          allRepositories: test.allRepositories
        });
        expect(view.get('invalidUrlExist')).to.equal(test.e);
      });
    });
  });

  describe('#totalErrorCnt', function () {
    var tests = Em.A([
      {
        allRepositories: [
          {}
        ],
        m: 'isNoOsChecked',
        isNoOsChecked: true,
        e: 1
      },
      {
        allRepositories: [
          {'emptyError': true},
          {'emptyError': true}
        ],
        isNoOsChecked: false,
        m: 'two with empty-error',
        e: 2
      },
      {
        allRepositories: [
          {'validation': 'icon-exclamation-sign'},
          {'validation': 'icon-exclamation-sign'}
        ],
        isNoOsChecked: false,
        m: 'two with validation="icon-exclamation-sign"',
        e: 2
      },
      {
        allRepositories: [
          {'emptyError': true, 'validation': 'icon-exclamation-sign'},
          {'emptyError': true, 'validation': 'icon-exclamation-sign'}
        ],
        isNoOsChecked: false,
        m: 'two with empty-error, two with validation="icon-exclamation-sign"',
        e: 4
      },
      {
        allRepositories: [
          {}
        ],
        isNoOsChecked: false,
        m: 'no errors/warnings etc',
        e: 0
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view = App.WizardStep1View.create();
        view.reopen({
          isNoOsChecked: test.isNoOsChecked,
          allRepositories: test.allRepositories
        });
        expect(view.get('totalErrorCnt')).to.equal(test.e);
      });
    });
  });

  describe('#didInsertElement', function () {
    it('should create tooltip', function () {
      sinon.stub($.fn, 'tooltip', Em.K);
      view.set('isRLCollapsed', false);
      view.didInsertElement();
      expect($.fn.tooltip.calledOnce).to.equal(true);
      $.fn.tooltip.restore();
    });
  });

  describe('#stackRadioButton', function () {

    var v;
    beforeEach(function () {
      v = view.get('stackRadioButton').create({
        content: Em.Object.create({
          name: ''
        }),
        controller: Em.Object.create({
          content: Em.Object.create({
            stacks: []
          })
        })
      });
    });

    describe('#isSelected', function () {
      it('should be equal content.isSelected', function () {
        v.set('content.isSelected', true);
        expect(v.get('checked')).to.equal(true);
        v.set('content.isSelected', false);
        expect(v.get('checked')).to.equal(false);
      });
    });

    describe('#click', function () {
      it('should select proper stack', function () {
        v.set('controller.content.stacks', Em.A([Em.Object.create({id: 'n-1'}), Em.Object.create({id: 'n-2'}), Em.Object.create({id: 'n-3'})]));
        v.set('content.name', 'n 2');
        v.click();
        expect(v.get('controller.content.stacks').getEach('isSelected')).to.eql([false, true, false]);
      });
    });

  });

  describe('#popoverView', function () {

    var v;
    beforeEach(function () {
      v = view.get('popoverView').create();
      sinon.stub(App, 'popover', Em.K);
      view = App.WizardStep1View.create({'controller': controller});
      view.set('$', function () {
        return Em.Object.create({hide: Em.K, toggle: Em.K});
      });
    });

    afterEach(function () {
      App.popover.restore();
    });

    describe('#didInsertElement', function () {
      it('should create popover', function () {
        v.didInsertElement();
        expect(App.popover.calledOnce).to.equal(true);
      });
    });

  });

  describe('#onToggleBlock', function () {

    it('should toggle isRLCollapsed', function () {
      view.set('isRLCollapsed', true);
      view.onToggleBlock();
      expect(view.get('isRLCollapsed')).to.equal(false);
      view.onToggleBlock();
      expect(view.get('isRLCollapsed')).to.equal(true);
    });
  });

  describe('#updateByCheckbox', function () {

    var operatingSystems = [
      Em.Object.create({
        name: 'redhat5',
        isSelected: false,
        repositories: [Em.Object.create({
          id: 'id',
          osType: 'redhat5',
          baseUrl: 'baseUrl',
          latestBaseUrl: 'latestBaseUrl',
          validation: '',
          isSelected: false
        })
        ]
      })
    ];

    var controller = {
      content: {
        stacks: [
          Em.Object.create({
            isSelected: true,
            operatingSystems: [
              Em.Object.create({
                id: 'id',
                osType: 'redhat5',
                baseUrl: 'baseUrl',
                latestBaseUrl: 'latestBaseUrl',
                validation: '',
                isSelected: false
              })
            ]
          })
        ]
      },
      selectedStack: Em.Object.create({
        isSelected: true,
        operatingSystems: [
          Em.Object.create({
            id: 'id',
            osType: 'redhat5',
            baseUrl: 'baseUrl',
            latestBaseUrl: 'latestBaseUrl',
            validation: '',
            isSelected: true
          })
        ]
      }),
      skipValidationChecked: true
    };

    it('target group isn\'t isSelected', function () {
      view.reopen({
        operatingSystems: operatingSystems,
        controller: controller
      });
      view.updateByCheckbox();
      var targetGroup = view.get('operatingSystems.firstObject.repositories.firstObject');
      expect(targetGroup.get('baseUrl')).to.equal('latestBaseUrl');
      expect(targetGroup.get('latestBaseUrl')).to.equal('latestBaseUrl');
      expect(targetGroup.get('validation')).to.be.empty;

    });

    it('target group is isSelected, skipValidationisSelected = true', function () {
      controller.content.stacks[0].operatingSystems[0].selected = true;
      operatingSystems[0].set('isSelected', true);
      view.reopen({
        operatingSystems: operatingSystems,
        controller: controller
      });
      view.updateByCheckbox();
      var targetGroup = view.get('operatingSystems.firstObject.repositories.firstObject');
      expect(targetGroup.get('validation')).to.be.empty;
    });
  });

  describe('#clearGroupLocalRepository', function () {
    it('should empty base url and validation', function () {
      var event = {context: Em.Object.create({'group-number': 0, id: 'HDP-redhat5', repoId: 'HDP-redhat5', baseUrl: 'baseUrl', validation: 'validation'})};
      view.clearGroupLocalRepository(event);
      expect(event.context.get('baseUrl')).to.be.empty;
      expect(event.context.get('validation')).to.be.empty;

    });
  });

  describe('#undoGroupLocalRepository', function () {
    it('should reset base url and validation', function () {
      var event = {context: Em.Object.create({'group-number': 0, id: 'HDP-redhat5', repoId: 'HDP-redhat5', latestBaseUrl: 'latestBaseUrl', validation: 'validation'})};
      view.undoGroupLocalRepository(event);
      expect(event.context.get('baseUrl')).to.equal(event.context.get('latestBaseUrl'));
      expect(event.context.get('validation')).to.be.empty;
    });
  });

  describe('#editLocalRepository', function () {

    it('should update repository', function () {
      view.reopen({
        allRepositories: [
          Em.Object.create({
            isSelected: true,
            baseUrl: 'b1',
            validation: 'icon-exclamation-sign'
          })
        ]
      });
      view.editLocalRepository();
      var repository = view.get('allRepositories.firstObject');
      expect(repository.get('lastBaseUrl')).to.equal(repository.get('baseUrl'));
      expect(repository.get('validation')).to.be.empty;
    });
  });
});
});

;require.register("test/views/wizard/step2_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step2_view');

var view, controller = Em.Object.create({
  clusterNameError: ''
});

describe('App.WizardStep0View', function () {

  beforeEach(function() {
    view = App.WizardStep2View.create({'controller': controller});
  });

  describe('#sshKeyState', function() {
    it('should be equal to controller.content.installOptions.manualInstall', function() {
      controller.set('content', {installOptions: {manualInstall: false}});
      expect(view.get('sshKeyState')).to.equal(false);
      controller.toggleProperty('content.installOptions.manualInstall');
      expect(view.get('sshKeyState')).to.equal(true);
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      view.set('controller.hostsError', 'some text');
      view.set('controller.sshKeyError', 'some text');
    });
    afterEach(function () {
      App.popover.restore();
    });
    it('should clean hostsError', function () {
      view.didInsertElement();
      expect(view.get('controller.hostsError')).to.be.null;
    });
    it('should clean sshKeyError', function () {
      view.didInsertElement();
      expect(view.get('controller.sshKeyError')).to.be.null;
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

  describe('#providingSSHKeyRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('providingSSHKeyRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.useSsh', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(true);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', true);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(false);
      });
    });

  });

  describe('#manualRegistrationRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('manualRegistrationRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.manualInstall', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', true);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(false);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(true);
      });
    });

  });

  describe('#textFieldView', function() {
    var v;

    beforeEach(function() {
      v = view.get('textFieldView').create();
    });

    describe('#disabled', function() {
      it('should be inverted to isEnabled', function () {
        v.set('isEnabled', false);
        expect(v.get('disabled')).to.equal(true);
        v.set('isEnabled', true);
        expect(v.get('disabled')).to.equal(false);
      });
    });

  });

});

describe('App.SshKeyFileUploader', function() {

  beforeEach(function() {
    view = App.SshKeyFileUploader.create();
  });

});

});

;require.register("test/views/wizard/step3/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostLogPopupBody_view');
var view;
describe('App.WizardStep3HostLogPopupBody', function() {

  beforeEach(function() {
    view = App.WizardStep3HostLogPopupBody.create({
      parentView: Em.Object.create({
        host: Em.Object.create()
      })
    });
  });

  describe('#textArea', function() {

    var v;

    beforeEach(function() {
      v = view.get('textArea').create();
    });

    describe('#value', function() {
      it('should be equal to content', function() {
        var c = 'Relax, you are doing fine';
        v.set('content', c);
        expect(v.get('value')).to.equal(c);
      });
    });

  });

  describe('#bootLog', function() {
    it('should be equal to parentView.host.bootLog', function() {
      var log = 'i wanna play a game';
      view.set('parentView.host.bootLog', log);
      expect(view.get('bootLog')).to.equal(log);
    });
  });

});
});

;require.register("test/views/wizard/step3/hostWarningPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var lazyloading = require('utils/lazy_loading');
require('views/wizard/step3/hostWarningPopupBody_view');
var view;

describe('App.WizardStep3HostWarningPopupBody', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupBody.create({
      didInsertElement: Em.K,
      $: function() {
        return Em.Object.create({
          toggle: Em.K
        })
      }
    });
  });

  describe('#onToggleBlock', function() {
    it('should toggle', function() {
      var context = Em.Object.create({isCollapsed: false});
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(true);
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(false);
    });
  });

  describe('#showHostsPopup', function() {
    it('should call App.ModalPopup.show', function() {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      view.showHostsPopup({context: []});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#categoryWarnings', function() {
    it('should return empty array', function() {
      var warningsByHost = null;
      view.reopen({warningsByHost: warningsByHost});
      expect(view.get('categoryWarnings')).to.eql([]);
    });
    it('should return filtered warnings', function() {
      var warningsByHost = [
        {name: 'c', warnings: [{}, {}, {}]},
        {name: 'd', warnings: [{}]}
      ];
      view.reopen({warningsByHost: warningsByHost, category: 'c'});
      expect(view.get('categoryWarnings.length')).to.equal(3);
    });
  });

  describe('#warningHostsNamesCount', function() {
    it('should parse warnings', function() {
      view.set('bodyController', Em.Object.create({
        repoCategoryWarnings: [
          {hostsNames: ['h1', 'h4']}
        ],
        thpCategoryWarnings: [
          {hostsNames: ['h2', 'h3']}
        ],
        jdkCategoryWarnings: [
          {hostsNames: ['h3', 'h5']}
        ],
        hostCheckWarnings: [
          {hostsNames: ['h1', 'h2']}
        ],
        diskCategoryWarnings: [
          {hostsNames: ['h2', 'h5']}
        ],
        warningsByHost: [
          {},
          { name: 'h1', warnings: [{}, {}, {}] },
          { name: 'h2', warnings: [{}, {}, {}] },
          { name: 'h3', warnings: [] }
        ]
      }));
      expect(view.warningHostsNamesCount()).to.equal(5);
    });
  });

  describe('#hostSelectView', function() {

    var v;

    beforeEach(function() {
      v = view.get('hostSelectView').create();
    });

    describe('#click', function() {
      Em.A([
          {
            isLoaded: false,
            isLazyLoading: true,
            e: true
          },
          {
            isLoaded: true,
            isLazyLoading: true,
            e: false
          },
          {
            isLoaded: false,
            isLazyLoading: false,
            e: false
          },
          {
            isLoaded: true,
            isLazyLoading: false,
            e: false
          }
        ]).forEach(function (test) {
          it('isLoaded: ' + test.isLoaded.toString() + ', isLazyLoading: ' + test.isLazyLoading.toString(), function () {
            v.reopen({
              isLoaded: test.isLoaded,
              isLazyLoading: test.isLazyLoading
            });
            sinon.spy(lazyloading, 'run');
            v.click();
            if (test.e) {
              expect(lazyloading.run.calledOnce).to.equal(true);
            }
            else {
              expect(lazyloading.run.called).to.equal(false);
            }
            lazyloading.run.restore();
          });
        });
    });

  });

  describe('#contentInDetails', function() {
    var content = [
      {category: 'firewall', warnings: [{name: 'n1'}, {name: 'n2'}, {name: 'n3'}]},
      {category: 'fileFolders', warnings: [{name: 'n4'}, {name: 'n5'}, {name: 'n6'}]},
      {category: 'reverseLookup', warnings: [{name: 'n19', hosts: ["h1"]}]},
      {
        category: 'process',
        warnings: [
          {name: 'n7', hosts:['h1', 'h2'], user: 'u1', pid: 'pid1'},
          {name: 'n8', hosts:['h2'], user: 'u2', pid: 'pid2'},
          {name: 'n9', hosts:['h3'], user: 'u1', pid: 'pid3'}
        ]
      },
      {category: 'package', warnings: [{name: 'n10'}, {name: 'n11'}, {name: 'n12'}]},
      {category: 'service', warnings: [{name: 'n13'}, {name: 'n14'}, {name: 'n15'}]},
      {category: 'user', warnings: [{name: 'n16'}, {name: 'n17'}, {name: 'n18'}]},
      {category: 'jdk', warnings: []},
      {category: 'disk', warnings: []},
      {category: 'repositories', warnings: []},
      {category: 'hostNameResolution', warnings: []},
      {category: 'thp', warnings: []}
    ];
    beforeEach(function() {
      view.reopen({content: content, warningsByHost: [], hostNamesWithWarnings: ['c', 'd']});
    });
    it('should map hosts', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('c d')).to.equal(true);
    });
    it('should map firewall warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n1<br>n2<br>n3')).to.equal(true);
    });
    it('should map fileFolders warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n4 n5 n6')).to.equal(true);
    });
    it('should map process warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('(h1,u1,pid1)')).to.equal(true);
      expect(newContent.contains('(h2,u1,pid1)')).to.equal(true);
      expect(newContent.contains('(h2,u2,pid2)')).to.equal(true);
      expect(newContent.contains('(h3,u1,pid3)')).to.equal(true);
    });
    it('should map package warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n10 n11 n12')).to.equal(true);
    });
    it('should map service warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n13 n14 n15')).to.equal(true);
    });
    it('should map user warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n16 n17 n18')).to.equal(true);
    });
    it('should map reverse lookup warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('h1')).to.equal(true);
    });
  });

});
});

;require.register("test/views/wizard/step3/hostWarningPopupFooter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostWarningPopupFooter_view');
var view;

describe('App.WizardStep3HostWarningPopupFooter', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupFooter.create();
    view.reopen({footerController: Em.Object.create()});
  });

  describe('#progressWidth', function() {
    it('based on footerController.checksUpdateProgress', function() {
      view.set('footerController.checksUpdateProgress', 42);
      expect(view.get('progressWidth')).to.equal('width:42%');
    });
  });

  describe('#isUpdateInProgress', function() {
    var tests = Em.A([
      {checksUpdateProgress: 0, e: false},
      {checksUpdateProgress: 100, e: false},
      {checksUpdateProgress: 50, e: true}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateProgress, function() {
        view.set('footerController.checksUpdateProgress', test.checksUpdateProgress);
        expect(view.get('isUpdateInProgress')).to.equal(test.e);
      });
    });
  });

  describe('#updateStatusClass', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: 'text-success'},
      {checksUpdateStatus: 'FAILED', e: 'text-error'},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatusClass')).to.be.null;
        }
        else {
          expect(view.get('updateStatusClass')).to.equal(test.e);
        }
      })
    });
  });

  describe('#updateStatus', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: Em.I18n.t('installer.step3.warnings.updateChecks.success')},
      {checksUpdateStatus: 'FAILED', e: Em.I18n.t('installer.step3.warnings.updateChecks.failed')},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatus')).to.be.null;
        }
        else {
          expect(view.get('updateStatus')).to.equal(test.e);
        }
      })
    });
  });

});
});

;require.register("test/views/wizard/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('messages');
require('views/wizard/step3_view');
var v;
describe('App.WizardStep3View', function () {

  var view = App.WizardStep3View.create({
    monitorStatuses: function () {
    },
    content: [
      Em.Object.create({
        name: 'host1',
        bootStatus: 'PENDING',
        isChecked: false
      }),
      Em.Object.create({
        name: 'host2',
        bootStatus: 'PENDING',
        isChecked: true
      }),
      Em.Object.create({
        name: 'host3',
        bootStatus: 'PENDING',
        isChecked: true
      })
    ],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });

  describe('#watchSelection', function () {
    it('2 of 3 hosts selected', function () {
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(2);
    });
    it('all hosts selected', function () {
      view.selectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(3);
    });
    it('none hosts selected', function () {
      view.unSelectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(true);
      expect(view.get('selectedHostsCount')).to.equal(0);
    });
  });

  describe('#selectAll', function () {
    it('select all hosts', function () {
      view.selectAll();
      expect(view.get('content').everyProperty('isChecked', true)).to.equal(true);
    });
  });

  describe('#unSelectAll', function () {
    it('unselect all hosts', function () {
      view.unSelectAll();
      expect(view.get('content').everyProperty('isChecked', false)).to.equal(true);
    });
  });

  var testCases = Em.A([
    {
      title: 'none hosts',
      content: [],
      result: {
        "ALL": 0,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts RUNNING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'RUNNING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 3,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 3,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 3,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts FAILED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'FAILED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 3
      }
    },
    {
      title: 'first host is FAILED, second is RUNNING, third is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 1,
        "REGISTERING": 0,
        "REGISTERED": 1,
        "FAILED": 1
      }
    },
    {
      title: 'two hosts is REGISTERING, one is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 2,
        "REGISTERED": 1,
        "FAILED": 0
      }
    }
  ]);

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content', test.content);
        view.countCategoryHosts();
        view.get('categories').forEach(function (category) {
          expect(category.get('hostsCount')).to.equal(test.result[category.get('hostsBootStatus')])
        })
      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostsBootStatus'), function () {
            view.set('content', test.content);
            view.reopen({
              selectedCategory: category
            });
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostsBootStatus')])
          });
        });
      });
    }, this);
  });

  describe('#monitorStatuses', function() {
    var tests = Em.A([
      {
        controller: Em.Object.create({bootHosts: Em.A([])}),
        m: 'Empty hosts list',
        e: {status: 'alert-warn', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: false}),
        m: 'isWarningsLoaded false',
        e: {status: 'alert-info', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, isHostHaveWarnings: true}),
        m: 'isWarningsLoaded true, isHostHaveWarnings true',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, repoCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, repoCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, diskCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty',
        e: {status: 'alert-success', linkText: Em.I18n.t('installer.step3.noWarnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{bootStatus: 'FAILED'}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty, all failed',
        e: {status: 'alert-warn', linkText: ''}
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          controller: test.controller
        });
        v.monitorStatuses();
        expect(v.get('status')).to.equal(test.e.status);
        expect(v.get('linkText')).to.equal(test.e.linkText);
      });
    });
  });

  describe('#retrySelectedHosts', function() {
    it('should set active category "All"', function() {
      view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
      view.retrySelectedHosts();
      expect(view.get('categories').findProperty('hostsBootStatus', 'ALL').get('isActive')).to.equal(true);
    });
  });

  describe('#selectCategory', function() {
    var tests = Em.A(['ALL','RUNNING','REGISTERING','REGISTERED','FAILED']);
    tests.forEach(function(test) {
      it('should set active category "' + test + '"', function() {
        view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
        view.selectCategory({context:Em.Object.create({hostsBootStatus:test})});
        expect(view.get('categories').findProperty('hostsBootStatus', test).get('isActive')).to.equal(true);
      });
    });
  });

  describe('#countCategoryHosts', function() {
    it('should set host count for each category', function() {
      view.set('content', Em.A([
        Em.Object.create({bootStatus: 'RUNNING'}),
        Em.Object.create({bootStatus: 'REGISTERING'}),
        Em.Object.create({bootStatus: 'REGISTERED'}),
        Em.Object.create({bootStatus: 'FAILED'})
      ]));
      view.countCategoryHosts();
      expect(view.get('categories').mapProperty('hostsCount')).to.eql([4,1,1,1,1]);
    });
  });

  describe('#hostBootStatusObserver', function() {
    it('should call "Em.run.once" three times', function() {
      sinon.spy(Em.run, 'once');
      view.hostBootStatusObserver();
      expect(Em.run.once.calledThrice).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('countCategoryHosts');
      expect(Em.run.once.secondCall.args[1]).to.equal('filter');
      expect(Em.run.once.thirdCall.args[1]).to.equal('monitorStatuses');
      Em.run.once.restore();
    });
  });

  describe('#watchSelection', function() {
    describe('should set "pageChecked"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),m:'false if empty "pageContent"', e: false},
        {pageContent: Em.A([{isChecked: false}]),m:'false if not-empty "pageContent" and not all "isChecked" true', e: false},
        {pageContent: Em.A([{isChecked: true}]),m:'true if not-empty "pageContent" and all "isChecked" true', e: false}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.watchSelection();
          expect(view.get('pageChecked')).to.equal(test.e);
        });
      });
    });
    describe('should set "noHostsSelected" and "selectedHostsCount"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),content:Em.A([]),m:' - "true", "0" if content is empty',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: false})]),m:' - "true", "0" if no one isChecked',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: true}),Em.Object.create({isChecked: false})]),m:' - "false", "1" if one isChecked',e:{selectedHostsCount: 1, noHostsSelected: false}}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.set('content', test.content);
          view.watchSelection();
          expect(view.get('noHostsSelected')).to.equal(test.e.noHostsSelected);
          expect(view.get('selectedHostsCount')).to.equal(test.e.selectedHostsCount);
        });
      });
    });
  });

  describe('#watchSelectionOnce', function() {
    it('should call "Em.run.once" one time', function() {
      sinon.spy(Em.run, 'once');
      view.watchSelectionOnce();
      expect(Em.run.once.calledOnce).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('watchSelection');
      Em.run.once.restore();
    });
  });

  describe('#selectedCategory', function() {
    it('should equal category with isActive = true', function() {
      view.get('categories').findProperty('hostsBootStatus', 'FAILED').set('isActive', true);
      expect(view.get('selectedCategory.hostsBootStatus')).to.equal('FAILED');
    });
  });

  describe('#onPageChecked', function() {
    var tests = Em.A([
      {
        selectionInProgress: true,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'shouldn\'t do nothing if selectionInProgress is true',
        e: [true, false]
      },
      {
        selectionInProgress: false,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'should set each isChecked to pageChecked value',
        e: [true, true]
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          'pageContent': test.pageContent,
          'pageChecked': test.pageChecked,
          'selectionInProgress': test.selectionInProgress
        });
        v.onPageChecked();
        expect(v.get('pageContent').mapProperty('isChecked')).to.eql(test.e);
      });
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      v = App.WizardStep3View.create({
        controller: Em.Object.create({
          loadStep: Em.K
        })
      });
      sinon.spy(v.get('controller'), 'loadStep');
    });
    afterEach(function() {
      v.get('controller').loadStep.restore();
    });
    it('should call loadStep', function() {
      v.didInsertElement();
      expect(v.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe('#categoryObject', function() {
    var o;
    beforeEach(function() {
      v = App.WizardStep3View.create();
      o = v.get('categoryObject').create();
    });

    describe('#label', function() {
      it('should use value and hostCount', function() {
        o.setProperties({
          value: 'abc',
          hostsCount: 3
        });
        expect(o.get('label')).to.equal('abc (3)');
      });
    });

    describe('#itemClass', function() {
      it('should depends on isActive', function() {
        o.set('isActive', true);
        expect(o.get('itemClass')).to.equal('active');
        o.set('isActive', false);
        expect(o.get('itemClass')).to.equal('');
      });
    });

  });

});

var wView;
describe('App.WizardHostView', function() {

  beforeEach(function() {
    wView = App.WizardHostView.create({
      hostInfo: {},
      controller: Em.Object.create({
        removeHost: Em.K,
        retryHost: Em.K
      })
    });
    sinon.spy(wView.get('controller'), 'retryHost');
    sinon.spy(wView.get('controller'), 'removeHost');
  });

  afterEach(function() {
    wView.get('controller').retryHost.restore();
    wView.get('controller').removeHost.restore();
  });

  describe('#retry', function() {
    it('should call controller.retryHost', function() {
      wView.retry();
      expect(wView.get('controller').retryHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').retryHost.calledOnce).to.equal(true);
    });
  });

  describe('#remove', function() {
    it('should call controller.removeHost', function() {
      wView.remove();
      expect(wView.get('controller').removeHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').removeHost.calledOnce).to.equal(true);
    });
  });

});

});

;require.register("test/views/wizard/step5_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/wizard/step5_view');
var view;

describe('App.WizardStep5View', function() {

  beforeEach(function() {
    view = App.WizardStep5View.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#didInsertElement', function() {
    it('should call controller.loadStep', function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });

  describe('#shouldUseInputs', function() {
    it('should based on hosts count', function() {
      view.set('controller.hosts', d3.range(0, 25).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.false;
      view.set('controller.hosts', d3.range(0, 26).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.true;
      view.set('controller.hosts', d3.range(0, 24).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.false;
    });
  });

});

describe('App.SelectHostView', function() {
  var models = require('test/init_model_test');

  beforeEach(function() {
    view = App.SelectHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#click', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      models.setupStackServiceComponent();
    });

    afterEach(function() {
      view.initContent.restore();
      models.cleanStackServiceComponent();
    });

    it('should call initContent', function() {
      view.click();
      expect(view.initContent.calledOnce).to.be.true;
    });
  });

  describe('#didInsertElement', function() {

    it('should set value', function() {
      view.set('value', '');
      view.set('component', {selectedHost: 'h1'});
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', serviceComponentId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1 info');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.calledWith('ZOOKEEPER_SERVER', 'h1', 1));
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

});

describe('App.InputHostView', function() {

  beforeEach(function() {
    view = App.InputHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      view.set('content', [Em.Object.create({host_name: 'h1', host_info: 'h1 info'})]);
      view.set('component', {selectedHost: 'h1'});
    });

    afterEach(function() {
      view.initContent.restore();
    });

    it('should call initContent', function() {
      view.didInsertElement();
      expect(view.initContent.calledOnce).to.equal(true);
    });

    it('should set selectedHost host_info to value', function() {
      view.set('value', '');
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1 info');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', serviceComponentId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1 info');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.calledWith('ZOOKEEPER_SERVER', 'h1', 1));
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

  describe('#getAvailableHosts', function() {
    var tests = Em.A([
      {
        hosts: Em.A([]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Empty hosts',
        e: []
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'c1',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'c2', selectedHost: 'h1'})
        ]),
        m: 'Two hosts',
        e: ['h1', 'h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, ZOOKEEPER_SERVER',
        e: ['h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'HBASE_MASTER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HBASE_MASTER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, HBASE_MASTER',
        e: ['h2']
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.hosts', test.hosts);
        view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
        view.set('component', {component_name: test.componentName});
        view.set('controller.selectedServicesMasters', test.selectedServicesMasters);
        var r = view.getAvailableHosts();
        expect(r.mapProperty('host_name')).to.eql(test.e);
      });
    });
  });

  describe('#rebalanceComponentHostsOnce', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName not equal to componentToRebalance',
        e: {
          initContent: false
        }
      },
      {
        componentName: 'c2',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName equal to componentToRebalance',
        e: {
          initContent: true
        }
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('content', test.content);
        view.set('component', {component_name: test.componentName});
        view.set('controller.componentToRebalance', test.componentToRebalance);
        sinon.stub(view, 'initContent', Em.K);
        view.rebalanceComponentHostsOnce();
        expect(view.initContent.calledOnce).to.equal(test.e.initContent);
        view.initContent.restore();
      });
    });
  });

  describe('#initContent', function() {
    var tests = Em.A([
      {
        hosts: 25,
        m: 'not lazy loading, 25 hosts, no selected host',
        e: 25
      },
      {
        hosts: 25,
        h: 4,
        m: 'not lazy loading, 25 hosts, one selected host',
        e: 25
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.reopen({getAvailableHosts: function() {return d3.range(0, test.hosts).map(function(indx){return Em.Object.create({host_name: indx})});}});
        if (test.h) {
          view.set('selectedHost', test.h);
        }
        view.initContent();
        expect(view.get('content.length')).to.equal(test.e);
      });
    });
  });

  describe('#change', function() {

    beforeEach(function() {
      sinon.stub(view, 'changeHandler', Em.K);
    });

    afterEach(function() {
      view.changeHandler.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.set('state', 'destroyed');
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(false);
    });

    it('should toggle hostNameCheckTrigger', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(true);
    });

  });

});

describe('App.RemoveControlView', function() {

  beforeEach(function() {
    view = App.RemoveControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'removeComponent', Em.K);
    });
    afterEach(function() {
      view.get('controller').removeComponent.restore();
    });
    it('should call removeComponent', function() {
      view.set('serviceComponentId', 1);
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').removeComponent.calledWith('c1', 1)).to.equal(true);
    });
  });

});

describe('App.AddControlView', function() {

  beforeEach(function() {
    view = App.AddControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'addComponent', Em.K);
    });

    afterEach(function() {
      view.get('controller').addComponent.restore();
    });

    it('should call addComponent', function() {
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').addComponent.calledWith('c1')).to.equal(true);
    });

  });

});

});

;require.register("test/views/wizard/step6_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step6_view');
var view;

describe('App.WizardStep6View', function() {

  beforeEach(function() {
    view = App.WizardStep6View.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#content', function() {
    it('should be same to controller.hosts', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('content')).to.eql(d);
    });
  });

  describe('#filteredContent', function() {
    it('should be same to content', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('filteredContent')).to.eql(d);
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
      sinon.stub(view, 'setLabel', Em.K);
    });
    afterEach(function() {
      view.get('controller').loadStep.restore();
      App.tooltip.restore();
      view.setLabel.restore();
    });
    it('should call loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
    it('should create tooltip', function() {
      view.didInsertElement();
      expect(App.tooltip.calledOnce).to.equal(true);
    });
    it('should call setLabel if not controller.isMasters', function() {
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(view.setLabel.calledOnce).to.equal(true);
    });
  });

  describe('#setLabel', function() {
    var tests = Em.A([
      {
        clients: [{display_name: 'c1'}],
        m: 'One client',
        e: 'c1'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}],
        m: 'Two clients',
        e: 'c1 and c2.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}],
        m: 'Three clients',
        e: 'c1, c2 and c3.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}],
        m: 'Four clients',
        e: 'c1, c2, c3 and c4.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}, {display_name: 'c5'}],
        m: 'Five clients',
        e: 'c1, c2, c3, c4 and c5.'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.content', {clients: test.clients});
        view.setLabel();
        expect(view.get('label').endsWith(test.e)).to.equal(true);
      });
    });
  });

});

describe('App.WizardStep6HostView', function() {

  beforeEach(function() {
    view = App.WizardStep6HostView.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      sinon.stub(App, 'popover', Em.K);
    });
    afterEach(function() {
      App.popover.restore();
    });
    it('should create popover if not controller.isMasters', function() {
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return [{}, {}];});
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
      view.get('controller').getMasterComponentsForHost.restore();
    });
    it('shouldn\'t create popover if controller.getMasterComponentsForHost returns empty array', function() {
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return [];});
      view.set('controller.isMasters', true);
      view.didInsertElement();
      expect(App.popover.called).to.equal(false);
      view.get('controller').getMasterComponentsForHost.restore();
    });
  });

});
});

;require.register("test/views/wizard/step8_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step8_view');
var view;

describe('App.WizardStep8View', function() {

  beforeEach(function() {
    view = App.WizardStep8View.create();
  });

  describe('#didInsertElement', function() {
    it('should call loadStep', function() {
      view.set('controller', Em.Object.create({
        loadStep: Em.K
      }));
      sinon.spy(view.get('controller'), 'loadStep');
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });

  describe('#printReview', function() {
    it('should call jqprint', function() {
      sinon.stub($.fn, 'jqprint', Em.K);
      view.printReview();
      expect($.fn.jqprint.calledOnce).to.equal(true);
      $.fn.jqprint.restore();
    });
  });

  describe('#showLoadingIndicator', function() {
    it('should hide existing popup', function() {
      var popup = App.ModalPopup.show({});
      view.set('modalPopup', popup);
      view.set('controller', {isSubmitDisabled: false});
      view.showLoadingIndicator();
      expect(Em.isNone(view.get('popup'))).to.equal(true);
    });
    it('if popup exists shouldn\'t create another', function() {
      view.set('modalPopup', App.ModalPopup.show({}));
      view.set('controller', {isSubmitDisabled: true});
      sinon.spy(App.ModalPopup, 'show');
      view.showLoadingIndicator();
      expect(App.ModalPopup.show.called).to.equal(false);
      App.ModalPopup.show.restore();
    });
    it('if popup doesn\'t exist should create another', function() {
      view.set('modalPopup', null);
      view.reopen({controller: {isSubmitDisabled: true}});
      sinon.spy(App.ModalPopup, 'show');
      view.showLoadingIndicator();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });

    describe('#bodyClass', function() {

      beforeEach(function() {
        view.set('modalPopup', null);
        view.reopen({controller: {isSubmitDisabled: true}});
      });

      describe('#autoHide', function() {
        it('should be called if controller.servicesInstalled is true', function() {
          view.showLoadingIndicator();
          var v = view.get('modalPopup').get('bodyClass').create();
          v.reopen({controller: {servicesInstalled: false}, parentView: Em.Object.create({hide: Em.K})});
          sinon.spy(v.get('parentView'), 'hide');
          v.set('controller.servicesInstalled', true);
          expect(v.get('parentView').hide.calledOnce).to.equal(true);
          v.get('parentView').hide.restore();
        });
        it('shouldn\'t be called if controller.servicesInstalled is false', function() {
          view.showLoadingIndicator();
          var v = view.get('modalPopup').get('bodyClass').create();
          v.reopen({controller: {servicesInstalled: false}, parentView: Em.Object.create({hide: Em.K})});
          sinon.spy(v.get('parentView'), 'hide');
          v.set('controller.servicesInstalled', false);
          expect(v.get('parentView').hide.called).to.equal(false);
          v.get('parentView').hide.restore();
        });
      });

      describe('#ajaxQueueChangeObs', function() {
        it('should set barWidth and message', function() {
          view.showLoadingIndicator();
          var v = view.get('modalPopup').get('bodyClass').create();
          v.reopen({controller: {ajaxQueueLength: 12, ajaxRequestsQueue: Em.Object.create({queue: []})}});
          v.set('controller.ajaxRequestsQueue.queue', [{}, {}, {}, {}]);
          expect(v.get('barWidth')).to.equal('width: ' + (8 / 12 * 100) + '%;');
          expect(v.get('message')).to.equal(Em.I18n.t('installer.step8.deployPopup.message').format(8, 12));
        });
      });

    });
  });

});
});

;require.register("test/views/wizard/step9/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9/hostLogPopupBody_view');
var view;

describe('App.WizardStep9HostLogPopupBodyView', function() {

  beforeEach(function() {
    view = App.WizardStep9HostLogPopupBodyView.create({
      parentView: Em.Object.create({
        host: Em.Object.create()
      })
    });
  });

  describe('#isHeartbeatLost', function() {
    it('should depends on parentView.host.status', function() {
      view.set('parentView.host.status', 'success');
      expect(view.get('isHeartbeatLost')).to.equal(false);
      view.set('parentView.host.status', 'heartbeat_lost');
      expect(view.get('isHeartbeatLost')).to.equal(true);
    });
  });

  describe('#isNoTasksScheduled', function() {
    it('should be same to parentView.host.isNoTasksForInstall', function() {
      view.set('parentView.host.isNoTasksForInstall', true);
      expect(view.get('isNoTasksScheduled')).to.equal(true);
      view.set('parentView.host.isNoTasksForInstall', false);
      expect(view.get('isNoTasksScheduled')).to.equal(false);
    });
  });

  describe('#visibleTasks', function() {
    Em.A([
        {
          value: 'pending',
          f: ['pending', 'queued']
        },
        {
          value: 'in_progress',
          f: ['in_progress']
        },
        {
          value: 'failed',
          f: ['failed']
        },
        {
          value: 'completed',
          f: ['completed']
        },
        {
          value: 'aborted',
          f: ['aborted']
        },
        {
          value: 'timedout',
          f: ['timedout']
        },
        {
          value: 'all'
        }
      ]).forEach(function(test) {
        it(test.value, function() {
          view.reopen({
            category: Em.Object.create({value: test.value}),
            tasks: Em.A([
              {status: 'pending', isVisible: false},
              {status: 'queued', isVisible: false},
              {status: 'in_progress', isVisible: false},
              {status: 'failed', isVisible: false},
              {status: 'completed', isVisible: false},
              {status: 'aborted', isVisible: false},
              {status: 'timedout', isVisible: false}
            ])
          });
          view.visibleTasks();
          var visibleTasks = view.get('tasks').filter(function(task) {
            if (test.f) {
              return test.f.contains(task.status);
            }
            return true;
          });
          expect(visibleTasks.everyProperty('isVisible', true)).to.equal(true);
        });
    });
  });

  describe('#backToTaskList', function() {
    it('should call destroyClipBoard', function() {
      sinon.stub(view, 'destroyClipBoard', Em.K);
      view.backToTaskList();
      expect(view.destroyClipBoard.calledOnce).to.equal(true);
      view.destroyClipBoard.restore();
    });
    it('should set isLogWrapHidden to true', function() {
      view.set('isLogWrapHidden', false);
      view.backToTaskList();
      expect(view.get('isLogWrapHidden')).to.equal(true);
    });
  });

  describe('#getStartedTasks', function() {
    it('should return tasks with some status', function() {
      var logTasks = Em.A([
        {Tasks: {}}, {Tasks: {status: 's'}}, {Tasks: {status: null}}, {Tasks: {status: 'v'}}
      ]);
      expect(view.getStartedTasks({logTasks: logTasks}).length).to.equal(2);
    });
  });

  describe('#openedTask', function() {
    it('should return currently open task', function() {
      var task = Em.Object.create({id: 2});
      view.reopen({
        tasks: Em.A([
          Em.Object.create({id: 1}),
          Em.Object.create({id: 3}),
          task,
          Em.Object.create({id: 4})
        ])
      });
      view.set('parentView.c', {currentOpenTaskId: 2});
      expect(view.get('openedTask.id')).to.equal(2);
    });
  });

  describe('#tasks', function() {
    var testTask = {
      Tasks: {
        status: 'init',
        id: 1,
        request_id: 2,
        role: 'PIG',
        stderr: 'stderr',
        stdout: 'stdout',
        host_name: 'host1',
        command: 'Cmd'
      }
    };

    it('should map tasks', function() {
      view.set('parentView.host.logTasks', [testTask]);
      var t = view.get('tasks');
      expect(t.length).to.equal(1);
      var first = t[0];
      expect(first.get('id')).to.equal(1);
      expect(first.get('requestId')).to.equal(2);
      expect(first.get('command')).to.equal('cmd');
      expect(first.get('role')).to.equal('Pig');
      expect(first.get('stderr')).to.equal('stderr');
      expect(first.get('stdout')).to.equal('stdout');
      expect(first.get('isVisible')).to.equal(true);
      expect(first.get('hostName')).to.equal('host1');
    });

    it('should set cog icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'pending';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cog');
    });

    it('should set cog icon (2)', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'queued';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cog');
    });

    it('should set cogs icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'in_progress';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cogs');
    });

    it('should set ok icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'completed';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-ok');
    });

    it('should set icon-exclamation-sign icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'failed';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-exclamation-sign');
    });

    it('should set minus icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'aborted';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-minus');
    });

    it('should set time icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'timedout';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-time');
    });

  });

  describe('#toggleTaskLog', function() {
    it('isLogWrapHidden is true', function() {
      var taskInfo = {
        id: 1,
        requestId: 2
      };
      view.set('isLogWrapHidden', true);
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      sinon.spy(view.get('parentView.c'), 'loadCurrentTaskLog');
      view.toggleTaskLog({context: taskInfo});
      expect(view.get('isLogWrapHidden')).to.equal(false);
      expect(view.get('parentView.c.currentOpenTaskId')).to.equal(taskInfo.id);
      expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(taskInfo.requestId);
      expect(view.get('parentView.c').loadCurrentTaskLog.calledOnce).to.equal(true);
      view.get('parentView.c').loadCurrentTaskLog.restore();
    });
    it('isLogWrapHidden is false', function() {
      var taskInfo = {};
      view.set('isLogWrapHidden', false);
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      view.toggleTaskLog({context: taskInfo});
      expect(view.get('isLogWrapHidden')).to.equal(true);
      expect(view.get('parentView.c.currentOpenTaskId')).to.equal(0);
      expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(0);
    });
  });

});
});

;require.register("test/views/wizard/step9_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9_view');

var v;
describe('App.WizardStep9View', function () {
  beforeEach(function () {
    v = App.WizardStep9View.create({
      controller: App.WizardStep9Controller.create()
    });
  });
  var view = App.WizardStep9View.create({
    onStatus: function () {
    },
    content: [],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });
  var testCases = [
    {
      title: 'none hosts',
      content: [],
      result: {
        "all": 0,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts inProgress',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'info'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'pending'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 3,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts warning',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 3,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 3,
        "failed": 0
      }
    },
    {
      title: 'all hosts failed',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'heartbeat_lost'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 3
      }
    },
    {
      title: 'first host is failed, second is warning, third is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 1,
        "success": 1,
        "failed": 1
      }
    },
    {
      title: 'two hosts is inProgress, one is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'pending'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 2,
        "warning": 0,
        "success": 1,
        "failed": 0
      }
    }
  ];

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content', test.content);
        view.countCategoryHosts();
        view.get('categories').forEach(function (category) {
          expect(category.get('hostsCount')).to.equal(test.result[category.get('hostStatus')])
        })
      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostStatus'), function () {
            view.set('content', test.content);
            view.reopen({selectedCategory: category});
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostStatus')])
          });
        })
      });
    }, this);
  });

  describe('#isStepCompleted', function () {
    it('should be true if progress is 100', function () {
      v.set('controller.progress', '100');
      expect(v.get('isStepCompleted')).to.equal(true);
    });
    it('should be false if progress isn\'t 100', function () {
      v.set('controller.progress', '50');
      expect(v.get('isStepCompleted')).to.equal(false);
    });
  });

  describe('#content', function () {
    it('should be equal to controller.hosts', function () {
      sinon.stub(v, 'hostStatusObserver', Em.K);
      var hosts = [
        {},
        {},
        {}
      ];
      v.set('controller.hosts', hosts);
      expect(v.get('content')).to.eql(hosts);
      v.hostStatusObserver.restore();
    });
  });

  describe('#categoryObject', function () {
    it('label should contains value and hostsCount', function () {
      var value = 'v',
        hostsCount = 10,
        o = v.get('categoryObject').create({value: value, hostsCount: hostsCount});
      expect(o.get('label')).to.equal(value + ' (' + hostsCount + ')');
    });
    it('itemClass should depends on isActive', function () {
      var o = v.get('categoryObject').create();
      o.set('isActive', false);
      expect(o.get('itemClass')).to.equal('');
      o.set('isActive', true);
      expect(o.get('itemClass')).to.equal('active');
    });
  });

  describe('#isHostHeartbeatLost', function () {
    Em.A([
        {
          hostsWithHeartbeatLost: [],
          m: 'should be false if hostsWithHeartbeatLost is empty',
          e: false
        },
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          m: 'should be true if hostsWithHeartbeatLost contains some values',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          expect(v.get('isHostHeartbeatLost')).to.equal(test.e);
        })
      });
  });

  describe('#barWidth', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('barWidth')).to.equal('width: ' + w + '%;');
    });
  });

  describe('#progressMessage', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('progressMessage').contains(w)).to.equal(true);
    });
  });

  describe('#showAllHosts', function () {
    it('should set active to category with all hosts', function () {
      v.get('categories').findProperty('hostStatus', 'inProgress').set('isActive', true);
      v.showAllHosts();
      var allCategory = v.get('categories').findProperty('hostStatus', 'all');
      expect(allCategory.get('isActive')).to.equal(true);
      expect(v.get('categories').without(allCategory).everyProperty('isActive', false)).to.equal(true);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(v, 'onStatus', Em.K);
      sinon.stub(v.get('controller'), 'navigateStep', Em.K);
    });
    afterEach(function () {
      v.onStatus.restore();
      v.get('controller').navigateStep.restore();
    });
    it('should call onStatus', function () {
      v.didInsertElement();
      expect(v.onStatus.calledOnce).to.equal(true);
    });
    it('should call navigateStep', function () {
      v.didInsertElement();
      expect(v.get('controller').navigateStep.calledOnce).to.equal(true);
    });
  });

  describe('#selectCategory', function () {
    it('should set isActive true to selected category', function () {
      var event = {context: Em.Object.create({hostStatus: 'inProgress'})},
        c = v.get('categories').findProperty('hostStatus', 'inProgress');
      c.set('isActive', false);
      v.selectCategory(event);
      expect(c.get('isActive')).to.equal(true);
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          status: 'success',
          e: {
            barColor: 'progress-success',
            resultMsg: Em.I18n.t('installer.step9.status.success'),
            resultMsgColor: 'alert-success'
          }
        },
        {
          status: 'info',
          e: {
            barColor: 'progress-info',
            resultMsg: ''
          }
        },
        {
          status: 'warning',
          e: {
            barColor: 'progress-warning',
            resultMsg: Em.I18n.t('installer.step9.status.warning'),
            resultMsgColor: 'alert-warning'
          }
        },
        {
          status: 'failed',
          e: {
            barColor: 'progress-danger',
            resultMsgColor: 'alert-error'
          }
        }
      ]).forEach(function (test) {
        it(test.status, function () {
          v.set('controller.status', test.status);
          v.onStatus();
          Em.keys(test.e).forEach(function (k) {
            expect(v.get(k)).to.equal(test.e[k]);
          });
        });
      });
    Em.A([
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          startCallFailed: false,
          m: 'heartbeat lost for 2 hosts',
          resultMsg: Em.I18n.t('installer.step9.status.hosts.heartbeat_lost').format(2)
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: true,
          m: 'heartbeat not lost, startCallFailed true',
          resultMsg: Em.I18n.t('installer.step9.status.start.services.failed')
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: false,
          m: 'heartbeat not lost, startCallFailed false',
          resultMsg: Em.I18n.t('installer.step9.status.failed')
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          v.set('controller.startCallFailed', test.startCallFailed);
          v.set('controller.status', 'failed');
          v.onStatus();
          expect(v.get('resultMsg')).to.equal(test.resultMsg);
        });
      });
  });

  describe('#hostWithInstallFailed', function () {
    it('popup property failedHosts should be equal to hostsWithHeartbeatLost', function () {
      var hostsWithHeartbeatLost = [
        {},
        {}
      ];
      v.set('controller.hostsWithHeartbeatLost', hostsWithHeartbeatLost);
      var body = v.hostWithInstallFailed().get('bodyClass').create();
      expect(body.get('failedHosts')).to.eql(hostsWithHeartbeatLost);
    });
  });

});

var hv;
describe('App.HostStatusView', function () {
  beforeEach(function () {
    hv = App.HostStatusView.create();
  });
  var tests = [
    {
      p: 'isFailed',
      tests: [
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isSuccess',
      tests: [
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isWarning',
      tests: [
        {
          obj: {
            status: 'warning',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'warning',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    }
  ];
  tests.forEach(function (test) {
    describe(test.p, function () {
      test.tests.forEach(function (t) {
        var hostStatusView = App.HostStatusView.create();
        it('obj.progress = ' + t.obj.progress + '; obj.status = ' + t.obj.status, function () {
          hostStatusView.set('obj', t.obj);
          expect(hostStatusView.get(test.p)).to.equal(t.e);
        });
      });
    });
  });

  describe('#barWidth', function () {
    it('should depends of obj.progress', function () {
      hv.set('obj', {progress: '25'});
      expect(hv.get('barWidth')).to.equal('width: 25%;');
    });
  });

  describe('#didInsertElement', function () {
    it('should call onStatus', function () {
      sinon.stub(hv, 'onStatus', Em.K);
      hv.didInsertElement();
      expect(hv.onStatus.calledOnce).to.equal(true);
      hv.onStatus.restore();
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          obj: {
            status: 'info'
          },
          e: {
            barColor: 'progress-info'
          }
        },
        {
          obj: {
            status: 'warning'
          },
          e: {
            barColor: 'progress-warning'
          }
        },
        {
          obj: {
            status: 'warning',
            progress: '100'
          },
          e: {
            barColor: 'progress-warning',
            'obj.message': Em.I18n.t('installer.step9.host.status.warning')
          }
        },
        {
          obj: {
            status: 'failed'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.status.failed')
          }
        },
        {
          obj: {
            status: 'heartbeat_lost'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'heartbeat_lost',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.heartbeat_lost')
          }
        }
      ]).forEach(function (test) {
        it(JSON.stringify(test.obj), function () {
          hv.set('obj', test.obj);
          hv.onStatus();
          Em.keys(test.e).forEach(function (k) {
            expect(hv.get(k)).to.equal(test.e[k]);
          });
        });
      });
    Em.A([
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '35',
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '34',
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: '99'
          },
          progress: '35',
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          progress: '35',
          e: false
        }
      ]).forEach(function (test) {
        it(JSON.stringify(test.obj) + ' ' + test.progress, function() {
          hv.set('barColor', '');
          hv.set('obj', test.obj);
          hv.set('obj.message', '');
          hv.set('controller', {progress: test.progress});
          hv.onStatus();
          expect(hv.get('obj.message') === Em.I18n.t('installer.step9.host.status.success')).to.equal(test.e);
          expect(hv.get('barColor') === 'progress-success').to.equal(test.e);
        });
      });
  });

  describe('#hostLogPopup', function() {
    describe('#onClose', function() {
      beforeEach(function() {
        hv.set('controller', {currentOpenTaskId: 123});
        hv.set('obj', Em.Object.create());
      });
      it('popup should clear currentOpenTaskId', function() {
        hv.hostLogPopup().onClose();
        expect(hv.get('controller.currentOpenTaskId')).to.equal(0);
      });
      it('onClose popup should hide popup', function() {
        var p = hv.hostLogPopup();
        sinon.spy(p, 'hide');
        p.onClose();
        expect(p.hide.calledOnce).to.equal(true);
      });
    });
  });

});

});

;
//# sourceMappingURL=test.js.map